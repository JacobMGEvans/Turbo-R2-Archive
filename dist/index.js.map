{
  "version": 3,
  "sources": ["../node_modules/temporal-polyfill/src/dateUtils/units.ts", "../node_modules/temporal-polyfill/src/argParse/overflowHandling.ts", "../node_modules/temporal-polyfill/src/argParse/refine.ts", "../node_modules/temporal-polyfill/src/argParse/roundingMode.ts", "../node_modules/temporal-polyfill/src/utils/obj.ts", "../node_modules/temporal-polyfill/src/argParse/unitStr.ts", "../node_modules/temporal-polyfill/src/argParse/diffOptions.ts", "../node_modules/temporal-polyfill/src/argParse/roundingOptions.ts", "../node_modules/temporal-polyfill/src/dateUtils/abstract.ts", "../node_modules/temporal-polyfill/src/utils/math.ts", "../node_modules/temporal-polyfill/src/utils/string.ts", "../node_modules/temporal-polyfill/src/utils/largeInt.ts", "../node_modules/temporal-polyfill/src/dateUtils/durationFields.ts", "../node_modules/temporal-polyfill/src/dateUtils/dayAndTime.ts", "../node_modules/temporal-polyfill/src/calendarImpl/eraOrigins.ts", "../node_modules/temporal-polyfill/src/calendarImpl/calendarImpl.ts", "../node_modules/temporal-polyfill/src/calendarImpl/isoCalendarImpl.ts", "../node_modules/temporal-polyfill/src/dateUtils/epoch.ts", "../node_modules/temporal-polyfill/src/dateUtils/compare.ts", "../node_modules/temporal-polyfill/src/dateUtils/constrain.ts", "../node_modules/temporal-polyfill/src/argParse/fieldStr.ts", "../node_modules/temporal-polyfill/src/calendarImpl/gregoryCalendarImpl.ts", "../node_modules/temporal-polyfill/src/argParse/calendarDisplay.ts", "../node_modules/temporal-polyfill/src/argParse/disambig.ts", "../node_modules/temporal-polyfill/src/argParse/isoFormatOptions.ts", "../node_modules/temporal-polyfill/src/argParse/timeZoneDisplay.ts", "../node_modules/temporal-polyfill/src/dateUtils/isoFormat.ts", "../node_modules/temporal-polyfill/src/dateUtils/mixins.ts", "../node_modules/temporal-polyfill/src/argParse/offsetHandling.ts", "../node_modules/temporal-polyfill/src/dateUtils/timeZone.ts", "../node_modules/temporal-polyfill/src/dateUtils/translate.ts", "../node_modules/temporal-polyfill/src/dateUtils/offset.ts", "../node_modules/temporal-polyfill/src/dateUtils/parseRegExp.ts", "../node_modules/temporal-polyfill/src/dateUtils/parse.ts", "../node_modules/temporal-polyfill/src/dateUtils/parseRefine.ts", "../node_modules/temporal-polyfill/src/timeZoneImpl/timeZoneImpl.ts", "../node_modules/temporal-polyfill/src/timeZoneImpl/fixedTimeZoneImpl.ts", "../node_modules/temporal-polyfill/src/dateUtils/intlFormat.ts", "../node_modules/temporal-polyfill/src/native/intlUtils.ts", "../node_modules/temporal-polyfill/src/timeZoneImpl/specialCases.ts", "../node_modules/temporal-polyfill/src/timeZoneImpl/intlTimeZoneImpl.ts", "../node_modules/temporal-polyfill/src/timeZoneImpl/timeZoneImplQuery.ts", "../node_modules/temporal-polyfill/src/public/timeZone.ts", "../node_modules/temporal-polyfill/src/argParse/timeZone.ts", "../node_modules/temporal-polyfill/src/dateUtils/fromAndWith.ts", "../node_modules/temporal-polyfill/src/dateUtils/isoFieldValidation.ts", "../node_modules/temporal-polyfill/src/dateUtils/rounding.ts", "../node_modules/temporal-polyfill/src/native/intlFactory.ts", "../node_modules/temporal-polyfill/src/native/intlMixins.ts", "../node_modules/temporal-polyfill/src/dateUtils/parseDuration.ts", "../node_modules/temporal-polyfill/src/argParse/offsetDisplay.ts", "../node_modules/temporal-polyfill/src/public/plainTime.ts", "../node_modules/temporal-polyfill/src/dateUtils/diff.ts", "../node_modules/temporal-polyfill/src/public/plainYearMonth.ts", "../node_modules/temporal-polyfill/src/public/zonedDateTime.ts", "../node_modules/temporal-polyfill/src/dateUtils/relativeTo.ts", "../node_modules/temporal-polyfill/src/dateUtils/durationSpan.ts", "../node_modules/temporal-polyfill/src/dateUtils/totalUnits.ts", "../node_modules/temporal-polyfill/src/dateUtils/roundingDuration.ts", "../node_modules/temporal-polyfill/src/public/duration.ts", "../node_modules/temporal-polyfill/src/argParse/totalOptions.ts", "../node_modules/temporal-polyfill/src/public/plainDateTime.ts", "../node_modules/temporal-polyfill/src/public/plainMonthDay.ts", "../node_modules/temporal-polyfill/src/dateUtils/calendar.ts", "../node_modules/temporal-polyfill/src/calendarImpl/intlCalendarImpl.ts", "../node_modules/temporal-polyfill/src/calendarImpl/japaneseCalendarImpl.ts", "../node_modules/temporal-polyfill/src/calendarImpl/calendarImplQuery.ts", "../node_modules/temporal-polyfill/src/calendarImpl/islamicCalendarImpl.ts", "../node_modules/temporal-polyfill/src/calendarImpl/bugs.ts", "../node_modules/temporal-polyfill/src/dateUtils/week.ts", "../node_modules/temporal-polyfill/src/public/calendar.ts", "../node_modules/temporal-polyfill/src/argParse/calendar.ts", "../node_modules/temporal-polyfill/src/public/plainDate.ts", "../node_modules/temporal-polyfill/src/public/instant.ts", "../node_modules/temporal-polyfill/src/native/date.ts", "../node_modules/temporal-polyfill/src/native/intlTemporal.ts", "../node_modules/temporal-polyfill/src/public/now.ts", "../node_modules/temporal-polyfill/src/public/temporal.ts", "../node_modules/temporal-polyfill/src/utils/dom.ts", "../node_modules/temporal-polyfill/src/impl.ts", "../src/isOlderThan.ts", "../src/autoCacheBust.ts", "../node_modules/hono/dist/utils/url.js", "../node_modules/hono/dist/utils/cookie.js", "../node_modules/hono/dist/helper/cookie/index.js", "../node_modules/hono/dist/validator/validator.js", "../node_modules/@hono/zod-validator/dist/esm/index.js", "../node_modules/hono/dist/types.js", "../node_modules/hono/dist/context.js", "../node_modules/hono/dist/compose.js", "../node_modules/hono/dist/http-exception.js", "../node_modules/hono/dist/utils/body.js", "../node_modules/hono/dist/request.js", "../node_modules/hono/dist/router.js", "../node_modules/hono/dist/hono-base.js", "../node_modules/hono/dist/router/reg-exp-router/node.js", "../node_modules/hono/dist/router/reg-exp-router/trie.js", "../node_modules/hono/dist/router/reg-exp-router/router.js", "../node_modules/hono/dist/router/smart-router/router.js", "../node_modules/hono/dist/router/trie-router/node.js", "../node_modules/hono/dist/router/trie-router/router.js", "../node_modules/hono/dist/hono.js", "../node_modules/hono/dist/middleware/cors/index.js", "../node_modules/zod/lib/index.mjs", "../src/routes.ts", "../src/index.ts"],
  "sourceRoot": "./dist",
  "sourcesContent": ["// TODO: rename everything to 'sec'/'min'?\n\nexport type TimeUnitInt = 0 | 1 | 2 | 3 | 4 | 5\nexport type YearMonthUnitInt = 8 | 9\nexport type DateUnitInt = 6 | 7 | YearMonthUnitInt\nexport type UnitInt = TimeUnitInt | DateUnitInt\nexport type DayTimeUnitInt = 6 | TimeUnitInt\n\nexport const NANOSECOND = 0\nexport const MICROSECOND = 1\nexport const MILLISECOND = 2\nexport const SECOND = 3\nexport const MINUTE = 4\nexport const HOUR = 5\nexport const DAY = 6\nexport const WEEK = 7\nexport const MONTH = 8\nexport const YEAR = 9\n\nexport const nanoInMicro = 1000\nexport const nanoInMilli = 1000000\nexport const nanoInSecond = 1000000000\nexport const nanoInMinute = 60000000000\nexport const nanoInHour = 3600000000000\nexport const nanoInDay = 86400000000000\nexport const nanoIn = [\n  1,\n  nanoInMicro,\n  nanoInMilli,\n  nanoInSecond,\n  nanoInMinute,\n  nanoInHour,\n  nanoInDay,\n]\n\nexport const milliInDay = 86400000\nexport const milliInHour = 3600000\nexport const milliInMinute = 60000\nexport const milliInSecond = 1000\nexport const secondsInDay = 24 * 60 * 60\n\nexport const unitDigitMap = [ // how many digits after the decimal point for a seconds value\n  9, // nanoseconds\n  6, // microseconds\n  3, // milliseconds\n]\n\nexport function isDayTimeUnit(unit: UnitInt): unit is DayTimeUnitInt {\n  return unit <= DAY\n}\n\nexport function isDateUnit(unit: UnitInt): unit is DateUnitInt {\n  return unit >= DAY\n}\n", "import { createOptionParser } from './refine'\n\nexport const OVERFLOW_CONSTRAIN = 0\nexport const OVERFLOW_REJECT = 1\nexport type OverflowHandlingInt = 0 | 1\n\nexport interface OverflowHandlingMap {\n  constrain: 0\n  reject: 1\n}\nexport const overflowHandlingMap: OverflowHandlingMap = {\n  constrain: 0,\n  reject: 1,\n}\n\nexport const parseOverflowOption = createOptionParser(\n  'overflow',\n  overflowHandlingMap,\n  OVERFLOW_CONSTRAIN,\n)\n", "import { ValueOf } from '../utils/obj'\nimport { OVERFLOW_REJECT, OverflowHandlingInt } from './overflowHandling'\n\nexport function createOptionParser<Map>(propName: string, map: Map, defaultVal?: ValueOf<Map>): (\n  options: Record<string, unknown> | undefined, // TODO: better type\n  runtimeDefaultVal?: ValueOf<Map>,\n) => ValueOf<Map> {\n  const valueParser = createParser(propName, map, defaultVal)\n  return (\n    options: Record<string, unknown> | undefined,\n    runtimeDefaultVal?: ValueOf<Map>,\n  ) => {\n    const ensured = ensureOptionsObj(options)\n    return valueParser(ensured[propName] as any, runtimeDefaultVal)\n  }\n}\n\nexport function createParser<Map>(nameForError: string, map: Map, defaultVal?: ValueOf<Map>): (\n  arg: keyof Map | undefined,\n  runtimeDefaultVal?: ValueOf<Map>\n) => ValueOf<Map> {\n  return (\n    input: keyof Map | undefined,\n    runtimeDefaultVal?: ValueOf<Map>,\n  ): ValueOf<Map> => {\n    if (input === undefined) {\n      const d = runtimeDefaultVal ?? defaultVal\n      if (d === undefined) {\n        throw new RangeError(`Must specify a ${nameForError}`)\n      }\n      return d\n    }\n    if (map[input] === undefined) {\n      throw new RangeError(`Invalid ${nameForError}: ${input}`)\n    }\n    return map[input]\n  }\n}\n\n// TODO: better error messages for invalid properties\nexport function constrainInt(\n  val: number | undefined,\n  min: number, // inclusive. serves as default\n  max: number, // inclusive\n  overflowHandling: OverflowHandlingInt,\n): number {\n  if (val === undefined) {\n    return min\n  }\n\n  if (!Number.isFinite(val)) {\n    throw new RangeError('Number must be finite')\n  }\n\n  // convert floating-point to integer\n  val = Math.trunc(val)\n\n  const newVal = Math.min(Math.max(val, min), max)\n  if (newVal !== val && overflowHandling === OVERFLOW_REJECT) {\n    throw new RangeError('Invalid overflowed value ' + val)\n  }\n\n  return newVal\n}\n\nexport function refineFields<Map extends { [fieldName: string]: (input: unknown) => any }>(\n  input: { [FieldName in keyof Map]?: unknown },\n  refinerMap: Map,\n): { [FieldName in keyof Map]?: ReturnType<Map[FieldName]> } {\n  const res: { [FieldName in keyof Map]?: ReturnType<Map[FieldName]> } = {}\n\n  for (const fieldName in refinerMap) {\n    if (input[fieldName] !== undefined) {\n      res[fieldName] = refinerMap[fieldName](input[fieldName])\n    }\n  }\n\n  return res\n}\n\nexport function ensureOptionsObj<OptionsType>(\n  options: Partial<OptionsType> | undefined,\n  strict?: boolean,\n): Partial<OptionsType> {\n  if (options === undefined && !strict) {\n    return {}\n  }\n  if (!isObjectLike(options)) {\n    throw TypeError('options must be an object or undefined')\n  }\n  return options\n}\n\nconst objectLikeTypeRE = /object|function/\n\nexport function isObjectLike(v: any): v is Record<string, unknown> {\n  return v !== null && objectLikeTypeRE.test(typeof v)\n}\n", "import { RoundingFunc } from '../utils/math'\nimport { createOptionParser } from './refine'\n\nexport interface RoundingModeMap {\n  halfExpand: RoundingFunc\n  ceil: RoundingFunc\n  trunc: RoundingFunc\n  floor: RoundingFunc\n}\n\nconst roundingModeMap: RoundingModeMap = {\n  halfExpand: Math.round,\n  ceil: Math.ceil,\n  trunc: Math.trunc,\n  floor: Math.floor,\n}\n\n// TODO: start using ENUM-like types. It's bad to have caller code referencing Math.* functions\n\nexport const parseRoundingModeOption = createOptionParser(\n  'roundingMode',\n  roundingModeMap,\n  // TODO: always default to Math.trunc?\n)\n", "export type ValueOf<T> = T[keyof T]\ntype GenericHash = Record<string, unknown>\n\n// TODO: just use Symbols instead?\n\n// The `object` type is literally required for WeakMap\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function createWeakMap<Subject extends object, Storage>(): [\n  (obj: Subject) => Storage, // getter\n  (obj: Subject, storage: Storage) => void // setter\n] {\n  const map = new WeakMap<Subject, Storage>()\n  return [\n    map.get.bind(map) as (obj: Subject) => Storage, // assume always previously set\n    map.set.bind(map),\n  ]\n}\n\nexport function attachGetters<Obj>(\n  ObjClass: { prototype: Obj },\n  getters: { [methodName: string]: (this: Obj) => unknown },\n): void {\n  Object.defineProperties(\n    ObjClass.prototype,\n    mapHash(\n      getters,\n      (func) => ({ get: func }),\n    ),\n  )\n}\n\nexport function mapHash<Hash, ResType>(\n  hash: Hash,\n  func: (input: ValueOf<Hash>, key: string) => ResType,\n): { [Key in keyof Hash]: ResType } {\n  const res = {} as { [Key in keyof Hash]: ResType }\n  for (const key in hash) {\n    res[key] = func(hash[key], key)\n  }\n  return res\n}\n\nexport function mapHashByKeys<PropInputType, PropOutputType>(\n  input: { [prop: string]: PropInputType },\n  keys: string[],\n  func: (inputProp: PropInputType) => PropOutputType,\n): { [prop: string]: PropOutputType } {\n  const output = {} as { [prop: string]: PropOutputType }\n\n  for (const key of keys) {\n    output[key] = func(input[key])\n  }\n\n  return output\n}\n\nexport function excludeUndefined(obj: GenericHash): GenericHash {\n  const res: GenericHash = {}\n  for (const key in obj) {\n    if (obj[key] !== undefined) {\n      res[key] = obj[key]\n    }\n  }\n  return res\n}\n\nexport function strArrayToHash<FieldType>(\n  strs: string[],\n  func: (str: string, index: number) => FieldType,\n): { [key: string]: FieldType } {\n  const res: { [key: string]: FieldType } = {}\n  strs.forEach((str, i) => {\n    res[str] = func(str, i)\n  })\n  return res\n}\n", "import { Temporal } from 'temporal-spec'\nimport { UnsignedDurationFields } from '../dateUtils/durationFields'\nimport { UnitInt } from '../dateUtils/units'\nimport { strArrayToHash } from '../utils/obj'\n\n// These names must match the indexes of the Unit integers\n\nexport const timeUnitNames: Temporal.TimeUnit[] = [\n  'nanosecond',\n  'microsecond',\n  'millisecond',\n  'second',\n  'minute',\n  'hour',\n]\nexport const dateUnitNames: Temporal.DateUnit[] = [\n  'day',\n  'week',\n  'month',\n  'year',\n]\nexport const unitNames: Temporal.DateTimeUnit[] = [\n  ...timeUnitNames,\n  ...dateUnitNames,\n]\n\n// Duration / Plurals\n// TODO: use Temporal.PluralUnit type somehow?\n\nexport const durationUnitNames: (keyof UnsignedDurationFields)[] = unitNames.map(\n  (unit) => (unit + 's') as keyof UnsignedDurationFields,\n)\n\n// Parsing\n\nconst unitMap = strArrayToHash(unitNames, (_str, i) => i)\nconst pluralUnitMap = strArrayToHash(durationUnitNames, (_str, i) => i)\n\nexport function parseUnit<UnitType extends UnitInt>(\n  input: Temporal.DateTimeUnit | Temporal.PluralUnit<Temporal.DateTimeUnit> | undefined,\n  defaultUnit: UnitType | undefined,\n  minUnit: UnitType,\n  maxUnit: UnitType,\n): UnitType {\n  let num: UnitType\n  if (input === undefined) {\n    if (defaultUnit === undefined) {\n      throw new RangeError('Unit is required') // TOOD: better error message with setting name\n    }\n    num = defaultUnit\n  } else {\n    num = (unitMap[input] ?? pluralUnitMap[input]) as UnitType\n\n    if (num === undefined || num < minUnit || num > maxUnit) {\n      throw new RangeError('Invalid unit ' + input) // TOOD: better error message with setting name\n    }\n  }\n\n  return num\n}\n", "import { Temporal } from 'temporal-spec'\nimport { DAY, UnitInt, nanoIn } from '../dateUtils/units'\nimport { RoundingFunc } from '../utils/math'\nimport { ensureOptionsObj } from './refine'\nimport { parseRoundingModeOption } from './roundingMode'\nimport { parseUnit } from './unitStr'\n\nexport interface DiffConfig<UnitType extends UnitInt = UnitInt> {\n  smallestUnit: UnitType\n  largestUnit: UnitType\n  roundingFunc: RoundingFunc\n  roundingIncrement: number\n}\n\nexport function parseDiffOptions<\n  UnitArg extends Temporal.DateTimeUnit,\n  UnitIntType extends UnitInt\n>(\n  options: Temporal.DifferenceOptions<UnitArg> | undefined,\n  largestUnitDefault: UnitIntType,\n  smallestUnitDefault: UnitIntType,\n  minUnit: UnitIntType,\n  maxUnit: UnitIntType,\n  forDurationRounding?: boolean, // TODO: change to 'defaultRoundingFunc'\n): DiffConfig<UnitIntType> {\n  const ensuredOptions = ensureOptionsObj(options)\n  const roundingIncrement = ensuredOptions.roundingIncrement ?? 1\n  const smallestUnit = parseUnit(ensuredOptions.smallestUnit, smallestUnitDefault, minUnit, maxUnit)\n  const roundingFunc = parseRoundingModeOption(\n    ensuredOptions,\n    forDurationRounding ? Math.round : Math.trunc,\n  )\n\n  let largestUnitArg = ensuredOptions.largestUnit\n  if (largestUnitArg === 'auto') {\n    largestUnitArg = undefined\n  }\n\n  largestUnitDefault = Math.max(largestUnitDefault, smallestUnit) as UnitIntType\n  const largestUnit = parseUnit(largestUnitArg, largestUnitDefault, minUnit, maxUnit)\n\n  if (smallestUnit > largestUnit) {\n    throw new RangeError('Bad smallestUnit/largestUnit')\n  }\n\n  if (smallestUnit < DAY) {\n    const largerNano = nanoIn[smallestUnit + 1]\n    const incNano = nanoIn[smallestUnit] * roundingIncrement\n\n    if (largerNano === incNano) {\n      throw new RangeError('Must not equal larger unit')\n    }\n\n    if (largerNano % incNano) {\n      throw new RangeError('Must divide into larger unit')\n    }\n  }\n\n  return {\n    smallestUnit,\n    largestUnit,\n    roundingFunc,\n    roundingIncrement,\n  }\n}\n", "import { Temporal } from 'temporal-spec'\nimport { DayTimeUnit } from '../dateUtils/dayAndTime'\nimport { DAY, DayTimeUnitInt, nanoIn, nanoInDay } from '../dateUtils/units'\nimport { RoundingFunc } from '../utils/math'\nimport { ensureOptionsObj } from './refine'\nimport { parseRoundingModeOption } from './roundingMode'\nimport { parseUnit } from './unitStr'\n\nexport interface RoundingConfig<UnitType extends DayTimeUnitInt = DayTimeUnitInt> {\n  smallestUnit: UnitType\n  roundingFunc: RoundingFunc\n  incNano: number\n}\n\nexport function parseRoundingOptions<\n  UnitArgType extends DayTimeUnit,\n  UnitType extends DayTimeUnitInt\n>(\n  options: Temporal.RoundTo<UnitArgType> | UnitArgType,\n  minUnit: UnitType,\n  maxUnit: UnitType,\n  relaxedDivisibility?: boolean,\n): RoundingConfig<UnitType> {\n  const optionsObj: Temporal.RoundTo<UnitArgType> | undefined =\n    typeof options === 'string'\n      ? { smallestUnit: options }\n      : options\n\n  const ensuredOptions = ensureOptionsObj(optionsObj, true) // strict=true\n  const roundingIncrement = ensuredOptions.roundingIncrement ?? 1\n  const smallestUnit = parseUnit(ensuredOptions.smallestUnit, undefined, minUnit, maxUnit)\n  const roundingFunc = parseRoundingModeOption(ensuredOptions, Math.round)\n  const incNano = nanoIn[smallestUnit] * roundingIncrement\n\n  if (smallestUnit === DAY) {\n    if (roundingIncrement !== 1) {\n      throw new RangeError('When smallestUnit is days, roundingIncrement must be 1')\n    }\n  } else {\n    const largerNano = relaxedDivisibility ? nanoInDay : nanoIn[smallestUnit + 1]\n\n    if (!relaxedDivisibility && largerNano === incNano) {\n      throw new RangeError('Must not equal larger unit')\n    }\n\n    if (largerNano % incNano) {\n      throw new RangeError('Must divide into larger unit')\n    }\n  }\n\n  return {\n    smallestUnit,\n    roundingFunc,\n    incNano,\n  }\n}\n", "import { createWeakMap } from '../utils/obj'\n\n// weird to have this here\n// to prevent circular reference\nexport const formatFactoryFactorySymbol = Symbol()\n\n// Functions\n\nexport function ensureObj<Obj, ObjArg, OtherArgs extends any[]>(\n  ObjClass: {\n    new(...constructorArgs: any[]): Obj\n    from(fromArg: ObjArg, ...otherArgs: OtherArgs): Obj\n  },\n  arg: ObjArg,\n  ...otherArgs: OtherArgs\n): Obj {\n  if (arg instanceof ObjClass) {\n    return arg\n  }\n  return ObjClass.from(arg, ...otherArgs)\n}\n\n// Classes\n\nexport abstract class AbstractObj {\n  abstract toString(): string\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport abstract class AbstractNoValueObj extends AbstractObj {\n  valueOf(): never {\n    throw new Error('Cannot convert object using valueOf')\n  }\n}\n\nconst [getISOFields, setISOFields] = createWeakMap<AbstractISOObj<unknown>, any>()\n\nexport abstract class AbstractISOObj<ISOFields> extends AbstractNoValueObj {\n  constructor(isoFields: ISOFields) {\n    super()\n    setISOFields(this, Object.freeze(isoFields))\n  }\n\n  getISOFields(): ISOFields {\n    return getISOFields(this)\n  }\n}\n", "import { Temporal } from 'temporal-spec'\nimport { nanoInMinute } from '../dateUtils/units'\nimport { LargeInt } from './largeInt'\n\nexport type RoundingFunc = (n: number) => number\n\nexport function compareValues(a: number, b: number): Temporal.ComparisonResult {\n  if (a < b) {\n    return -1\n  } else if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nexport function numSign(num: number): Temporal.ComparisonResult {\n  return compareValues(num, 0)\n}\n\nexport function roundToIncrement(\n  num: number,\n  inc: number,\n  roundingFunc: RoundingFunc,\n): number {\n  return roundingFunc(num / inc) * inc\n}\n\nexport function roundToMinute(nano: number): number {\n  return roundToIncrement(nano, nanoInMinute, halfExpand)\n}\n\n// like round, but does rounds negatives \"down\" (closer to -0.9)\n// use elsewhere?\nfunction halfExpand(n: number) {\n  return Math.round(Math.abs(n)) * numSign(n)\n}\n\nexport function roundToIncrementBI(\n  num: LargeInt,\n  inc: number,\n  roundingFunc: RoundingFunc,\n): LargeInt {\n  const wholeUnits = num.div(inc)\n  const wholeNum = wholeUnits.mult(inc)\n  const leftover = num.sub(wholeNum).toNumber()\n  return wholeNum.add(roundingFunc(leftover / inc) * inc)\n}\n\n// wraps `n` to 0...max (not including max)\nexport function positiveModulo(n: number, max: number): number {\n  return (n % max + max) % max\n}\n", "\nexport function capitalizeFirstLetter(s: string): string {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\n/*\nconverts a positive integer to a string with a guaranteed length, padding zeros on the left side\n*/\nexport function padZeros(num: number, length: number): string {\n  return padStart(String(num), length, '0')\n}\n\nexport function padStart(str: string, len: number, padChar: string): string {\n  return buildPadding(str, len, padChar) + str\n}\n\nexport function padEnd(str: string, len: number, padChar: string): string {\n  return str + buildPadding(str, len, padChar)\n}\n\nfunction buildPadding(str: string, len: number, padChar: string): string {\n  return new Array(Math.max(0, len - str.length + 1)).join(padChar)\n}\n\nexport function getSignStr(num: number): string {\n  return num < 0 ? '-' : '+'\n}\n", "import { Temporal } from 'temporal-spec'\nimport { compareValues, numSign } from './math'\nimport { padEnd } from './string'\n\n// MAX_SAFE_INTEGER has 16 digits, but go lower so low value doesn't overflow\nconst maxLowDigits = 8\nconst maxLowNum = Math.pow(10, maxLowDigits)\n\nexport type LargeIntArgStrict = LargeInt | bigint | string\nexport type LargeIntArg = LargeIntArgStrict | number // allow number, which might loose precision\n\nexport class LargeInt {\n  constructor(\n    public high: number,\n    public low: number,\n  ) {}\n\n  sign(): Temporal.ComparisonResult {\n    return numSign(this.high) || numSign(this.low)\n  }\n\n  neg(): LargeInt {\n    return new LargeInt(-this.high || 0, -this.low || 0) // prevents -0\n  }\n\n  abs(): LargeInt {\n    return this.sign() < 0 ? this.neg() : this\n  }\n\n  add(input: LargeInt | number): LargeInt {\n    const [high, low] = getHighLow(input)\n    return balanceAndCreate(this.high + high, this.low + low)\n  }\n\n  sub(input: LargeInt | number): LargeInt {\n    const [high, low] = getHighLow(input)\n    return balanceAndCreate(this.high - high, this.low - low)\n  }\n\n  mult(n: number): LargeInt {\n    return balanceAndCreate(this.high * n, this.low * n)\n  }\n\n  div(n: number): LargeInt {\n    const highFloat = this.high / n\n    let highStr = String(highFloat) // more exact output than toFixed\n\n    if (highStr.indexOf('e-') !== -1) { // has negative scientific notation?\n      highStr = highFloat.toFixed(20) // return maximum-guaranteed precision\n    }\n\n    const highDot = highStr.indexOf('.')\n    let lowScraps = 0\n\n    if (highDot !== -1) {\n      let afterDot = highStr.substr(highDot + 1)\n      afterDot = padEnd(afterDot, maxLowDigits, '0')\n      afterDot = afterDot.substr(0, maxLowDigits)\n      lowScraps = parseInt(afterDot) * (numSign(highFloat) || 1)\n    }\n\n    const high = Math.trunc(highFloat) || 0 // prevent -0\n    const low = Math.trunc(this.low / n) + lowScraps\n\n    return balanceAndCreate(high, low)\n  }\n\n  toNumber(): number {\n    return this.high * maxLowNum + this.low\n  }\n\n  toBigInt(): bigint {\n    return BigInt(this.high) * BigInt(maxLowNum) + BigInt(this.low)\n  }\n\n  // valueOf(): void {\n  //   throw new Error('Cant get valueOf of LargeInt')\n  // }\n}\n\nexport function createLargeInt(input: LargeIntArg): LargeInt\nexport function createLargeInt(input: LargeIntArgStrict, strict: true): LargeInt\nexport function createLargeInt(input: LargeIntArg, strict?: true): LargeInt {\n  let high: number\n  let low: number\n  if (input instanceof LargeInt) {\n    high = input.high\n    low = input.low\n  } else if (typeof input === 'number') { // TODO: don't allow this in Instant or ZonedDateTime\n    if (strict) {\n      throw new TypeError('Must supply bigint, not number')\n    }\n    high = Math.trunc(input / maxLowNum)\n    low = input % maxLowNum || 0\n  } else if (typeof input === 'bigint') {\n    const maxNumBI = BigInt(maxLowNum)\n    high = Number(input / maxNumBI)\n    low = Number(input % maxNumBI || 0)\n  } else if (typeof input === 'string') { // TODO: write test\n    input = input.trim()\n    if (input.match(/\\D/)) {\n      throw new SyntaxError(`Cannot parse ${input} to a BigInt`)\n    }\n    const gapIndex = input.length - maxLowDigits\n    high = Number(input.substr(gapIndex))\n    low = Number(input.substr(0, gapIndex))\n  } else {\n    throw new Error('Invalid type of BigNano')\n  }\n  return new LargeInt(high, low)\n}\n\nexport function compareLargeInts(a: LargeInt, b: LargeInt): Temporal.ComparisonResult {\n  return compareValues(a.high, b.high) || compareValues(a.low, b.low)\n}\n\nfunction getHighLow(input: LargeInt | number): [number, number] {\n  if (typeof input === 'number') {\n    return [0, input]\n  }\n  return [input.high, input.low]\n}\n\nfunction balanceAndCreate(high: number, low: number): LargeInt {\n  let newLow = low % maxLowNum || 0\n  let newHigh = high + Math.trunc(low / maxLowNum)\n  const signHigh = numSign(newHigh) // all signs must equal this\n  const signLow = numSign(newLow)\n\n  // ensure same signs. more performant way to do this?\n  if (signLow && signHigh && signLow !== signHigh) {\n    newHigh += signLow\n    newLow -= maxLowNum * signLow\n  }\n\n  return new LargeInt(newHigh, newLow)\n}\n", "import { Temporal } from 'temporal-spec'\nimport { durationUnitNames } from '../argParse/unitStr'\nimport { numSign } from '../utils/math'\nimport { mapHashByKeys } from '../utils/obj'\nimport { NANOSECOND, UnitInt, YEAR } from './units'\n\n// duration\n// special note about not doing spreads\n// NO.... just use the internal props instead!\n\nexport interface DurationTimeFields {\n  hours: number\n  minutes: number\n  seconds: number\n  milliseconds: number\n  microseconds: number\n  nanoseconds: number\n}\n\nexport interface UnsignedDurationFields extends DurationTimeFields {\n  years: number\n  months: number\n  weeks: number\n  days: number\n}\n\n// prefer this over unsigned\nexport interface DurationFields extends UnsignedDurationFields {\n  sign: Temporal.ComparisonResult\n}\n\n// special note about not doing spreads\n\nconst durationFieldNames: (keyof DurationFields)[] =\n  (durationUnitNames as (keyof DurationFields)[]).concat('sign')\n\ntype NumberFields = { [prop: string]: number }\n\nexport function negateDuration(fields: DurationFields): DurationFields {\n  return mapHashByKeys(\n    fields as unknown as NumberFields,\n    durationFieldNames,\n    (n: number) => -n || 0, // prevent -0 // TODO: make general util\n  ) as unknown as DurationFields\n}\n\nexport function absDuration(fields: DurationFields): DurationFields {\n  return mapHashByKeys(\n    fields as unknown as NumberFields,\n    durationFieldNames,\n    (n: number) => Math.abs(n), // TODO: make general util? Just pass-in Math.abs?\n  ) as unknown as DurationFields\n}\n\n// TODO: rename. confusing with 'override'\nexport function mergeDurations(d0: DurationFields, d1: DurationFields): DurationFields {\n  return {\n    sign: d0.sign || d1.sign,\n    years: d0.years + d1.years,\n    months: d0.months + d1.months,\n    weeks: d0.weeks + d1.weeks,\n    days: d0.days + d1.days,\n    hours: d0.hours + d1.hours,\n    minutes: d0.minutes + d1.minutes,\n    seconds: d0.seconds + d1.seconds,\n    milliseconds: d0.milliseconds + d1.milliseconds,\n    microseconds: d0.microseconds + d1.microseconds,\n    nanoseconds: d0.nanoseconds + d1.nanoseconds,\n  }\n}\n\n// workaround for not being able to do spreads\n// TODO: use refineDuration somehow?\nexport function overrideDuration(d0: DurationFields, d1: Partial<DurationFields>): DurationFields {\n  return signDuration({\n    years: d1.years ?? d0.years,\n    months: d1.months ?? d0.months,\n    weeks: d1.weeks ?? d0.weeks,\n    days: d1.days ?? d0.days,\n    hours: d1.hours ?? d0.hours,\n    minutes: d1.minutes ?? d0.minutes,\n    seconds: d1.seconds ?? d0.seconds,\n    milliseconds: d1.milliseconds ?? d0.milliseconds,\n    microseconds: d1.microseconds ?? d0.microseconds,\n    nanoseconds: d1.nanoseconds ?? d0.nanoseconds,\n  })\n}\n\nexport function refineDurationNumbers(unsignedFields: UnsignedDurationFields): DurationFields {\n  const fields = signDuration(unsignedFields)\n  const { sign } = fields\n\n  for (const fieldName of durationUnitNames) {\n    const fieldNum = fields[fieldName as keyof UnsignedDurationFields]\n    const fieldSign = numSign(fields[fieldName as keyof UnsignedDurationFields]!)\n\n    if (fieldSign && fieldSign !== sign) {\n      throw new RangeError('All fields must be same sign')\n    }\n\n    if (!Number.isInteger(fieldNum)) {\n      throw new RangeError('Duration fields must be integers')\n    }\n  }\n\n  return fields\n}\n\nexport function signDuration(fields: UnsignedDurationFields): DurationFields {\n  return { ...fields, sign: computeDurationSign(fields) }\n}\n\nfunction computeDurationSign(fields: UnsignedDurationFields): Temporal.ComparisonResult {\n  let sign: Temporal.ComparisonResult = 0\n\n  for (const fieldName of durationUnitNames) {\n    const fieldNum = fields[fieldName as keyof UnsignedDurationFields]\n\n    if (fieldNum) {\n      sign = numSign(fields[fieldName])\n      break\n    }\n  }\n\n  return sign\n}\n\nexport function computeLargestDurationUnit(dur: DurationFields): UnitInt {\n  let unit: UnitInt = YEAR\n\n  while (\n    unit > NANOSECOND &&\n    !dur[durationUnitNames[unit]]\n  ) {\n    unit--\n  }\n\n  return (unit as UnitInt) // wtf\n}\n", "import { Temporal } from 'temporal-spec'\nimport { LargeInt, createLargeInt } from '../utils/largeInt'\nimport { DurationFields, DurationTimeFields, signDuration } from './durationFields'\nimport { ISOTimeFields } from './isoFields'\nimport { LocalTimeFields } from './localFields'\nimport {\n  DAY,\n  DayTimeUnitInt,\n  HOUR,\n  MICROSECOND,\n  MILLISECOND,\n  MINUTE,\n  SECOND,\n  nanoInDay,\n  nanoInHour,\n  nanoInMicro,\n  nanoInMilli,\n  nanoInMinute,\n  nanoInSecond,\n} from './units'\n\n// weird place for this\nexport type DayTimeUnit = 'day' | Temporal.TimeUnit\n\nexport const zeroISOTimeFields: ISOTimeFields = {\n  isoHour: 0,\n  isoMinute: 0,\n  isoSecond: 0,\n  isoMillisecond: 0,\n  isoMicrosecond: 0,\n  isoNanosecond: 0,\n}\n\nexport const zeroDurationTimeFields: DurationTimeFields = {\n  hours: 0,\n  minutes: 0,\n  seconds: 0,\n  milliseconds: 0,\n  microseconds: 0,\n  nanoseconds: 0,\n}\n\n// fields -> fields\n// -------------------------------------------------------------------------------------------------\n\nexport function partialLocalTimeToISO(fields: Partial<LocalTimeFields>): ISOTimeFields {\n  return {\n    isoHour: fields.hour || 0,\n    isoMinute: fields.minute || 0,\n    isoSecond: fields.second || 0,\n    isoMillisecond: fields.millisecond || 0,\n    isoMicrosecond: fields.microsecond || 0,\n    isoNanosecond: fields.nanosecond || 0,\n  }\n}\n\n// fields -> nano\n// -------------------------------------------------------------------------------------------------\n\nexport function durationDayTimeToNano(fields: DurationFields): LargeInt {\n  return createLargeInt(nanoInDay)\n    .mult(fields.days)\n    .add(durationTimeToNano(fields))\n}\n\n// must return bigint because there could be huge hour value,\n// which would cause the nanosecond's precision to max out.\nexport function durationTimeToNano(fields: DurationTimeFields): LargeInt {\n  return createLargeInt(fields.nanoseconds)\n    .add(createLargeInt(fields.microseconds).mult(nanoInMicro))\n    .add(createLargeInt(fields.milliseconds).mult(nanoInMilli))\n    .add(createLargeInt(fields.seconds).mult(nanoInSecond))\n    .add(createLargeInt(fields.minutes).mult(nanoInMinute))\n    .add(createLargeInt(fields.hours).mult(nanoInHour))\n}\n\nexport function isoTimeToNano(fields: ISOTimeFields): number {\n  return fields.isoHour * nanoInHour +\n    fields.isoMinute * nanoInMinute +\n    fields.isoSecond * nanoInSecond +\n    fields.isoMillisecond * nanoInMilli +\n    fields.isoMicrosecond * nanoInMicro +\n    fields.isoNanosecond\n}\n\n// nano -> fields\n// -------------------------------------------------------------------------------------------------\n\nexport function nanoToDuration(nano: LargeInt, largestUnit: DayTimeUnitInt): DurationFields {\n  let days = 0\n  let hours = 0\n  let minutes = 0\n  let seconds = 0\n  let milliseconds = 0\n  let microseconds = 0\n  let temp: LargeInt\n\n  switch (largestUnit) {\n    case DAY:\n      temp = nano.div(nanoInDay)\n      days = temp.toNumber()\n      nano = nano.sub(temp.mult(nanoInDay))\n      // fall through\n    case HOUR:\n      temp = nano.div(nanoInHour)\n      hours = temp.toNumber()\n      nano = nano.sub(temp.mult(nanoInHour))\n      // fall through\n    case MINUTE:\n      temp = nano.div(nanoInMinute)\n      minutes = temp.toNumber()\n      nano = nano.sub(temp.mult(nanoInMinute))\n      // fall through\n    case SECOND:\n      temp = nano.div(nanoInSecond)\n      seconds = temp.toNumber()\n      nano = nano.sub(temp.mult(nanoInSecond))\n      // fall through\n    case MILLISECOND:\n      temp = nano.div(nanoInMilli)\n      milliseconds = temp.toNumber()\n      nano = nano.sub(temp.mult(nanoInMilli))\n      // fall through\n    case MICROSECOND:\n      temp = nano.div(nanoInMicro)\n      microseconds = temp.toNumber()\n      nano = nano.sub(temp.mult(nanoInMicro))\n  }\n\n  return signDuration({\n    years: 0,\n    months: 0,\n    weeks: 0,\n    days,\n    hours,\n    minutes,\n    seconds,\n    milliseconds,\n    microseconds,\n    nanoseconds: nano.toNumber(),\n  })\n}\n\n/*\nEnsures the resulting ISOTimeFields are positive and within 24 hours.\nWill adjust dayDelta if necessary.\n*/\nexport function nanoToISOTime(timeNano: number): [ISOTimeFields, number] {\n  const dayDelta = Math.floor(timeNano / nanoInDay)\n  timeNano -= dayDelta * nanoInDay // ensures timeNano becomes positive\n\n  const isoHour = Math.floor(timeNano / nanoInHour)\n  timeNano -= isoHour * nanoInHour\n\n  const isoMinute = Math.floor(timeNano / nanoInMinute)\n  timeNano -= isoMinute * nanoInMinute\n\n  const isoSecond = Math.floor(timeNano / nanoInSecond)\n  timeNano -= isoSecond * nanoInSecond\n\n  const isoMillisecond = Math.floor(timeNano / nanoInMilli)\n  timeNano -= isoMillisecond * nanoInMilli\n\n  const isoMicrosecond = Math.floor(timeNano / nanoInMicro)\n  timeNano -= isoMicrosecond * nanoInMicro\n\n  const isoTimeFields: ISOTimeFields = {\n    isoHour,\n    isoMinute,\n    isoSecond,\n    isoMillisecond,\n    isoMicrosecond,\n    isoNanosecond: timeNano,\n  }\n\n  return [isoTimeFields, dayDelta]\n}\n", "\n// for converting from [era,eraYear] -> year\n// if origin is >=0,\n//   year = origin + eraYear\n// if origin is <0, consider the era to be 'reverse' direction\n//   year = -origin - eraYear\n//   year = -(origin + eraYear)\nexport const eraOrigins: {\n  [calendarID: string]: { [era: string]: number }\n} = {\n  gregory: {\n    bce: -1,\n    ce: 0,\n  },\n  ethioaa: {\n    era0: 0,\n  },\n  ethiopic: {\n    era0: 0,\n    era1: 5500,\n  },\n  coptic: {\n    era0: -1,\n    era1: 0,\n  },\n  roc: {\n    beforeroc: -1,\n    minguo: 0,\n  },\n  buddhist: {\n    be: 0,\n  },\n  islamic: {\n    ah: 0,\n  },\n  indian: {\n    saka: 0,\n  },\n  persian: {\n    ap: 0,\n  },\n  japanese: {\n    bce: -1,\n    ce: 0,\n    meiji: 1867,\n    taisho: 1911,\n    showa: 1925,\n    heisei: 1988,\n    reiwa: 2018,\n  },\n}\n", "import { numSign } from '../utils/math'\nimport { padZeros } from '../utils/string'\nimport { eraOrigins } from './eraOrigins'\n\nexport interface CalendarImplFields { // like DateFields, but without monthCode\n  era: string | undefined\n  eraYear: number | undefined\n  year: number\n  month: number\n  day: number\n}\n\nexport interface CalendarImplFieldsDumb { // like CalendarImplFields, but with month string\n  era: string | undefined\n  eraYear: number | undefined\n  year: number,\n  month: string,\n  day: number\n}\n\nexport abstract class CalendarImpl {\n  constructor(\n    public id: string,\n  ) {}\n\n  // ISO -> Calendar-dependent\n\n  abstract computeFields(epochMilli: number): CalendarImplFields\n\n  // Calendar-dependent computation\n  // caller is responsible for constraining given values\n\n  abstract epochMilliseconds(year: number, month: number, day: number): number\n  abstract daysInMonth(year: number, month: number): number\n  abstract monthsInYear(year: number): number\n  abstract inLeapYear(year: number): boolean\n  abstract guessYearForMonthDay(monthCode: string, day: number): number\n  abstract normalizeISOYearForMonthDay(isoYear: number): number\n\n  // month -> monthCode\n  monthCode(month: number, _year: number): string {\n    return 'M' + padZeros(month, 2)\n  }\n\n  // monthCode -> month\n  // not responsible for constraining\n  // TODO: throw error when not starting with M?\n  convertMonthCode(monthCode: string, _year: number): [\n    number, // month\n    boolean, // unusedLeap (a valid 'L', but not used in this year)\n  ] {\n    // TODO: more DRY\n    const monthCodeIsLeap = /L$/.test(monthCode)\n    const monthCodeInt = parseInt(monthCode.substr(1)) // chop off 'M'\n\n    if (monthCodeIsLeap) {\n      throw new RangeError('Calendar system doesnt support leap months') // TODO: more DRY\n    }\n\n    return [monthCodeInt, false]\n  }\n}\n\n// eraYear -> year\nexport function convertEraYear(\n  calendarID: string,\n  eraYear: number,\n  era: string,\n  fromDateTimeFormat?: boolean,\n): number {\n  let origin = eraOrigins[getCalendarIDBase(calendarID)]?.[era]\n\n  if (origin === undefined) {\n    if (fromDateTimeFormat) {\n      origin = 0\n    } else {\n      throw new Error('Unkown era ' + era)\n    }\n  }\n\n  // see the origin format in the config file\n  return (origin + eraYear) * (numSign(origin) || 1)\n}\n\n// TODO: somehow combine with convertEraYear\nexport function hasEras(calendarID: string): boolean {\n  return eraOrigins[getCalendarIDBase(calendarID)] !== undefined\n}\n\nexport function getCalendarIDBase(calendarID: string): string {\n  return calendarID.split('-')[0]\n}\n", "import { epochMilliToISOFields, isoEpochLeapYear, isoToEpochMilli } from '../dateUtils/epoch'\nimport { CalendarImpl, CalendarImplFields } from './calendarImpl'\n\nexport class ISOCalendarImpl extends CalendarImpl {\n  computeFields(epochMilli: number): CalendarImplFields {\n    const fields = epochMilliToISOFields(epochMilli)\n    return {\n      era: undefined,\n      eraYear: undefined,\n      year: fields.isoYear,\n      month: fields.isoMonth,\n      day: fields.isoDay,\n    }\n  }\n\n  epochMilliseconds(year: number, month: number, day: number): number {\n    return isoToEpochMilli(year, month, day)\n  }\n\n  // will work for any year, not just years within valid Date range\n  daysInMonth(year: number, month: number): number {\n    if (month === 2) {\n      return this.inLeapYear(year) ? 29 : 28\n    }\n    if (month === 4 || month === 6 || month === 9 || month === 11) {\n      return 30\n    }\n    return 31\n  }\n\n  monthsInYear(): number {\n    return 12\n  }\n\n  inLeapYear(year: number): boolean {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n  }\n\n  guessYearForMonthDay(): number {\n    return isoEpochLeapYear\n  }\n\n  normalizeISOYearForMonthDay(): number {\n    return isoEpochLeapYear\n  }\n}\n\nexport const isoCalendarID = 'iso8601'\nexport const isoCalendarImpl = new ISOCalendarImpl(isoCalendarID)\n", "import { isoCalendarImpl } from '../calendarImpl/isoCalendarImpl'\nimport { LargeInt, createLargeInt } from '../utils/largeInt'\nimport { numSign, positiveModulo } from '../utils/math'\nimport { isoTimeToNano } from './dayAndTime'\nimport {\n  ISODateFields,\n  ISODateTimeFields,\n  ISODateTimeFieldsMilli,\n  ISOTimeFields,\n} from './isoFields'\nimport {\n  milliInDay,\n  milliInSecond, nanoInMicro,\n  nanoInMilli,\n} from './units'\n\nexport const isoEpochOriginYear = 1970\nexport const isoEpochLeapYear = 1972 // first ISO leap year after origin\n\nexport type EpochableFields = ISODateFields & Partial<ISOTimeFields>\n\nexport const epochNanoSymbol = Symbol()\n\nexport interface EpochableObj {\n  [epochNanoSymbol]?: LargeInt\n  getISOFields(): EpochableFields\n}\n\n/*\nGENERAL ROUNDING TIPS:\n- use trunc on timeZoneOffsets and durations (directionally outward from 0 origin)\n  - for this, trunc and % go well together\n- use floor on epoch-times, time-of-days, week numbers (directionally forward only)\n  - for this, floor and positiveModulo go well together\n*/\n// ISO Field <-> Epoch Math\n\nexport function isoFieldsToEpochNano(isoFields: EpochableFields): LargeInt {\n  return isoToEpochNano(\n    isoFields.isoYear,\n    isoFields.isoMonth,\n    isoFields.isoDay,\n    isoFields.isoHour,\n    isoFields.isoMinute,\n    isoFields.isoSecond,\n    isoFields.isoMillisecond,\n    isoFields.isoMicrosecond,\n    isoFields.isoNanosecond,\n  )\n}\n\nexport function isoFieldsToEpochMilli(isoFields: EpochableFields): number {\n  return isoToEpochMilli(\n    isoFields.isoYear,\n    isoFields.isoMonth,\n    isoFields.isoDay,\n    isoFields.isoHour,\n    isoFields.isoMinute,\n    isoFields.isoSecond,\n    isoFields.isoMillisecond,\n  )\n}\n\nexport function isoToEpochNano(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  isoHour?: number,\n  isoMinute?: number,\n  isoSecond?: number,\n  isoMillisecond?: number,\n  isoMicrosecond?: number,\n  isoNanosecond?: number,\n): LargeInt {\n  return createLargeInt(\n    isoToEpochMilli(\n      isoYear,\n      isoMonth,\n      isoDay,\n      isoHour,\n      isoMinute,\n      isoSecond,\n      isoMillisecond,\n    ),\n  ).mult(nanoInMilli).add(\n    (isoMicrosecond ?? 0) * nanoInMicro +\n      (isoNanosecond ?? 0),\n  )\n}\n\nexport function isoToEpochMilli(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  isoHour?: number,\n  isoMinute?: number,\n  isoSecond?: number,\n  isoMillisecond?: number,\n): number {\n  const sign = numSign(isoYear)\n  let dayShiftAbs = 0\n  let isoDayTry: number\n  let milli: number | undefined\n\n  // https://stackoverflow.com/a/5870822/96342\n  const twoDigitYearBug = isoYear >= 0 && isoYear < 1000\n  const isoYearTemp = twoDigitYearBug ? isoYear + 1200 : isoYear\n\n  // Temporal must represent year-month-days and year-months that don't have their start-of-unit\n  // in bounds. Keep moving the date towards the origin one day at a time until in-bounds.\n  // We won't need to shift more than a month.\n  for (; dayShiftAbs < 31; dayShiftAbs++) {\n    isoDayTry = isoDay - (sign * dayShiftAbs)\n\n    const milliTry = Date.UTC(\n      isoYearTemp,\n      isoMonth - 1,\n      isoDayTry,\n      isoHour ?? 0,\n      isoMinute ?? 0,\n      isoSecond ?? 0,\n      isoMillisecond ?? 0,\n    )\n    // is valid? (TODO: rename isInvalid -> isValid)\n    if (!isInvalid(milliTry)) {\n      milli = milliTry + (sign * dayShiftAbs * milliInDay)\n      break\n    }\n  }\n\n  if (\n    milli === undefined ||\n    // ensure day didn't underflow/overflow to get to an in-bounds date\n    isoDayTry! < 1 ||\n    isoDayTry! > isoCalendarImpl.daysInMonth(isoYear, isoMonth)\n  ) {\n    throwOutOfRange()\n  }\n\n  if (twoDigitYearBug) {\n    milli = new Date(milli!).setUTCFullYear(isoYear)\n  }\n\n  return milli!\n}\n\nexport function epochNanoToISOFields(epochNano: LargeInt): ISODateTimeFields {\n  let epochMilli = epochNano.div(nanoInMilli)\n  let leftoverNano = epochNano.sub(epochMilli.mult(nanoInMilli)).toNumber()\n\n  // ensure leftoverNano. bump to millisecond below if necessary\n  if (leftoverNano < 0) {\n    leftoverNano += nanoInMilli\n    epochMilli = epochMilli.sub(1)\n  }\n\n  const isoMicrosecond = Math.floor(leftoverNano / nanoInMicro)\n  leftoverNano -= isoMicrosecond * nanoInMicro\n\n  return {\n    ...epochMilliToISOFields(epochMilli.toNumber()),\n    isoMicrosecond,\n    isoNanosecond: leftoverNano,\n  }\n}\n\nexport function epochMilliToISOFields(epochMilli: number): ISODateTimeFieldsMilli {\n  const [legacy, dayUnshift] = nudgeToLegacyDate(epochMilli)\n  return {\n    isoYear: legacy.getUTCFullYear(),\n    isoMonth: legacy.getUTCMonth() + 1,\n    isoDay: legacy.getUTCDate() + dayUnshift,\n    isoHour: legacy.getUTCHours(),\n    isoMinute: legacy.getUTCMinutes(),\n    isoSecond: legacy.getUTCSeconds(),\n    isoMillisecond: legacy.getUTCMilliseconds(),\n  }\n}\n\n// High-level conversions\n\nexport function toEpochNano(dt: EpochableObj): LargeInt {\n  return dt[epochNanoSymbol] ?? isoFieldsToEpochNano(dt.getISOFields())\n}\n\n// Misc conversions\n\nexport function isoYearToEpochSeconds(isoYear: number): number {\n  return Math.floor(isoToEpochMilli(isoYear, 1, 1) / milliInSecond)\n}\n\nexport function epochNanoToISOYear(epochNano: LargeInt): number {\n  return nudgeToLegacyDate(\n    epochNano.div(nanoInMilli).toNumber(),\n  )[0].getUTCFullYear()\n}\n\n// Day-of-Week (move?)\n\nexport function computeISODayOfWeek(isoYear: number, isoMonth: number, isoDay: number): number {\n  const [legacy, dayUnshift] = nudgeToLegacyDate(isoToEpochMilli(isoYear, isoMonth, isoDay))\n  return positiveModulo(\n    legacy.getUTCDay() + dayUnshift,\n    7,\n  ) || 7 // convert Sun...Mon to Mon...Sun\n}\n\n// Utils\n\nfunction nudgeToLegacyDate(epochMilli: number): [Date, number] {\n  const sign = numSign(epochMilli)\n  let dayShiftAbs = 0\n  let date: Date | undefined\n\n  // undo the dayShift done in isoToEpochMilli\n  // won't need to move more than a month (max month days is 31, so 30)\n  for (; dayShiftAbs < 31; dayShiftAbs++) {\n    const dateTry = new Date(epochMilli - (sign * dayShiftAbs * milliInDay))\n\n    if (!isInvalid(dateTry)) {\n      date = dateTry\n      break\n    }\n  }\n\n  if (date === undefined) {\n    throwOutOfRange()\n  }\n\n  return [date!, sign * dayShiftAbs]\n}\n\nfunction isInvalid(n: { valueOf(): number; }): boolean {\n  return isNaN(n.valueOf())\n}\n\nexport function throwOutOfRange(): void {\n  throw new RangeError('Date outside of supported range')\n}\n\n// Epoch-Millisecond Math\n// (move to diff file?)\n\nexport function diffDaysMilli(epochMilli0: number, epochMilli1: number): number {\n  return Math.round((epochMilli1 - epochMilli0) / milliInDay)\n}\n\nexport function addDaysMilli(epochMilli: number, days: number): number {\n  return epochMilli + days * milliInDay\n}\n\nexport function splitEpochNano(epochNano: LargeInt): [LargeInt, number] {\n  const isoFields = epochNanoToISOFields(epochNano)\n  const dayEpochNano = isoToEpochNano(isoFields.isoYear, isoFields.isoMonth, isoFields.isoDay)\n  const timeNano = isoTimeToNano(isoFields)\n  return [dayEpochNano, timeNano]\n}\n", "import { Temporal } from 'temporal-spec'\nimport { LargeInt, compareLargeInts } from '../utils/largeInt'\nimport { compareValues } from '../utils/math'\nimport { durationDayTimeToNano, isoTimeToNano } from './dayAndTime'\nimport { DiffableObj } from './diff'\nimport { DurationFields, computeLargestDurationUnit } from './durationFields'\nimport { EpochableFields, epochNanoSymbol, isoFieldsToEpochNano } from './epoch'\nimport { ISOTimeFields } from './isoFields'\nimport { LocalDateFields } from './localFields'\nimport { DAY } from './units'\n\nexport interface ComparableDateTime {\n  getISOFields(): EpochableFields\n}\n\nexport interface ComparableTime {\n  getISOFields(): ISOTimeFields\n}\n\nexport interface ComparableEpochObj {\n  [epochNanoSymbol]: LargeInt\n}\n\n// Equality (considers Calendar & timeZone)\n// -------------------------------------------------------------------------------------------------\n\ntype EqualityTestObj = ComparableDateTime & { calendar: Temporal.CalendarProtocol }\ntype ZonedEqualityTestObj = EqualityTestObj & { timeZone: Temporal.TimeZoneProtocol }\n\nexport function zonedDateTimesEqual(a: ZonedEqualityTestObj, b: ZonedEqualityTestObj): boolean {\n  return dateTimesEqual(a, b) &&\n    a.timeZone.toString() === b.timeZone.toString()\n}\n\nexport function dateTimesEqual(a: EqualityTestObj, b: EqualityTestObj): boolean {\n  return !compareDateTimes(a, b) &&\n    a.calendar.toString() === b.calendar.toString()\n}\n\n// Comparison\n// -------------------------------------------------------------------------------------------------\n\nexport function compareDateTimes(\n  a: ComparableDateTime,\n  b: ComparableDateTime,\n): Temporal.ComparisonResult {\n  return compareLargeInts(\n    isoFieldsToEpochNano(a.getISOFields()),\n    isoFieldsToEpochNano(b.getISOFields()),\n  )\n}\n\nexport function compareTimes(t0: ComparableTime, t1: ComparableTime): Temporal.ComparisonResult {\n  return compareValues(\n    isoTimeToNano(t0.getISOFields()),\n    isoTimeToNano(t1.getISOFields()),\n  )\n}\n\nexport function compareLocalDateFields(\n  d0: LocalDateFields,\n  d1: LocalDateFields,\n): Temporal.ComparisonResult {\n  return compareValues(d0.year, d1.year) ||\n    compareValues(d0.month, d1.month) ||\n    compareValues(d0.day, d1.day)\n}\n\nexport function compareEpochObjs(\n  a: ComparableEpochObj,\n  b: ComparableEpochObj,\n): Temporal.ComparisonResult {\n  return compareLargeInts(\n    a[epochNanoSymbol],\n    b[epochNanoSymbol],\n  )\n}\n\nexport function compareDurations(\n  fields0: DurationFields,\n  fields1: DurationFields,\n  relativeTo: DiffableObj | undefined,\n): Temporal.ComparisonResult {\n  if (\n    relativeTo === undefined &&\n    computeLargestDurationUnit(fields0) <= DAY &&\n    computeLargestDurationUnit(fields1) <= DAY\n  ) {\n    return compareLargeInts(\n      durationDayTimeToNano(fields0),\n      durationDayTimeToNano(fields1),\n    )\n  }\n\n  if (!relativeTo) {\n    throw new RangeError('Need relativeTo')\n  }\n\n  const date0 = relativeTo.add(fields0)\n  const date1 = relativeTo.add(fields1)\n\n  if (relativeTo[epochNanoSymbol] !== undefined) {\n    return compareEpochObjs(date0 as ComparableEpochObj, date1 as ComparableEpochObj)\n  }\n\n  return compareDateTimes(date0 as ComparableDateTime, date1 as ComparableDateTime)\n}\n", "import { OVERFLOW_REJECT, OverflowHandlingInt } from '../argParse/overflowHandling'\nimport { constrainInt } from '../argParse/refine'\nimport { CalendarImpl } from '../calendarImpl/calendarImpl'\nimport { isoCalendarImpl } from '../calendarImpl/isoCalendarImpl'\nimport { ISODateFields, ISODateTimeFields, ISOTimeFields } from './isoFields'\n\nexport function constrainDateFields(\n  year: number,\n  month: number,\n  day: number,\n  calendarImpl: CalendarImpl,\n  overflow: OverflowHandlingInt,\n): [number, number, number] {\n  year = Number(year) // not using constrainValue, which converts to a number\n  month = constrainInt(month, 1, calendarImpl.monthsInYear(year), overflow)\n  day = constrainInt(day, 1, calendarImpl.daysInMonth(year, month), overflow)\n\n  return [year, month, day]\n}\n\nexport function constrainDateISO( // also ensures numbers\n  isoFields: ISODateFields,\n  overflow: OverflowHandlingInt,\n): ISODateFields {\n  const [isoYear, isoMonth, isoDay] = constrainDateFields(\n    isoFields.isoYear,\n    isoFields.isoMonth,\n    isoFields.isoDay,\n    isoCalendarImpl,\n    overflow,\n  )\n  return { isoYear, isoMonth, isoDay }\n}\n\nexport function isValidDateISO(isoFields: ISODateFields): boolean {\n  // HACK\n  try {\n    constrainDateISO(isoFields, OVERFLOW_REJECT)\n    return true\n  } catch (ex) {\n    return false\n  }\n}\n\nexport function constrainDateTimeISO( // also ensures numbers\n  isoFields: ISODateTimeFields,\n  overflow: OverflowHandlingInt,\n): ISODateTimeFields {\n  return {\n    ...constrainDateISO(isoFields, overflow),\n    ...constrainTimeISO(isoFields, overflow),\n  }\n}\n\nexport function constrainTimeISO( // also converts to number\n  {\n    isoHour, isoMinute, isoSecond,\n    isoMillisecond, isoMicrosecond, isoNanosecond,\n  }: ISOTimeFields,\n  overflow: OverflowHandlingInt,\n): ISOTimeFields {\n  isoHour = constrainInt(isoHour, 0, 23, overflow)\n  isoMinute = constrainInt(isoMinute, 0, 59, overflow)\n  isoSecond = constrainInt(isoSecond, 0, 59, overflow)\n  isoMillisecond = constrainInt(isoMillisecond, 0, 999, overflow)\n  isoMicrosecond = constrainInt(isoMicrosecond, 0, 999, overflow)\n  isoNanosecond = constrainInt(isoNanosecond, 0, 999, overflow)\n  return { isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond }\n}\n", "import { strArrayToHash } from '../utils/obj'\nimport { durationUnitNames } from './unitStr'\n\nexport const yearMonthFieldMap = {\n  era: String,\n  eraYear: Number,\n  year: Number,\n  month: Number,\n  monthCode: String,\n}\n\nexport const dateFieldMap = {\n  ...yearMonthFieldMap,\n  day: Number,\n}\n\nexport const timeFieldMap = {\n  hour: Number,\n  minute: Number,\n  second: Number,\n  millisecond: Number,\n  microsecond: Number,\n  nanosecond: Number,\n}\n\nexport const monthDayFieldMap = {\n  era: String,\n  eraYear: Number,\n  year: Number,\n  month: Number,\n  monthCode: String,\n  day: Number,\n}\n\nexport const durationFieldMap = strArrayToHash(durationUnitNames, () => Number)\n", "import { CalendarImplFields } from './calendarImpl'\nimport { ISOCalendarImpl } from './isoCalendarImpl'\n\n// for converting year -> [era,eraYear]\n// (can't use eraOrigins, it's for the other direction)\nexport class GregoryCalendarImpl extends ISOCalendarImpl {\n  computeFields(epochMilli: number): CalendarImplFields {\n    const fields = super.computeFields(epochMilli)\n    const { year } = fields\n    return {\n      ...fields,\n      era: year < 1 ? 'bce' : 'ce',\n      eraYear: year < 1 ? -(year - 1) : year,\n    }\n  }\n}\n", "import { createOptionParser } from './refine'\n\nexport const CALENDAR_DISPLAY_AUTO = 0\nexport const CALENDAR_DISPLAY_NEVER = 1\nexport const CALENDAR_DISPLAY_ALWAYS = 2\nexport type CalendarDisplayInt = 0 | 1 | 2\n\nexport interface CalendarDisplayMap {\n  auto: 0\n  never: 1\n  always: 2\n}\nexport const calendarDisplayMap: CalendarDisplayMap = {\n  auto: 0,\n  never: 1,\n  always: 2,\n}\n\nexport const parseCalendarDisplayOption = createOptionParser(\n  'calendarName',\n  calendarDisplayMap,\n  CALENDAR_DISPLAY_AUTO,\n)\n", "import { createOptionParser } from './refine'\n\nexport const DISAMBIG_COMPATIBLE = 0\nexport const DISAMBIG_EARLIER = 1\nexport const DISAMBIG_LATER = 2\nexport const DISAMBIG_REJECT = 3\nexport type DisambigInt = 0 | 1 | 2 | 3\n\nexport interface DisambigMap {\n  compatible: 0\n  earlier: 1\n  later: 2\n  reject: 3\n}\nexport const disambigMap: DisambigMap = {\n  compatible: 0,\n  earlier: 1,\n  later: 2,\n  reject: 3,\n}\n\nexport const parseDisambigOption = createOptionParser(\n  'disambiguation',\n  disambigMap,\n  DISAMBIG_COMPATIBLE,\n)\n", "import { Temporal } from 'temporal-spec'\nimport {\n  MICROSECOND,\n  MILLISECOND,\n  MINUTE,\n  NANOSECOND,\n  SECOND,\n  nanoIn,\n  unitDigitMap,\n} from '../dateUtils/units'\nimport { OVERFLOW_REJECT } from './overflowHandling'\nimport { constrainInt, ensureOptionsObj } from './refine'\nimport { parseRoundingModeOption } from './roundingMode'\nimport { RoundingConfig } from './roundingOptions'\nimport { parseUnit } from './unitStr'\n\nexport type DurationToStringUnitInt = // TODO: move this??? weird name/location for this\n  typeof SECOND |\n  typeof MILLISECOND |\n  typeof MICROSECOND |\n  typeof NANOSECOND\n\nexport type TimeToStringUnitInt = typeof MINUTE | DurationToStringUnitInt\n\nexport interface TimeToStringConfig<\n  UnitType extends TimeToStringUnitInt = TimeToStringUnitInt\n> extends RoundingConfig<UnitType> {\n  fractionalSecondDigits: number | undefined\n}\n\nexport type DurationToStringConfig = TimeToStringConfig<DurationToStringUnitInt>\n\nexport function parseTimeToStringOptions<UnitType extends TimeToStringUnitInt>(\n  options: Temporal.ToStringPrecisionOptions | undefined,\n  largestUnit: UnitType = MINUTE as UnitType,\n): TimeToStringConfig<UnitType> {\n  const ensuredOptions = ensureOptionsObj(options)\n  const smallestUnitArg = ensuredOptions.smallestUnit\n  const digitsArg = ensuredOptions.fractionalSecondDigits\n  let smallestUnit = NANOSECOND as UnitType\n  let incNano = 1\n  let digits: number | undefined\n\n  if (smallestUnitArg !== undefined) {\n    smallestUnit = parseUnit<UnitType>(\n      smallestUnitArg,\n      undefined, // no default. a required field\n      NANOSECOND as UnitType, // minUnit\n      largestUnit, // maxUnit\n    )\n    incNano = nanoIn[smallestUnit]\n    digits = unitDigitMap[smallestUnit] || 0\n  } else if (digitsArg !== undefined && digitsArg !== 'auto') {\n    digits = constrainInt(digitsArg, 0, 9, OVERFLOW_REJECT)\n    incNano = Math.pow(10, 9 - digits)\n  }\n\n  return {\n    smallestUnit,\n    fractionalSecondDigits: digits,\n    roundingFunc: parseRoundingModeOption(options, Math.trunc),\n    incNano,\n  }\n}\n", "import { createOptionParser } from './refine'\n\nexport const TIME_ZONE_DISPLAY_AUTO = 0\nexport const TIME_ZONE_DISPLAY_NEVER = 1\nexport type TimeZoneDisplayInt = 0 | 1\n\nexport interface TimeZoneDisplayMap {\n  auto: 0\n  never: 1\n}\nexport const timeZoneDisplayMap: TimeZoneDisplayMap = {\n  auto: 0,\n  never: 1,\n}\n\nexport const parseTimeZoneDisplayOption = createOptionParser(\n  'timeZoneName',\n  timeZoneDisplayMap,\n  TIME_ZONE_DISPLAY_AUTO,\n)\n", "import {\n  CALENDAR_DISPLAY_ALWAYS,\n  CALENDAR_DISPLAY_NEVER,\n  CalendarDisplayInt,\n} from '../argParse/calendarDisplay'\nimport { DurationToStringConfig, TimeToStringConfig } from '../argParse/isoFormatOptions'\nimport { TIME_ZONE_DISPLAY_NEVER, TimeZoneDisplayInt } from '../argParse/timeZoneDisplay'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { createLargeInt } from '../utils/largeInt'\nimport { RoundingFunc, roundToIncrementBI } from '../utils/math'\nimport { getSignStr, padZeros } from '../utils/string'\nimport { nanoToISOTime } from './dayAndTime'\nimport { DurationFields } from './durationFields'\nimport { ISODateFields, ISODateTimeFields, ISOTimeFields } from './isoFields'\nimport {\n  MINUTE,\n  SECOND,\n  TimeUnitInt,\n  nanoIn,\n  nanoInMicro,\n  nanoInMilli,\n  nanoInSecond,\n} from './units'\n\n// given ISO fields should already be rounded\nexport function formatDateTimeISO(\n  fields: ISODateTimeFields,\n  formatConfig: TimeToStringConfig,\n): string {\n  return formatDateISO(fields) + 'T' + formatTimeISO(fields, formatConfig)\n}\n\nexport function formatDateISO(fields: ISODateFields): string {\n  return formatYearMonthISO(fields) + '-' + padZeros(fields.isoDay, 2)\n}\n\nexport function formatYearMonthISO(fields: ISODateFields): string {\n  const { isoYear } = fields\n  return (\n    (isoYear < 1000 || isoYear > 9999)\n      ? getSignStr(isoYear) + padZeros(Math.abs(isoYear), 6)\n      : padZeros(isoYear, 4)\n  ) + '-' + padZeros(fields.isoMonth, 2)\n}\n\nexport function formatMonthDayISO(fields: ISODateFields): string {\n  return padZeros(fields.isoMonth, 2) + '-' + padZeros(fields.isoDay, 2)\n}\n\n// given ISO fields should already be rounded\n// formatConfig is NOT for rounding. only for smallestUnit/fractionalSecondDigits\nexport function formatTimeISO(\n  fields: ISOTimeFields,\n  formatConfig: TimeToStringConfig, // tighten type? remove roundingMode?\n): string {\n  const parts: string[] = [padZeros(fields.isoHour, 2)]\n\n  if (formatConfig.smallestUnit <= MINUTE) {\n    parts.push(padZeros(fields.isoMinute, 2))\n\n    if (formatConfig.smallestUnit <= SECOND) {\n      parts.push(\n        padZeros(fields.isoSecond, 2) +\n          formatPartialSeconds(\n            fields.isoMillisecond,\n            fields.isoMicrosecond,\n            fields.isoNanosecond,\n            formatConfig.fractionalSecondDigits,\n          )[0],\n      )\n    }\n  }\n\n  return parts.join(':')\n}\n\n// TODO: combine with formatTimeISO\nexport function formatOffsetISO(offsetNano: number): string {\n  const [fields, dayDelta] = nanoToISOTime(Math.abs(offsetNano))\n  const partialSecondsStr = formatPartialSeconds(\n    fields.isoMillisecond,\n    fields.isoMicrosecond,\n    fields.isoNanosecond,\n    undefined,\n  )[0]\n\n  return getSignStr(offsetNano) +\n    // format beyond 24:00 (TODO: somehow convince nanoToISOTime to have topheavy hours?)\n    padZeros(fields.isoHour + dayDelta * 24, 2) + ':' +\n    padZeros(fields.isoMinute, 2) +\n    ((fields.isoSecond || partialSecondsStr)\n      ? ':' + padZeros(fields.isoSecond, 2) + partialSecondsStr\n      : '')\n}\n\n// you MUST pass in Calendar::toString()\n// this is WEIRD. proper solution: have a proper CalendarProtocol object\nexport function formatCalendarID(\n  calendarID: string | undefined,\n  display: CalendarDisplayInt,\n): string {\n  if (\n    calendarID && ( // might be blank if custom calendar implementation\n      display === CALENDAR_DISPLAY_ALWAYS ||\n      (display !== CALENDAR_DISPLAY_NEVER && calendarID !== isoCalendarID)\n    )\n  ) {\n    return `[u-ca=${calendarID}]`\n  }\n  return ''\n}\n\nexport function formatTimeZoneID(timeZoneID: string, display: TimeZoneDisplayInt): string {\n  if (display !== TIME_ZONE_DISPLAY_NEVER) {\n    return `[${timeZoneID}]`\n  }\n  return ''\n}\n\nexport function formatDurationISO(\n  fields: DurationFields,\n  formatConfig: DurationToStringConfig,\n): string {\n  const { smallestUnit, fractionalSecondDigits, roundingFunc } = formatConfig\n  const { sign } = fields\n  const hours = fields.hours\n  const minutes = fields.minutes\n  let seconds = fields.seconds\n  let partialSecondsStr = ''\n\n  if (smallestUnit <= SECOND) { // should be just less-than!!?\n    const res = formatPartialSeconds(\n      fields.milliseconds,\n      fields.microseconds,\n      fields.nanoseconds,\n      fractionalSecondDigits,\n      roundingFunc,\n      smallestUnit,\n    )\n    partialSecondsStr = res[0]\n    seconds += res[1]\n  }\n\n  // guarantee display of seconds if...\n  const forceSeconds =\n    fractionalSecondDigits !== undefined || // fractionalSecondDigits explicitly specified\n    partialSecondsStr || // partial seconds, either via fractionalSecondDigits or default\n    !sign // duration is completely empty, display 'PT0S'\n\n  return (sign < 0 ? '-' : '') + 'P' +\n    collapseDurationTuples([\n      [fields.years, 'Y'],\n      [fields.months, 'M'],\n      [fields.weeks, 'W'],\n      [fields.days, 'D'],\n    ]) +\n    (hours || minutes || seconds || forceSeconds\n      ? 'T' +\n      collapseDurationTuples([\n        [hours, 'H'],\n        [minutes, 'M'],\n        [\n          smallestUnit <= SECOND ? seconds : 0,\n          partialSecondsStr + 'S',\n          forceSeconds,\n        ],\n      ])\n      : '')\n}\n\n// use BigInts, because less likely to overflow and formatting never does scientific notation\nfunction collapseDurationTuples(tuples: [number, string, unknown?][]): string {\n  return tuples.map(([num, postfix, forceShow]) => {\n    if (forceShow || num) {\n      // avoid outputting scientific notation\n      // https://stackoverflow.com/a/50978675/96342\n      const numStr = Math.abs(num).toLocaleString('fullwide', { useGrouping: false })\n      return numStr + postfix\n    }\n    return ''\n  }).join('')\n}\n\nfunction formatPartialSeconds(\n  milliseconds: number,\n  microseconds: number,\n  nanoseconds: number,\n  fractionalSecondDigits: number | undefined,\n  roundingFunc?: RoundingFunc, // HACK for forcing this func to do rounding\n  smallestUnit?: TimeUnitInt, // HACK for forcing this func to do rounding\n): [string, number] { // [afterDecimalStr, secondsOverflow]\n  let totalNano = createLargeInt(milliseconds).mult(nanoInMilli)\n    .add(createLargeInt(microseconds).mult(nanoInMicro))\n    .add(nanoseconds)\n\n  // HACK. sometimes input is pre-rounded, other times not\n  // not DRY. search for Math.pow\n  if (roundingFunc) {\n    totalNano = roundToIncrementBI(\n      totalNano,\n      fractionalSecondDigits === undefined\n        ? nanoIn[smallestUnit!] // not needed anymore I don't think\n        : Math.pow(10, 9 - fractionalSecondDigits),\n      roundingFunc,\n    )\n  }\n\n  const totalNanoAbs = totalNano.abs()\n  const seconds = totalNanoAbs.div(nanoInSecond)\n  const leftoverNano = totalNanoAbs.sub(seconds.mult(nanoInSecond))\n\n  let afterDecimal = padZeros(leftoverNano.toNumber(), 9)\n  afterDecimal = fractionalSecondDigits === undefined\n    ? afterDecimal.replace(/0+$/, '') // strip trailing zeros\n    : afterDecimal.substr(0, fractionalSecondDigits)\n\n  return [\n    afterDecimal ? '.' + afterDecimal : '',\n    seconds.toNumber() * (totalNano.sign() || 1), // restore sign\n  ]\n}\n", "import { Temporal } from 'temporal-spec'\nimport { unitNames } from '../argParse/unitStr'\nimport { LargeInt } from '../utils/largeInt'\nimport { attachGetters, strArrayToHash } from '../utils/obj'\nimport { capitalizeFirstLetter } from '../utils/string'\nimport { DateISOInstance } from './calendar'\nimport { epochNanoSymbol } from './epoch'\nimport { nanoInMicro, nanoInMilli, nanoInSecond } from './units'\n\n// Epoch Fields\n\nexport interface ComputedEpochFields {\n  epochNanoseconds: bigint\n  epochMicroseconds: bigint\n  epochMilliseconds: number\n  epochSeconds: number\n}\n\nexport function mixinEpochFields<Obj extends { [epochNanoSymbol]: LargeInt }>(\n  ObjClass: { prototype: Obj },\n): void {\n  attachGetters(ObjClass, {\n    epochNanoseconds(): bigint {\n      return this[epochNanoSymbol].toBigInt()\n    },\n    epochMicroseconds(): bigint {\n      return this[epochNanoSymbol].div(nanoInMicro).toBigInt()\n    },\n    epochMilliseconds(): number {\n      return this[epochNanoSymbol].div(nanoInMilli).toNumber()\n    },\n    epochSeconds(): number {\n      return this[epochNanoSymbol].div(nanoInSecond).toNumber()\n    },\n  })\n}\n\n// ISO Fields\n\nconst isoFieldMap: { [Key: string]: string } = {\n  calendar: 'calendar',\n}\nfor (const unitName of unitNames) {\n  isoFieldMap[unitName] = 'iso' + capitalizeFirstLetter(unitName)\n}\n\n// always mixes in `calendar`\nexport function mixinISOFields<Obj extends { getISOFields(): any }>(\n  ObjClass: { prototype: Obj },\n  unitNames: Temporal.DateTimeUnit[] = [],\n): void {\n  attachGetters(\n    ObjClass,\n    strArrayToHash(\n      (unitNames as string[]).concat('calendar'),\n      (propName) => function(this: Obj) {\n        return this.getISOFields()[isoFieldMap[propName]]\n      },\n    ),\n  )\n}\n\n// Calendar Fields\n\nexport interface YearMonthCalendarFields {\n  era: string | undefined\n  eraYear: number | undefined\n  year: number\n  month: number\n  monthCode: string\n  daysInMonth: number\n  daysInYear: number\n  monthsInYear: number\n  inLeapYear: boolean\n}\n\nexport interface MonthDayCalendarFields {\n  monthCode: string\n  day: number\n}\n\nexport interface DateCalendarFields extends YearMonthCalendarFields {\n  day: number\n  daysInWeek: number\n  dayOfWeek: number\n  dayOfYear: number\n  weekOfYear: number\n}\n\nexport const yearMonthCalendarFields: (keyof YearMonthCalendarFields)[] = [\n  'era',\n  'eraYear',\n  'year',\n  'month',\n  'monthCode',\n  'daysInMonth',\n  'daysInYear',\n  'monthsInYear',\n  'inLeapYear',\n]\n\nexport const monthDayCalendarFields: (keyof MonthDayCalendarFields)[] = [\n  'monthCode',\n  'day',\n]\n\nexport const dateCalendarFields: (keyof DateCalendarFields)[] = [\n  ...yearMonthCalendarFields,\n  'day',\n  'dayOfWeek',\n  'dayOfYear',\n  'weekOfYear',\n  'daysInWeek',\n]\n\nexport function mixinCalendarFields<Obj extends DateISOInstance>(\n  ObjClass: { prototype: Obj },\n  propNames: (keyof DateCalendarFields)[],\n): void {\n  attachGetters(\n    ObjClass,\n    strArrayToHash(propNames, (propName) => function(this: Obj) {\n      const value = this.calendar[propName as keyof DateCalendarFields](\n        this as Temporal.PlainDateLike,\n      )\n      Object.defineProperty(this, propName, { value }) // cache the value on the object\n      return value\n    }),\n  )\n}\n\n// affects how objects are displayed in console\n\n// TODO: make readonly somehow?\nexport function attachStringTag(objOrClass: any, name: string): void {\n  (objOrClass.prototype || objOrClass)[Symbol.toStringTag] = 'Temporal.' + name\n}\n", "import { createOptionParser } from './refine'\n\nexport const OFFSET_PREFER = 0\nexport const OFFSET_USE = 1\nexport const OFFSET_IGNORE = 2\nexport const OFFSET_REJECT = 3\nexport type OffsetHandlingInt = 0 | 1 | 2 | 3\n\nexport interface OffsetHandlingMap {\n  prefer: 0\n  use: 1\n  ignore: 2\n  reject: 3\n}\nexport const offsetHandlingMap: OffsetHandlingMap = {\n  prefer: 0,\n  use: 1,\n  ignore: 2,\n  reject: 3,\n}\n\nexport const parseOffsetHandlingOption = createOptionParser(\n  'offset',\n  offsetHandlingMap,\n)\n", "import { Temporal } from 'temporal-spec'\nimport {\n  DISAMBIG_COMPATIBLE,\n  DISAMBIG_EARLIER,\n  DISAMBIG_LATER,\n  DISAMBIG_REJECT,\n  DisambigInt,\n} from '../argParse/disambig'\nimport { Instant } from '../public/instant'\nimport { PlainDateTime } from '../public/plainDateTime'\nimport { toEpochNano } from './epoch'\nimport { nanoInDay } from './units'\n\n// Utils for working with TimeZoneProtocol\n\nexport function getInstantFor(\n  timeZoneProtocol: Temporal.TimeZoneProtocol,\n  dateTime: PlainDateTime,\n  disambigInt: DisambigInt = DISAMBIG_COMPATIBLE,\n): Temporal.Instant {\n  const possibleInstants = timeZoneProtocol.getPossibleInstantsFor(dateTime)\n\n  if (possibleInstants.length === 1) {\n    return possibleInstants[0]\n  } else {\n    if (disambigInt === DISAMBIG_REJECT) {\n      throw new RangeError('Ambiguous offset')\n    }\n\n    // within a transition that jumps back\n    // (compat means earlier)\n    if (possibleInstants.length) {\n      return possibleInstants[\n        disambigInt === DISAMBIG_LATER\n          ? 1\n          : 0 // DISAMBIG_EARLIER and DISAMBIG_COMPATIBLE\n      ]\n\n    // within a transition that jumps forward\n    // (compat means later)\n    } else {\n      const gapNano = computeGapNear(timeZoneProtocol, dateTime)\n      const moreInstants = timeZoneProtocol.getPossibleInstantsFor(\n        dateTime.add({\n          nanoseconds:\n            gapNano *\n            (disambigInt === DISAMBIG_EARLIER\n              ? -1\n              : 1), // DISAMBIG_LATER and DISAMBIG_COMPATIBLE\n        }),\n      )\n\n      return moreInstants[// either 1 or 2 choices\n        disambigInt === DISAMBIG_EARLIER\n          ? 0\n          : moreInstants.length - 1 // DISAMBIG_LATER and DISAMBIG_COMPATIBLE\n      ]\n    }\n  }\n}\n\nfunction computeGapNear(\n  timeZoneProtocol: Temporal.TimeZoneProtocol,\n  plainDateTime: PlainDateTime,\n): number {\n  const utcEpochNano = toEpochNano(plainDateTime)\n  const offsetDayBefore = timeZoneProtocol.getOffsetNanosecondsFor(\n    new Instant(utcEpochNano.sub(nanoInDay)),\n  )\n  const offsetDayAfter = timeZoneProtocol.getOffsetNanosecondsFor(\n    new Instant(utcEpochNano.add(nanoInDay)),\n  )\n  return offsetDayAfter - offsetDayBefore\n}\n", "import { Temporal } from 'temporal-spec'\nimport { OverflowHandlingInt } from '../argParse/overflowHandling'\nimport { constrainInt } from '../argParse/refine'\nimport { CalendarImpl } from '../calendarImpl/calendarImpl'\nimport { Instant } from '../public/instant'\nimport { createDate } from '../public/plainDate'\nimport { createDateTime } from '../public/plainDateTime'\nimport { LargeInt } from '../utils/largeInt'\nimport {\n  durationDayTimeToNano,\n  durationTimeToNano,\n  isoTimeToNano,\n  nanoToDuration,\n  nanoToISOTime,\n  zeroDurationTimeFields,\n} from './dayAndTime'\nimport { DiffableObj, diffAccurate } from './diff'\nimport { DurationFields, computeLargestDurationUnit, overrideDuration } from './durationFields'\nimport {\n  addDaysMilli,\n  epochMilliToISOFields,\n  epochNanoSymbol,\n  epochNanoToISOFields,\n  isoFieldsToEpochNano,\n  isoToEpochMilli,\n} from './epoch'\nimport {\n  ISODateFields,\n  ISODateTimeFields,\n  ISOTimeFields,\n} from './isoFields'\nimport { LocalDateFields } from './localFields'\nimport { getInstantFor } from './timeZone'\nimport { DAY, DayTimeUnitInt, nanoInDay } from './units'\n\ntype TranslatableObj = ISODateTimeFields & { calendar: Temporal.CalendarProtocol }\ntype ZonedTranslatableObj = TranslatableObj & { timeZone: Temporal.TimeZoneProtocol }\n\nexport function translateZonedDateTimeFields(\n  fields: ZonedTranslatableObj,\n  duration: DurationFields,\n  options: Temporal.AssignmentOptions | undefined, // Calendar needs these options to be raw\n): LargeInt {\n  const { calendar, timeZone } = fields\n\n  // add date fields first\n  const translatedDate = calendar.dateAdd(\n    createDate(fields),\n    // don't let calendar round time fields to day\n    overrideDuration(duration, zeroDurationTimeFields),\n    options,\n  )\n\n  // add time-of-day back in\n  const translatedDateTime = createDateTime({\n    ...fields,\n    ...translatedDate.getISOFields(),\n  })\n\n  // add time fields of duration\n  const translatedInstant = getInstantFor(timeZone, translatedDateTime) as Instant // TODO: better\n  return translatedInstant[epochNanoSymbol].add(durationTimeToNano(duration))\n}\n\nexport function translateDateTime(\n  fields: TranslatableObj,\n  duration: DurationFields,\n  options: Temporal.AssignmentOptions | undefined, // Calendar needs raw options\n): ISODateTimeFields {\n  const { calendar } = fields\n\n  // add large fields first\n  const date = calendar.dateAdd(\n    createDate(fields),\n    // don't let calendar round time fields to day\n    overrideDuration(duration, zeroDurationTimeFields),\n    options,\n  )\n\n  const epochNano = isoFieldsToEpochNano(date.getISOFields())\n    .add(isoTimeToNano(fields)) // restore original time-of-day\n    .add(durationTimeToNano(duration)) // add duration time parts\n\n  return epochNanoToISOFields(epochNano)\n}\n\nexport function translateDate(\n  dateFields: LocalDateFields,\n  durationFields: DurationFields,\n  calendarImpl: CalendarImpl,\n  overflowHandling: OverflowHandlingInt,\n): ISODateFields {\n  dateFields = addYears(dateFields, durationFields.years, calendarImpl, overflowHandling)\n  dateFields = addMonths(dateFields, durationFields.months, calendarImpl, overflowHandling)\n\n  let epochMilli = calendarImpl.epochMilliseconds(dateFields.year, dateFields.month, dateFields.day)\n\n  const daysFromTime = Math.trunc(durationTimeToNano(durationFields).div(nanoInDay).toNumber())\n  const days = durationFields.weeks * 7 + durationFields.days + daysFromTime\n  epochMilli = addDaysMilli(epochMilli, days)\n\n  return epochMilliToISOFields(epochMilli)\n}\n\nexport function addYears(\n  { year, month, day }: LocalDateFields,\n  yearsToAdd: number,\n  calendarImpl: CalendarImpl,\n  overflowHandling: OverflowHandlingInt,\n): LocalDateFields {\n  year += yearsToAdd\n  const newMonth = constrainInt(month, 1, calendarImpl.monthsInYear(year), overflowHandling)\n  let newDay = month === newMonth ? day : 1 // month was constrained? reset day\n  newDay = constrainInt(newDay, 1, calendarImpl.daysInMonth(year, newMonth), overflowHandling)\n  return { year, month: newMonth, day: newDay }\n}\n\nexport function addMonths(\n  { year, month, day }: LocalDateFields,\n  monthsToAdd: number,\n  calendarImpl: CalendarImpl,\n  overflowHandling: OverflowHandlingInt,\n): LocalDateFields {\n  if (monthsToAdd) {\n    month += monthsToAdd\n\n    if (monthsToAdd < 0) {\n      while (month < 1) {\n        month += calendarImpl.monthsInYear(--year)\n      }\n    } else {\n      let monthsInYear\n      while (month > (monthsInYear = calendarImpl.monthsInYear(year))) {\n        month -= monthsInYear\n        year++\n      }\n    }\n\n    day = constrainInt(day, 1, calendarImpl.daysInMonth(year, month), overflowHandling)\n  }\n  return { year, month, day }\n}\n\nexport function addDays(\n  { isoYear, isoMonth, isoDay }: ISODateFields,\n  days: number,\n): ISODateFields {\n  if (days) {\n    let epochMilli = isoToEpochMilli(isoYear, isoMonth, isoDay)\n    epochMilli = addDaysMilli(epochMilli, days)\n    ;({ isoYear, isoMonth, isoDay } = epochMilliToISOFields(epochMilli))\n  }\n  return { isoYear, isoMonth, isoDay }\n}\n\nexport function translateTime(\n  timeFields: ISOTimeFields,\n  durationFields: DurationFields,\n): ISOTimeFields {\n  // TODO: will loss of precision cause a bug?\n  const nano = isoTimeToNano(timeFields) + durationTimeToNano(durationFields).toNumber()\n  const [newTimeFields] = nanoToISOTime(nano)\n  return newTimeFields\n}\n\nexport function translateEpochNano(epochNano: LargeInt, durationFields: DurationFields): LargeInt {\n  const largestUnit = computeLargestDurationUnit(durationFields)\n\n  if (largestUnit >= DAY) {\n    throw new RangeError('Duration cant have units >= days')\n  }\n\n  return epochNano.add(durationTimeToNano(durationFields))\n}\n\n// duration\n\nexport function addDurationFields(\n  d0: DurationFields, // should be added to relativeToArg FIRST\n  d1: DurationFields, // should be added to relativeToArg SECOND\n  relativeTo: DiffableObj | undefined,\n  calendar: Temporal.CalendarProtocol | undefined,\n): DurationFields {\n  const largestUnit = Math.max(\n    computeLargestDurationUnit(d0),\n    computeLargestDurationUnit(d1),\n  ) as DayTimeUnitInt\n\n  if (relativeTo === undefined && largestUnit <= DAY) {\n    return nanoToDuration(\n      durationDayTimeToNano(d0).add(durationDayTimeToNano(d1)),\n      largestUnit,\n    )\n  }\n\n  if (!relativeTo) {\n    throw new RangeError('Need relativeTo')\n  }\n\n  const translated = relativeTo.add(d0).add(d1)\n  return diffAccurate(relativeTo, translated, calendar!, largestUnit)\n}\n", "import { Temporal } from 'temporal-spec'\nimport { parseDisambigOption } from '../argParse/disambig'\nimport {\n  OFFSET_IGNORE,\n  OFFSET_REJECT,\n  OFFSET_USE,\n  OffsetHandlingInt,\n} from '../argParse/offsetHandling'\nimport { Calendar } from '../public/calendar'\nimport { Instant } from '../public/instant'\nimport { createDateTime } from '../public/plainDateTime'\nimport { LargeInt } from '../utils/largeInt'\nimport { roundToMinute } from '../utils/math'\nimport { zeroISOTimeFields } from './dayAndTime'\nimport { epochNanoSymbol, isoFieldsToEpochNano } from './epoch'\nimport { ISODateFields, ISODateTimeFields } from './isoFields'\nimport { getInstantFor } from './timeZone'\nimport { addDays } from './translate'\n\nexport interface OffsetComputableFields extends ISODateTimeFields {\n  calendar: Temporal.CalendarProtocol\n  timeZone: Temporal.TimeZoneProtocol\n  offsetNanoseconds?: number // TODO: change this back to `offset`? better for ZonedDateTime?\n  Z?: boolean\n}\n\nexport function checkInvalidOffset(isoFields: OffsetComputableFields): void {\n  const { offsetNanoseconds: offsetNano, timeZone, Z } = isoFields\n\n  // a non-Z offset defined? (for ALWAYS use Z as zero offset)\n  if (offsetNano !== undefined && !Z) {\n    const matchingEpochNano = findMatchingEpochNano(isoFields, offsetNano, timeZone, true)\n\n    if (matchingEpochNano === undefined) {\n      throw new RangeError('Mismatching offset/timezone') // TODO: more DRY\n    }\n  }\n}\n\nexport function computeZonedDateTimeEpochNano(\n  isoFields: OffsetComputableFields,\n  fuzzyMatching?: boolean,\n  offsetHandling: OffsetHandlingInt = OFFSET_REJECT,\n  disambigOptions?: Temporal.AssignmentOptions,\n): LargeInt {\n  const { offsetNanoseconds: offsetNano, timeZone, Z } = isoFields\n\n  if (offsetNano !== undefined && offsetHandling !== OFFSET_IGNORE) {\n    // we ALWAYS use Z as zero offset\n    if (offsetHandling === OFFSET_USE || Z) {\n      return isoFieldsToEpochNano(isoFields).sub(offsetNano)\n    } else {\n      const matchingEpochNano = findMatchingEpochNano(\n        isoFields,\n        offsetNano,\n        timeZone,\n        fuzzyMatching,\n      )\n      if (matchingEpochNano !== undefined) {\n        return matchingEpochNano\n      }\n      if (offsetHandling === OFFSET_REJECT) {\n        throw new RangeError('Mismatching offset/timezone')\n      }\n      // else, OFFSET_PREFER...\n    }\n  }\n\n  // compute fresh from TimeZone\n  const instant = getInstantFor(\n    timeZone,\n    createDateTime(isoFields),\n    parseDisambigOption(disambigOptions),\n  )\n\n  // TODO: better typing solution\n  return (instant as Instant)[epochNanoSymbol]\n}\n\nfunction findMatchingEpochNano(\n  isoFields: ISODateTimeFields & { calendar: Temporal.CalendarProtocol },\n  offsetNano: number,\n  timeZone: Temporal.TimeZoneProtocol,\n  fuzzyMatching?: boolean,\n): LargeInt | undefined {\n  const possibleInstants = timeZone.getPossibleInstantsFor(createDateTime(isoFields))\n  const utcEpochNano = isoFieldsToEpochNano(isoFields)\n  const roundedOffsetNano = fuzzyMatching ? roundToMinute(offsetNano) : offsetNano\n\n  for (const instant of possibleInstants) {\n    const possibleEpochNano = (instant as Instant)[epochNanoSymbol] // TODO: better typing\n    const possibleOffsetNano = utcEpochNano.sub(possibleEpochNano).toNumber()\n    const possibleOffsetRefined = fuzzyMatching\n      ? roundToMinute(possibleOffsetNano)\n      : possibleOffsetNano\n\n    if (possibleOffsetRefined === roundedOffsetNano) {\n      return possibleEpochNano\n    }\n  }\n}\n\n// best file for this?\nexport function computeNanoInDay(\n  fields: ISODateFields & { timeZone: Temporal.TimeZoneProtocol },\n): number {\n  const { timeZone } = fields\n\n  // TODO: awkard with iso8601 calendar\n  const day0 = { ...fields, ...zeroISOTimeFields, calendar: new Calendar('iso8601') }\n  const day1 = { ...addDays(day0, 1), ...zeroISOTimeFields, calendar: new Calendar('iso8601') }\n  const epochNano0 = (getInstantFor(timeZone, createDateTime(day0)) as Instant)[epochNanoSymbol]\n  const epochNano1 = (getInstantFor(timeZone, createDateTime(day1)) as Instant)[epochNanoSymbol]\n\n  return epochNano1.sub(epochNano0).toNumber()\n}\n", "\nconst yearMonthRegExpStr =\n  '([+-]\\\\d{6}|\\\\d{4})' + // 0: year\n  '-?(\\\\d{2})' // 1: month\n  // ending... 12: timeZone, 14: calendar\n\nconst dateRegExpStr =\n  yearMonthRegExpStr + // 0-1: yearMonth\n  '-?(\\\\d{2})' // 2: day\n  // ending... 13: timeZone, 15: calendar\n\nconst monthDayRegExpStr =\n  '(--)?(\\\\d{2})' + // 1: month\n  '-?(\\\\d{2})' // 2: day\n  // ending... 13: timeZone, 15: calendar\n\nconst timeRegExpStr =\n  '(\\\\d{2})' + // 0: hour\n  '(:?(\\\\d{2})' + // 2: minute\n  '(:?(\\\\d{2})' + // 4: second\n  '([.,](\\\\d{1,9}))?' + // 6: afterDecimal\n  ')?)?'\n\nconst dateTimeRegExpStr =\n  dateRegExpStr + // 0-2: date\n  '([T ]' + // 3: timeEverything\n  timeRegExpStr + // 4-10: time\n  ')?'\n  // ending... 11: zOrOffset, 12-19: offset, 21: timeZone, 23: calendar\n\nconst offsetRegExpStr =\n  '([+-])' + // 0: plusOrMinus\n  timeRegExpStr // 1-7: time\n\nconst endingRegExpStr =\n  '(Z|' + // 0: zOrOffset\n  offsetRegExpStr + // 1-8: offset\n  ')?' +\n  '(\\\\[([^=\\\\]]+)\\\\])?' + // 10: timeZone\n  '(\\\\[u-ca=([^\\\\]]+)\\\\])?' // 12: calendar\n\nexport const yearMonthRegExp = createRegExp(yearMonthRegExpStr + endingRegExpStr)\nexport const monthDayRegExp = createRegExp(monthDayRegExpStr + endingRegExpStr)\nexport const dateTimeRegExp = createRegExp(dateTimeRegExpStr + endingRegExpStr)\nexport const timeRegExp = createRegExp('T?' + timeRegExpStr + endingRegExpStr)\nexport const offsetRegExp = createRegExp(offsetRegExpStr)\n\n// TODO: use same DRY technique as above\nexport const durationRegExp = /^([-+])?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T((\\d+)([.,](\\d{1,9}))?H)?((\\d+)([.,](\\d{1,9}))?M)?((\\d+)([.,](\\d{1,9}))?S)?)?$/i\n\n// TODO: inject this into regexes above?\nconst unicodeDashRegExp = /\\u2212/g\n\nfunction createRegExp(meat: string): RegExp {\n  return new RegExp(`^${meat}$`, 'i')\n}\n\nexport function normalizeDashes(str: string): string {\n  return str.replace(unicodeDashRegExp, '-')\n}\n", "import { padEnd } from '../utils/string'\nimport { isValidDateISO } from './constrain'\nimport { nanoToISOTime } from './dayAndTime'\nimport { isoEpochLeapYear } from './epoch'\nimport { ISODateFields, ISODateTimeFields, ISOTimeFields } from './isoFields'\nimport {\n  dateTimeRegExp,\n  monthDayRegExp,\n  normalizeDashes,\n  offsetRegExp,\n  timeRegExp,\n  yearMonthRegExp,\n} from './parseRegExp'\nimport {\n  nanoInHour,\n  nanoInMinute,\n  nanoInSecond,\n} from './units'\n\nexport interface DateParseResults extends ISODateFields {\n  calendar: string | undefined\n}\n\nexport interface DateTimeParseResult extends ISODateTimeFields {\n  calendar: string | undefined\n}\n\nexport interface ZonedDateTimeParseResult extends DateTimeParseResult {\n  timeZone: string | undefined\n  offsetNanoseconds: number | undefined\n  Z: boolean | undefined // whether ISO8601 specified with 'Z' as offset indicator\n}\n\n// hard functions (throw error on failure)\n\nexport function parseZonedDateTime(str: string): ZonedDateTimeParseResult {\n  const res = tryParseZonedDateTime(str)\n  if (!res) {\n    throw createParseError('dateTime', str)\n  }\n  return res\n}\n\nexport function parseDateTime(str: string): DateTimeParseResult {\n  const res = tryParseDateTime(str)\n  if (!res) {\n    throw createParseError('dateTime', str)\n  }\n  return res\n}\n\nexport function parseYearMonth(str: string): DateParseResults {\n  const res = tryParseYearMonth(str) || tryParseDateTime(str)\n  if (!res) {\n    throw createParseError('yearMonth', str)\n  }\n  return res\n}\n\nexport function parseMonthDay(str: string): DateParseResults {\n  const res = tryParseMonthDay(str) || tryParseDateTime(str)\n  if (!res) {\n    throw createParseError('monthDay', str)\n  }\n  return res\n}\n\nexport function parseOffsetNano(str: string): number {\n  const res = tryParseOffsetNano(str)\n  if (res === undefined) {\n    throw createParseError('timeZone', str) // timeZone?\n  }\n  return res\n}\n\nexport function parseTime(str: string): ISOTimeFields {\n  let res = tryParseTime(str)\n\n  if (res !== undefined) {\n    // detect ambiguity in format\n    if (str.charAt(0) !== 'T') {\n      const tryOther = tryParseYearMonth(str) || tryParseMonthDay(str)\n      if (tryOther && isValidDateISO(tryOther)) {\n        res = undefined // invalid\n      }\n    }\n  } else {\n    res = tryParseDateTime(str, true)\n  }\n\n  if (res === undefined) {\n    throw createParseError('time', str)\n  }\n  return res\n}\n\n// soft functions (return undefined on failure)\n\nconst zRE = /^Z$/i\n\nexport function tryParseZonedDateTime(str: string): ZonedDateTimeParseResult | undefined {\n  const m = dateTimeRegExp.exec(normalizeDashes(str))\n  if (m) {\n    return parseZonedDateTimeParts(m.slice(1))\n  }\n}\n\nexport function tryParseDateTime(\n  str: string,\n  requireTime?: boolean,\n  allowZ?: boolean,\n): DateTimeParseResult | undefined {\n  const m = dateTimeRegExp.exec(normalizeDashes(str))\n  if (\n    m &&\n    (allowZ || !zRE.test(m[12])) && // don't allow Z (12 means index 11 when unsliced)\n    (!requireTime || m[4]) // timeEverything (4 means index 3 when unsliced)\n  ) {\n    return parseDateTimeParts(m.slice(1))\n  }\n}\n\nfunction tryParseYearMonth(str: string): DateParseResults | undefined {\n  const m = yearMonthRegExp.exec(normalizeDashes(str))\n  if (m) {\n    return parseYearMonthParts(m.slice(1))\n  }\n}\n\nfunction tryParseMonthDay(str: string): DateParseResults | undefined {\n  const m = monthDayRegExp.exec(normalizeDashes(str))\n  if (m) {\n    return parseMonthDayParts(m.slice(1))\n  }\n}\n\nfunction tryParseTime(str: string) {\n  const m = timeRegExp.exec(normalizeDashes(str))\n  if (m) {\n    return parseTimeParts(m.slice(1))\n  }\n}\n\nexport function tryParseOffsetNano(str: string): number | undefined {\n  const m = offsetRegExp.exec(normalizeDashes(str))\n  if (m) {\n    return parseOffsetParts(m.slice(1))\n  }\n}\n\n// parsing of string parts\n// TODO: don't need toInt1/toInt0 as much because parts are more guaranteed now\n// TODO: combine the zoned/unzoned cases. will simplify caller functions?\n\nfunction parseZonedDateTimeParts(parts: string[]): ZonedDateTimeParseResult {\n  const zOrOffset = parts[11]\n  let offsetNanoseconds: number | undefined\n  let Z = false\n\n  if (zOrOffset) {\n    Z = zRE.test(zOrOffset)\n    offsetNanoseconds = Z ? 0 : parseOffsetParts(parts.slice(12))\n  }\n\n  return {\n    ...parseDateTimeParts(parts),\n    timeZone: parts[21],\n    offsetNanoseconds,\n    Z,\n  }\n}\n\nfunction parseDateTimeParts(parts: string[]): DateTimeParseResult {\n  return {\n    calendar: parts[23],\n    isoYear: toInt1(parts[0]),\n    isoMonth: toInt1(parts[1]),\n    isoDay: toInt1(parts[2]),\n    ...parseTimeParts(parts.slice(4)),\n  }\n}\n\nfunction parseYearMonthParts(parts: string[]): DateParseResults {\n  return {\n    calendar: parts[14],\n    isoYear: toInt1(parts[0]),\n    isoMonth: toInt1(parts[1]),\n    isoDay: 1,\n  }\n}\n\nfunction parseMonthDayParts(parts: string[]): DateParseResults {\n  return {\n    calendar: parts[15],\n    isoYear: isoEpochLeapYear,\n    isoMonth: toInt1(parts[1]),\n    isoDay: toInt1(parts[2]),\n  }\n}\n\nfunction parseTimeParts(parts: string[]): ISOTimeFields {\n  const isoSecond = toInt0(parts[4])\n\n  return {\n    ...nanoToISOTime(parseNanoAfterDecimal(parts[6] || ''))[0],\n    isoHour: toInt0(parts[0]),\n    isoMinute: toInt0(parts[2]),\n    isoSecond: isoSecond === 60 ? 59 : isoSecond, // massage lead-second\n  }\n}\n\nfunction parseOffsetParts(parts: string[]): number {\n  return (parts[0] === '+' ? 1 : -1) * timePartsToNano(parts.slice(1))\n}\n\n// time parsing as nanoseconds\n\nfunction timePartsToNano(parts: string[]): number {\n  return toInt0(parts[0]) * nanoInHour +\n    toInt0(parts[2]) * nanoInMinute +\n    toInt0(parts[4]) * nanoInSecond +\n    parseNanoAfterDecimal(parts[6] || '')\n}\n\nexport function parseNanoAfterDecimal(str: string): number {\n  return parseInt(padEnd(str, 9, '0'))\n}\n\n// general utils\n\nfunction toInt0(input: string | undefined): number { // 0-based\n  return parseInt(input || '0')\n}\n\nfunction toInt1(input: string | undefined): number { // 1-based\n  return parseInt(input || '1')\n}\n\nexport function toIntMaybe(input: string | undefined): number | undefined {\n  return input === undefined ? undefined : parseInt(input)\n}\n\nexport function createParseError(type: string, str: string): any {\n  throw new RangeError(`Cannot parse ${type} '${str}'`)\n}\n", "import { Calendar, createDefaultCalendar } from '../public/calendar'\nimport { TimeZone } from '../public/timeZone'\n\ninterface BaseParseResult {\n  calendar: string | undefined\n}\n\ninterface ZonedParseResult extends BaseParseResult {\n  timeZone: string | undefined\n}\n\nexport function refineBaseObj<T extends BaseParseResult>(\n  parsed: T,\n): T & { calendar: Calendar } { // TODO: weird TS anding-behavior\n  return {\n    ...parsed,\n    calendar: parsed.calendar === undefined\n      ? createDefaultCalendar()\n      : new Calendar(parsed.calendar),\n  }\n}\n\nexport function refineZonedObj<T extends ZonedParseResult>(\n  parsed: T,\n): T & { calendar: Calendar, timeZone: TimeZone } { // TODO: weird TS anding-behavior\n  return {\n    ...refineBaseObj(parsed),\n    timeZone: new TimeZone(parsed.timeZone!), // will throw error if empty timeZone\n  }\n}\n", "import { LargeInt } from '../utils/largeInt'\n\nexport type RawTransition = [\n  LargeInt, // epochNano\n  number, // offsetNanoBefore\n  number, // offsetNanoAfter\n]\n\nexport abstract class TimeZoneImpl {\n  constructor(public id: string) {}\n\n  abstract getPossibleOffsets(zoneNano: LargeInt): number[] // offsetNanos\n  abstract getOffset(epochNano: LargeInt): number // offsetNano\n  abstract getTransition(epochNano: LargeInt, direction: -1 | 1): RawTransition | undefined\n}\n", "import { RawTransition, TimeZoneImpl } from './timeZoneImpl'\n\nexport class FixedTimeZoneImpl extends TimeZoneImpl {\n  constructor(\n    id: string,\n    private offsetNano: number,\n  ) {\n    super(id)\n  }\n\n  getPossibleOffsets(): number[] {\n    return [this.offsetNano]\n  }\n\n  getOffset(): number {\n    return this.offsetNano\n  }\n\n  getTransition(): RawTransition | undefined {\n    return undefined\n  }\n}\n", "\nexport type IntlFormatPartsMap = { [partType: string]: string }\n\nexport function hashIntlFormatParts(\n  format: Intl.DateTimeFormat,\n  epochMillisecond: number,\n): IntlFormatPartsMap {\n  const hash: IntlFormatPartsMap = {}\n  const parts = format.formatToParts(epochMillisecond) // TODO: use original methods\n\n  for (const part of parts) {\n    hash[part.type] = part.value\n  }\n\n  return hash\n}\n\nconst eraRemap: { [eraIn: string]: string } = {\n  bc: 'bce',\n  ad: 'ce',\n}\n\nexport function normalizeShortEra(formattedEra: string): string {\n  // Example 'Before R.O.C.' -> 'beforeroc'\n  formattedEra = formattedEra\n    .toLowerCase()\n    .normalize('NFD') // break apart accents, for 'Sh\u014Dwa' -> 'Showa'\n    .replace(/[^a-z0-9]/g, '')\n\n  return eraRemap[formattedEra] || formattedEra\n}\n", "import { Intl as IntlSpec } from 'temporal-spec'\nimport { isObjectLike } from '../argParse/refine'\n\nexport type LocalesArg = string | string[]\n\n// TODO: unify this as a class/const, to just export DateTimeFormat,\n// and have whole src reference it only, not Intl.DateTimeFormat\nexport const OrigDateTimeFormat = Intl.DateTimeFormat\n\nexport function normalizeAndCopyLocalesArg(localesArg: LocalesArg | undefined): string[] {\n  return ([] as string[]).concat(localesArg || [])\n}\n\n// TODO: more efficient way to do this, mapping resolvedOptions\nexport function flattenOptions(\n  options: IntlSpec.DateTimeFormatOptions,\n): Intl.DateTimeFormatOptions {\n  const newOptions: Intl.DateTimeFormatOptions = {}\n\n  for (const name in options) {\n    let val = (options as any)[name]\n\n    if (isObjectLike(val)) {\n      val = val.toString()\n    }\n\n    (newOptions as any)[name] = val\n  }\n\n  return newOptions\n}\n", "import { nanoInMilli } from '../dateUtils/units'\nimport { LargeInt, createLargeInt } from '../utils/largeInt'\nimport { RawTransition } from './timeZoneImpl'\n\nexport const specialCases: {\n  [timeZoneID: string]: { [year: string]: RawTransition[] }\n} = {\n  'Pacific/Apia': {\n    2011: [\n      // TODO: this was much nicer when specified in seconds\n      // TODO: have RawTransitions be seconds again?\n      [toNano(1301752800000), -36000000000000, -39600000000000], // start DST\n      [toNano(1316872800000), -39600000000000, -36000000000000], // end DST\n      [toNano(1325239200000), -36000000000000, 50400000000000], // change of time zone\n    ],\n  },\n}\n\nfunction toNano(milli: number): LargeInt {\n  return createLargeInt(milli).mult(nanoInMilli)\n}\n", "import { epochNanoToISOYear, isoToEpochMilli, isoYearToEpochSeconds } from '../dateUtils/epoch'\nimport { hashIntlFormatParts, normalizeShortEra } from '../dateUtils/intlFormat'\nimport { milliInSecond, nanoInSecond, secondsInDay } from '../dateUtils/units'\nimport { OrigDateTimeFormat } from '../native/intlUtils'\nimport { LargeInt, compareLargeInts, createLargeInt } from '../utils/largeInt'\nimport { specialCases } from './specialCases'\nimport { RawTransition, TimeZoneImpl } from './timeZoneImpl'\n\nconst DST_EARLIEST_YEAR = 1847 // year with the first DST transitions\nconst DST_PERSIST_YEAR = new Date().getUTCFullYear() + 10 // DST won't change on or after this\n\nconst ISLAND_SEARCH_DAYS = [\n  182, // 50% through year\n  91, // 25% through year\n  273, // 75% through year\n]\n\n// TODO: general question: why not use minutes internally instead of seconds?\n// No... Temporal.ZonedDateTime.from({ year: 1971, month: 1, day: 1, timeZone: 'Africa/Monrovia' })\n// .offset => '-00:44:30' // seconds\n\nexport class IntlTimeZoneImpl extends TimeZoneImpl {\n  private format: Intl.DateTimeFormat\n\n  // a cache of second offsets at the last second of each year\n  private yearEndOffsets: { [year: string]: number }\n\n  private transitionsInYear: { [year: string]: RawTransition[] }\n\n  constructor(id: string) {\n    const format = new OrigDateTimeFormat('en-GB', { // gives 24-hour clock\n      era: 'short',\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      timeZone: id,\n    })\n    super(format.resolvedOptions().timeZone)\n    this.format = format\n    this.yearEndOffsets = {}\n    this.transitionsInYear = specialCases[id] || {}\n  }\n\n  // `zoneNano` is like epochNano, but from zone's pseudo-epoch\n  getPossibleOffsets(zoneNano: LargeInt): number[] {\n    let lastOffsetNano: number | undefined\n\n    const transitions = [\n      this.getTransition(zoneNano, -1),\n      this.getTransition(zoneNano.sub(1), 1),\n      // ^subtract 1 b/c getTransition is always exclusive\n    ].filter(Boolean) as RawTransition[]\n\n    // loop transitions from past to future\n    for (const transition of transitions) {\n      const [transitionEpochNano, offsetNanoBefore, offsetNanoAfter] = transition\n      // FYI, a transition's switchover to offsetNanoAfter happens\n      // *inclusively* as transitionEpochNano\n\n      // two possibilities (no guarantee of chronology)\n      const epochNanoA = zoneNano.sub(offsetNanoBefore)\n      const epochNanoB = zoneNano.sub(offsetNanoAfter)\n\n      // is the transition after both possibilities?\n      if (\n        compareLargeInts(transitionEpochNano, epochNanoA) > 0 && // >\n        compareLargeInts(transitionEpochNano, epochNanoB) > 0 // >\n      ) {\n        return [offsetNanoBefore]\n\n      // is the transition before both possibilities?\n      } else if (\n        compareLargeInts(transitionEpochNano, epochNanoA) <= 0 && // <=\n        compareLargeInts(transitionEpochNano, epochNanoB) <= 0 // <=\n      ) {\n        // keep looping...\n\n      // stuck in a transition?\n      } else {\n        // if the offset increases, we're inside a forward transition that looses an hour\n        // return an empty result because zoneNano lives within this empty region\n        if (offsetNanoBefore < offsetNanoAfter) {\n          return []\n        } else {\n          return [offsetNanoBefore, offsetNanoAfter]\n        }\n      }\n\n      lastOffsetNano = offsetNanoAfter\n    }\n\n    // only found transitions before zoneSecs\n    if (lastOffsetNano !== undefined) {\n      return [lastOffsetNano]\n    }\n\n    // found no transitions?\n    return [\n      this.getYearEndOffsetSec(epochNanoToISOYear(zoneNano)) * nanoInSecond,\n    ]\n  }\n\n  getOffset(epochNano: LargeInt): number {\n    return this.getOffsetForEpochSecs(\n      epochNano.div(nanoInSecond).toNumber(),\n    ) * nanoInSecond\n  }\n\n  private getOffsetForEpochSecs(epochSec: number): number {\n    // NOTE: if Intl.DateTimeFormat's timeZoneName:'shortOffset' option were available,\n    // we could parse that.\n    const map = hashIntlFormatParts(this.format, epochSec * milliInSecond)\n\n    let year = parseInt(map.year)\n    if (normalizeShortEra(map.era) === 'bce') {\n      year = -(year - 1)\n    }\n\n    const zoneMilli = isoToEpochMilli(\n      year,\n      parseInt(map.month),\n      parseInt(map.day),\n      parseInt(map.hour),\n      parseInt(map.minute),\n      parseInt(map.second),\n    )\n    const zoneSecs = Math.floor(zoneMilli / milliInSecond)\n\n    return zoneSecs - epochSec\n  }\n\n  /*\n  Always exclusive. Will never return a transition that starts exactly on epochNano\n  */\n  getTransition(epochNano: LargeInt, direction: -1 | 1): RawTransition | undefined {\n    let year = epochNanoToISOYear(epochNano)\n\n    if (year > DST_PERSIST_YEAR) {\n      // look ahead or behind ONE year\n      const res = this.getTransitionFrom(year, year + direction, direction, epochNano)\n      if (res || direction > 0) {\n        return res\n      }\n      // fast-backwards in-bounds\n      year = DST_PERSIST_YEAR\n    }\n\n    return this.getTransitionFrom(\n      Math.max(year, DST_EARLIEST_YEAR),\n      direction < 0\n        ? DST_EARLIEST_YEAR - 1 // inclusive -> exclusive\n        : DST_PERSIST_YEAR,\n      direction,\n      epochNano,\n    )\n  }\n\n  getTransitionFrom(\n    year: number,\n    endYear: number, // exclusive\n    direction: -1 | 1,\n    epochNano: LargeInt,\n  ): RawTransition | undefined {\n    for (; year !== endYear; year += direction) {\n      let transitions = this.getTransitionsInYear(year)\n\n      if (direction < 0) {\n        transitions = transitions.slice().reverse()\n      }\n\n      for (const transition of transitions) {\n        // does the current transition overtake epochNano in the direction of travel?\n        if (compareLargeInts(transition[0], epochNano) === direction) {\n          return transition\n        }\n      }\n    }\n  }\n\n  private getYearEndOffsetSec(utcYear: number): number {\n    const { yearEndOffsets } = this\n    return yearEndOffsets[utcYear] ||\n      (yearEndOffsets[utcYear] = this.getOffsetForEpochSecs(\n        isoYearToEpochSeconds(utcYear + 1) - 1,\n      ))\n  }\n\n  private getTransitionsInYear(utcYear: number): RawTransition[] {\n    const { transitionsInYear } = this\n    return transitionsInYear[utcYear] ||\n      (transitionsInYear[utcYear] = this.computeTransitionsInYear(utcYear))\n  }\n\n  private computeTransitionsInYear(utcYear: number): RawTransition[] {\n    const startOffsetSec = this.getYearEndOffsetSec(utcYear - 1) // right before start of year\n    const endOffsetSec = this.getYearEndOffsetSec(utcYear) // at end of year\n    // FYI, a transition could be in the first second of the year, thus the exclusiveness\n\n    // TODO: make a isoYearEndEpochSeconds util? use in getYearEndOffsetSec?\n    const startEpochSec = isoYearToEpochSeconds(utcYear) - 1\n    const endEpochSec = isoYearToEpochSeconds(utcYear + 1) - 1\n\n    if (startOffsetSec !== endOffsetSec) {\n      return [this.searchTransition(startEpochSec, endEpochSec, startOffsetSec, endOffsetSec)]\n    }\n\n    const island = this.searchIsland(startOffsetSec, startEpochSec)\n    if (island !== undefined) {\n      return [\n        this.searchTransition(startEpochSec, island[0], startOffsetSec, island[1]),\n        this.searchTransition(island[0], endEpochSec, island[1], endOffsetSec),\n      ]\n    }\n\n    return []\n  }\n\n  // assumes the offset changes at some point between startSecs -> endSecs.\n  // finds the point where it switches over to the new offset.\n  private searchTransition(\n    startEpochSec: number,\n    endEpochSec: number,\n    startOffsetSec: number,\n    endOffsetSec: number,\n  ): RawTransition {\n    // keep doing binary search until start/end are 1 second apart\n    while (endEpochSec - startEpochSec > 1) {\n      const middleEpochSecs = Math.floor(startEpochSec + (endEpochSec - startEpochSec) / 2)\n      const middleOffsetSecs = this.getOffsetForEpochSecs(middleEpochSecs)\n\n      if (middleOffsetSecs === startOffsetSec) {\n        // middle is same as start. move start to the middle\n        startEpochSec = middleEpochSecs\n      } else {\n        // middle is same as end. move end to the middle\n        endEpochSec = middleEpochSecs\n      }\n    }\n    return [\n      createLargeInt(endEpochSec).mult(nanoInSecond),\n      startOffsetSec * nanoInSecond,\n      endOffsetSec * nanoInSecond,\n    ]\n  }\n\n  // assumes the offset is the same at startSecs and endSecs.\n  // pokes around the time in-between to see if there's a temporary switchover.\n  private searchIsland(\n    outerOffsetSec: number,\n    startEpochSec: number,\n  ): [number, number] | undefined { // [epochSec, offsetSec]\n    for (const days of ISLAND_SEARCH_DAYS) {\n      const epochSec = startEpochSec + days * secondsInDay\n      const offsetSec = this.getOffsetForEpochSecs(epochSec)\n      if (offsetSec !== outerOffsetSec) {\n        return [epochSec, offsetSec]\n      }\n    }\n  }\n}\n", "import { formatOffsetISO } from '../dateUtils/isoFormat'\nimport { tryParseOffsetNano } from '../dateUtils/parse'\nimport { nanoInDay } from '../dateUtils/units'\nimport { FixedTimeZoneImpl } from './fixedTimeZoneImpl'\nimport { IntlTimeZoneImpl } from './intlTimeZoneImpl'\nimport { TimeZoneImpl } from './timeZoneImpl'\n\nconst implCache: { [zoneName: string]: TimeZoneImpl } = {\n  UTC: new FixedTimeZoneImpl('UTC', 0),\n}\n\nexport function queryTimeZoneImpl(id: string): TimeZoneImpl {\n  id = String(id)\n  const key = id.toLocaleUpperCase() // uppercase is better for 'UTC'\n\n  if (implCache[key]) {\n    return implCache[key]\n  }\n\n  // parse a literal time zone offset\n  const offsetNano = tryParseOffsetNano(id)\n  if (offsetNano !== undefined) {\n    if (Math.abs(offsetNano) > nanoInDay) {\n      throw new RangeError('Offset out of bounds')\n    }\n    // don't store fixed-offset zones in cache. there could be many\n    return new FixedTimeZoneImpl(\n      formatOffsetISO(offsetNano),\n      offsetNano,\n    )\n  }\n\n  return (implCache[key] = new IntlTimeZoneImpl(id))\n}\n", "import { Temporal } from 'temporal-spec'\nimport { parseDisambigOption } from '../argParse/disambig'\nimport { isObjectLike } from '../argParse/refine'\nimport { timeZoneFromObj } from '../argParse/timeZone'\nimport { AbstractObj, ensureObj } from '../dateUtils/abstract'\nimport { epochNanoSymbol, epochNanoToISOFields, isoFieldsToEpochNano } from '../dateUtils/epoch'\nimport { formatOffsetISO } from '../dateUtils/isoFormat'\nimport { attachStringTag } from '../dateUtils/mixins'\nimport { checkInvalidOffset } from '../dateUtils/offset'\nimport { tryParseZonedDateTime } from '../dateUtils/parse'\nimport { refineZonedObj } from '../dateUtils/parseRefine'\nimport { getInstantFor } from '../dateUtils/timeZone'\nimport { TimeZoneImpl } from '../timeZoneImpl/timeZoneImpl'\nimport { queryTimeZoneImpl } from '../timeZoneImpl/timeZoneImplQuery'\nimport { createWeakMap } from '../utils/obj'\nimport { Calendar, createDefaultCalendar } from './calendar'\nimport { Instant, InstantArg } from './instant'\nimport { PlainDateTime, PlainDateTimeArg, createDateTime } from './plainDateTime'\n\n// FYI: the Temporal.TimeZoneLike type includes `string`\n// unlike many other object types\n\nconst [getImpl, setImpl] = createWeakMap<TimeZone, TimeZoneImpl>()\n\nexport class TimeZone extends AbstractObj implements Temporal.TimeZone {\n  constructor(id: string) {\n    if (!id) {\n      throw new RangeError('Invalid timezone ID')\n    }\n    super()\n    setImpl(this, queryTimeZoneImpl(id))\n  }\n\n  static from(arg: Temporal.TimeZoneLike): Temporal.TimeZoneProtocol {\n    if (isObjectLike(arg)) {\n      return timeZoneFromObj(arg)\n    }\n\n    const parsed = tryParseZonedDateTime(String(arg))\n\n    if (parsed) {\n      if (parsed.timeZone) {\n        const refined = refineZonedObj(parsed) // TODO: we don't need the calendar\n        checkInvalidOffset(refined)\n        return refined.timeZone\n      } else if (parsed.Z) {\n        return new TimeZone('UTC')\n      } else if (parsed.offsetNanoseconds !== undefined) {\n        return new TimeZone(formatOffsetISO(parsed.offsetNanoseconds))\n      }\n    }\n\n    return new TimeZone(String(arg)) // consider arg the literal time zone ID string\n  }\n\n  get id(): string {\n    return this.toString()\n  }\n\n  getOffsetStringFor(instantArg: InstantArg): string {\n    return formatOffsetISO(this.getOffsetNanosecondsFor(instantArg))\n  }\n\n  getOffsetNanosecondsFor(instantArg: InstantArg): number {\n    const instant = ensureObj(Instant, instantArg)\n    return getImpl(this).getOffset(instant[epochNanoSymbol])\n  }\n\n  getPlainDateTimeFor(\n    instantArg: InstantArg,\n    calendarArg: Temporal.CalendarLike = createDefaultCalendar(),\n  ): Temporal.PlainDateTime {\n    const instant = ensureObj(Instant, instantArg)\n    const isoFields = epochNanoToISOFields(\n      instant[epochNanoSymbol].add(this.getOffsetNanosecondsFor(instant)),\n    )\n    return createDateTime({\n      ...isoFields,\n      calendar: ensureObj(Calendar, calendarArg),\n    })\n  }\n\n  getInstantFor(\n    dateTimeArg: PlainDateTimeArg,\n    options?: Temporal.ToInstantOptions,\n  ): Temporal.Instant {\n    return getInstantFor(this, ensureObj(PlainDateTime, dateTimeArg), parseDisambigOption(options))\n  }\n\n  getPossibleInstantsFor(dateTimeArg: PlainDateTimeArg): Temporal.Instant[] {\n    const isoFields = ensureObj(PlainDateTime, dateTimeArg).getISOFields()\n    const zoneNano = isoFieldsToEpochNano(isoFields)\n    const possibleOffsetNanos = getImpl(this).getPossibleOffsets(zoneNano)\n\n    return possibleOffsetNanos.map((offsetNano) => (\n      new Instant(zoneNano.sub(offsetNano))\n    ))\n  }\n\n  getPreviousTransition(instantArg: InstantArg): Temporal.Instant | null {\n    const instant = ensureObj(Instant, instantArg)\n    const rawTransition = getImpl(this).getTransition(instant[epochNanoSymbol], -1)\n    if (rawTransition) {\n      return new Instant(rawTransition[0])\n    }\n    return null\n  }\n\n  getNextTransition(instantArg: InstantArg): Temporal.Instant | null {\n    const instant = ensureObj(Instant, instantArg)\n    const rawTransition = getImpl(this).getTransition(instant[epochNanoSymbol], 1)\n    if (rawTransition) {\n      return new Instant(rawTransition[0])\n    }\n    return null\n  }\n\n  toString(): string {\n    return getImpl(this).id\n  }\n}\n\n// mixins\nexport interface TimeZone { [Symbol.toStringTag]: 'Temporal.TimeZone' }\nattachStringTag(TimeZone, 'TimeZone')\n", "import { Temporal } from 'temporal-spec'\nimport { ensureObj } from '../dateUtils/abstract'\nimport { TimeZone } from '../public/timeZone'\nimport { isObjectLike } from './refine'\n\nexport function timeZoneFromObj(obj: any): Temporal.TimeZoneProtocol {\n  const innerTimeZone = obj.timeZone\n  if (innerTimeZone === undefined) {\n    return obj\n  }\n  if (isObjectLike(innerTimeZone) && innerTimeZone.timeZone === undefined) {\n    return innerTimeZone as any\n  }\n  return new TimeZone(innerTimeZone)\n}\n\nexport function extractTimeZone(input: any): Temporal.TimeZoneProtocol {\n  if (input.timeZone === undefined) {\n    throw new TypeError('Must specify timeZone')\n  }\n  return ensureObj(TimeZone, input.timeZone)\n}\n", "import { Temporal } from 'temporal-spec'\nimport { extractCalendar } from '../argParse/calendar'\nimport {\n  dateFieldMap,\n  durationFieldMap,\n  monthDayFieldMap,\n  timeFieldMap,\n  yearMonthFieldMap,\n} from '../argParse/fieldStr'\nimport { OverflowHandlingInt } from '../argParse/overflowHandling'\nimport { isObjectLike, refineFields } from '../argParse/refine'\nimport { extractTimeZone } from '../argParse/timeZone'\nimport { Calendar, mergeCalFields } from '../public/calendar'\nimport { PlainDate } from '../public/plainDate'\nimport { PlainMonthDay } from '../public/plainMonthDay'\nimport { PlainYearMonth } from '../public/plainYearMonth'\nimport { ZonedDateTime } from '../public/zonedDateTime'\nimport { mapHash } from '../utils/obj'\nimport { constrainTimeISO } from './constrain'\nimport { partialLocalTimeToISO, zeroISOTimeFields } from './dayAndTime'\nimport { DurationFields } from './durationFields'\nimport { isoEpochLeapYear } from './epoch'\nimport { ISOTimeFields } from './isoFields'\nimport { LocalTimeFields } from './localFields'\nimport { OffsetComputableFields } from './offset'\nimport { parseOffsetNano } from './parse'\n\nexport const processZonedDateTimeFromFields = buildSafeFunc(tryZonedDateTimeFromFields)\nexport const processDateTimeFromFields = buildSafeFunc(tryDateTimeFromFields)\nexport const processDateFromFields = buildSafeFunc(tryDateFromFields)\nexport const processYearMonthFromFields = buildSafeFunc(tryYearMonthFromFields)\nexport const processMonthDayFromFields = buildSafeFunc(tryMonthDayFromFields)\nexport const processTimeFromFields = buildSafeFunc(tryTimeFromFields)\n\nexport const processZonedDateTimeWithFields = buildSafeFunc(tryZonedDateTimeWithFields, true)\nexport const processDateTimeWithFields = buildSafeFunc(tryDateTimeWithFields, true)\nexport const processDateWithFields = buildSafeFunc(tryDateWithFields, true)\nexport const processYearMonthWithFields = buildSafeFunc(tryYearMonthWithFields, true)\nexport const processMonthDayWithFields = buildSafeFunc(tryMonthDayWithFields, true)\nexport const processTimeWithFields = buildSafeFunc(tryTimeWithFields, true)\n\nexport const processDurationFields = buildSafeFunc(tryDurationFields)\n\n// ::from (UNSAFE verions)\n\nfunction tryZonedDateTimeFromFields(\n  rawFields: any,\n  overflowHandling: OverflowHandlingInt,\n  options?: Temporal.AssignmentOptions,\n): OffsetComputableFields | undefined {\n  const res = tryDateTimeFromFields(rawFields, overflowHandling, options)\n\n  if (res) {\n    return {\n      ...res,\n      timeZone: extractTimeZone(rawFields),\n      offsetNanoseconds: rawFields.offset !== undefined\n        ? parseOffsetNano(String(rawFields.offset))\n        : undefined,\n    }\n  }\n}\n\nfunction tryDateTimeFromFields(\n  rawFields: Temporal.PlainDateLike,\n  overflowHandling: OverflowHandlingInt,\n  options?: Temporal.AssignmentOptions,\n): Temporal.PlainDateTimeISOFields | undefined {\n  const dateRes = tryDateFromFields(rawFields, options)\n  const timeRes = tryTimeFromFields(rawFields, overflowHandling)\n\n  if (dateRes) {\n    return {\n      ...dateRes.getISOFields(),\n      ...(timeRes || zeroISOTimeFields),\n    }\n  }\n}\n\nfunction tryDateFromFields(\n  rawFields: Temporal.PlainDateLike,\n  options?: Temporal.AssignmentOptions,\n): PlainDate | undefined {\n  const calendar = extractCalendar(rawFields)\n  const filteredFields = filterFieldsViaCalendar(rawFields, dateFieldMap, calendar)\n\n  if (hasAnyProps(filteredFields)) {\n    return calendar.dateFromFields(filteredFields, options)\n  }\n}\n\nfunction tryYearMonthFromFields(\n  rawFields: Temporal.PlainYearMonthLike,\n  options?: Temporal.AssignmentOptions,\n): PlainYearMonth | undefined {\n  const calendar = extractCalendar(rawFields)\n  const filteredFields = filterFieldsViaCalendar(rawFields, yearMonthFieldMap, calendar)\n\n  if (hasAnyProps(filteredFields)) {\n    return calendar.yearMonthFromFields(filteredFields, options)\n  }\n}\n\nfunction tryMonthDayFromFields(\n  rawFields: any,\n  options?: Temporal.AssignmentOptions,\n): PlainMonthDay | undefined {\n  const calendar = extractCalendar(rawFields)\n  const filteredFields = filterFieldsViaCalendar(rawFields, monthDayFieldMap, calendar)\n\n  if (hasAnyProps(filteredFields)) {\n    if (rawFields.year === undefined && rawFields.calendar === undefined) {\n      filteredFields.year = isoEpochLeapYear\n    }\n\n    return calendar.monthDayFromFields(filteredFields, options)\n  }\n}\n\nfunction tryTimeFromFields(\n  rawFields: any,\n  overflowHandling: OverflowHandlingInt,\n): ISOTimeFields | undefined {\n  const refinedFields = refineFields(rawFields, timeFieldMap)\n\n  if (hasAnyProps(refinedFields)) {\n    return constrainTimeISO(partialLocalTimeToISO(refinedFields), overflowHandling)\n  }\n}\n\n// ::with (UNSAFE versions)\n\nfunction tryZonedDateTimeWithFields(\n  zonedDateTime: ZonedDateTime,\n  rawFields: any,\n  overflowHandling: OverflowHandlingInt,\n  options?: Temporal.AssignmentOptions,\n): OffsetComputableFields | undefined {\n  const res = tryDateTimeWithFields(zonedDateTime, rawFields, overflowHandling, options)\n  const hasNewOffset = rawFields.offset !== undefined\n\n  if (res || hasNewOffset) {\n    return {\n      ...(res || zonedDateTime.getISOFields()),\n      timeZone: zonedDateTime.timeZone,\n      offsetNanoseconds: hasNewOffset\n        ? parseOffsetNano(String(rawFields.offset))\n        : zonedDateTime.offsetNanoseconds,\n    }\n  }\n}\n\nfunction tryDateTimeWithFields(\n  plainDateTime: any,\n  rawFields: any,\n  overflowHandling: OverflowHandlingInt,\n  options?: Temporal.AssignmentOptions,\n): Temporal.PlainDateTimeISOFields | undefined {\n  const dateRes = tryDateWithFields(plainDateTime, rawFields, options)\n  const timeRes = tryTimeWithFields(plainDateTime, rawFields, overflowHandling)\n\n  if (dateRes || timeRes) {\n    return {\n      ...plainDateTime.getISOFields(),\n      ...(dateRes ? dateRes.getISOFields() : {}),\n      ...timeRes,\n    }\n  }\n}\n\nfunction tryDateWithFields(\n  plainDate: any,\n  rawFields: any,\n  options?: Temporal.AssignmentOptions,\n): PlainDate | undefined {\n  const calendar: Calendar = plainDate.calendar\n  const filteredFields = filterFieldsViaCalendar(rawFields, dateFieldMap, calendar)\n\n  if (hasAnyProps(filteredFields)) {\n    const mergedFields = mergeFieldsViaCalendar(plainDate, filteredFields, dateFieldMap, calendar)\n    return calendar.dateFromFields(mergedFields, options)\n  }\n}\n\nfunction tryYearMonthWithFields(\n  plainYearMonth: any,\n  rawFields: any,\n  options?: Temporal.AssignmentOptions,\n): PlainYearMonth | undefined {\n  const calendar: Calendar = plainYearMonth.calendar\n  const filteredFields = filterFieldsViaCalendar(rawFields, yearMonthFieldMap, calendar)\n\n  if (hasAnyProps(filteredFields)) {\n    const mergedFields = mergeFieldsViaCalendar(\n      plainYearMonth,\n      rawFields,\n      yearMonthFieldMap,\n      calendar,\n    )\n    return calendar.yearMonthFromFields(mergedFields, options)\n  }\n}\n\nfunction tryMonthDayWithFields(\n  plainMonthDay: any,\n  rawFields: any,\n  options?: Temporal.AssignmentOptions,\n): PlainMonthDay | undefined {\n  const calendar: Calendar = plainMonthDay.calendar\n  const filteredFields = filterFieldsViaCalendar(rawFields, monthDayFieldMap, calendar)\n\n  if (hasAnyProps(filteredFields)) {\n    const mergedFields = mergeFieldsViaCalendar(\n      plainMonthDay,\n      rawFields,\n      monthDayFieldMap,\n      calendar,\n    )\n    return calendar.monthDayFromFields(mergedFields, options)\n  }\n}\n\nfunction tryTimeWithFields(\n  plainTime: any,\n  rawFields: any,\n  overflowHandling: OverflowHandlingInt,\n): ISOTimeFields | undefined {\n  const refinedFields = refineFields(rawFields, timeFieldMap)\n\n  if (hasAnyProps(refinedFields)) {\n    const mergedFields = mergeLocalTimeFields(plainTime, refinedFields)\n    return constrainTimeISO(partialLocalTimeToISO(mergedFields), overflowHandling)\n  }\n}\n\n// duration (used for ::from and ::with)\n\nfunction tryDurationFields(rawFields: any): DurationFields | undefined {\n  const refinedFields = refineFields(rawFields, durationFieldMap) as any // !!!\n\n  if (hasAnyProps(refinedFields)) {\n    return refinedFields\n  }\n}\n\n// utils\n\nfunction filterFieldsViaCalendar(\n  objOrFields: any,\n  fieldMap: any,\n  calendar: Temporal.CalendarProtocol,\n): any {\n  let fieldNames = Object.keys(fieldMap)\n\n  if (calendar.fields) {\n    // convert Iterable<string> to string[]... better way?\n    fieldNames = Array.prototype.slice.call(calendar.fields(fieldNames))\n  } else {\n    // a Calendar 'protocol'\n    // filter by method names\n    fieldNames = Object.keys(filterFieldsViaWhitelist(calendar, fieldNames))\n  }\n\n  return filterFieldsViaWhitelist(objOrFields, fieldNames)\n}\n\nfunction filterFieldsViaWhitelist(objOrFields: any, whitelist: string[]): any {\n  const filtered = {} as any\n\n  for (const propName of whitelist) {\n    if (objOrFields[propName] !== undefined) {\n      filtered[propName] = objOrFields[propName]\n    }\n  }\n\n  return filtered\n}\n\nfunction mergeFieldsViaCalendar(\n  existingObj: any,\n  fields: any,\n  fieldMap: any,\n  calendar: Temporal.CalendarProtocol,\n): any {\n  const existingFields = filterFieldsViaCalendar(existingObj, fieldMap, calendar)\n\n  if (calendar.mergeFields) {\n    return calendar.mergeFields(existingFields, fields)\n  }\n\n  return mergeCalFields(existingFields, fields)\n}\n\nfunction mergeLocalTimeFields(\n  base: LocalTimeFields,\n  fields: Partial<LocalTimeFields>,\n): LocalTimeFields {\n  return mapHash(timeFieldMap, (_refineFunc, fieldName) => (\n    fields[fieldName as keyof LocalTimeFields] ?? base[fieldName as keyof LocalTimeFields]\n  ))\n}\n\n// TODO: use chaining instead of flag\nfunction buildSafeFunc<Args extends any[], Res>(\n  func: (...args: Args) => Res | undefined,\n  isWith?: boolean,\n): (...args: Args) => Res {\n  return (...args: Args) => {\n    if (isWith) {\n      const rawFields = args[1]\n      if (!isObjectLike(rawFields)) {\n        throw new TypeError('must be object-like')\n      }\n      if (rawFields.calendar !== undefined) {\n        throw new TypeError('calendar not allowed')\n      }\n      if (rawFields.timeZone !== undefined) {\n        throw new TypeError('timeZone not allowed')\n      }\n    }\n    const res = func(...args)\n    if (!res) {\n      throw new TypeError('No valid fields')\n    }\n    return res\n  }\n}\n\nfunction hasAnyProps(fields: any): boolean {\n  return Object.keys(fields).length > 0\n}\n", "import { checkEpochNanoBuggy } from '../calendarImpl/bugs'\nimport { LargeInt, compareLargeInts, createLargeInt } from '../utils/largeInt'\nimport { isoFieldsToEpochNano, throwOutOfRange } from './epoch'\nimport { ISODateFields, ISODateTimeFields } from './isoFields'\nimport { nanoInDay } from './units'\n\n/*\nExtreme valid inputs\n  Legacy Date\n    Date.UTC(-271821, 4 - 1, 20,  0, 0, 0, 0)\n    Date.UTC(275760, 9 - 1, 13,  0, 0, 0, 0)\n  Instant\n    Temporal.Instant.fromEpochMilliseconds(Date.UTC(-271821, 4 - 1, 20,  0, 0, 0, 0))\n    Temporal.Instant.fromEpochMilliseconds(Date.UTC(275760, 9 - 1, 13,  0, 0, 0, 0))\n  PlainDateTime\n    new Temporal.PlainDateTime(-271821, 4, 19,  0, 0, 0, 0, 0, 1).toString()\n    new Temporal.PlainDateTime(275760, 9, 13,  23, 59, 59, 999, 999, 999).toString()\n  PlainDate\n    new Temporal.PlainDate(-271821, 4, 19).toString()\n    new Temporal.PlainDate(275760, 9, 13).toString()\n  PlainYearMonth\n    new Temporal.PlainYearMonth(-271821, 4).toString()\n    new Temporal.PlainYearMonth(275760, 9).toString()\n*/\n\nconst almostDay = nanoInDay - 1 // one nanosecond shy of day\nconst maxInstantBI = createLargeInt(nanoInDay).mult(100000000) // 100,000,000 days\nconst minInstantBI = maxInstantBI.mult(-1)\nconst maxPlainBI = maxInstantBI.add(almostDay)\nconst minPlainBI = minInstantBI.sub(almostDay)\n\nexport function validateYearMonth(isoFields: ISODateFields, calendarID: string): void {\n  // might throw an error\n  // moves between days in month\n  const epochNano = isoFieldsToEpochNano(isoFields)\n\n  checkEpochNanoBuggy(epochNano, calendarID)\n}\n\nexport function validateDate(isoFields: ISODateFields, calendarID: string): void {\n  const epochNano = isoFieldsToEpochNano(isoFields)\n\n  validatePlain(\n    // if potentially very negative, measure last nanosecond of day\n    // to increase chances it's in-bounds\n    epochNano.add(epochNano.sign() < 0 ? almostDay : 0),\n  )\n  checkEpochNanoBuggy(epochNano, calendarID)\n}\n\nexport function validateDateTime(isoFields: ISODateTimeFields, calendarID: string): void {\n  const epochNano = isoFieldsToEpochNano(isoFields)\n\n  validatePlain(epochNano)\n  checkEpochNanoBuggy(epochNano, calendarID)\n}\n\nexport function validateInstant(epochNano: LargeInt): void {\n  if (\n    compareLargeInts(epochNano, minInstantBI) === -1 ||\n    compareLargeInts(epochNano, maxInstantBI) === 1\n  ) {\n    throwOutOfRange()\n  }\n}\n\nexport function validatePlain(epochNano: LargeInt): void {\n  // like validateInstant's bounds, but expanded 24:59:59.999999999\n  if (\n    compareLargeInts(epochNano, minPlainBI) === -1 ||\n    compareLargeInts(epochNano, maxPlainBI) === 1\n  ) {\n    throwOutOfRange()\n  }\n}\n", "import { Temporal } from 'temporal-spec'\nimport { OFFSET_PREFER } from '../argParse/offsetHandling'\nimport { RoundingConfig } from '../argParse/roundingOptions'\nimport { LargeInt } from '../utils/largeInt'\nimport { roundToIncrement, roundToIncrementBI } from '../utils/math'\nimport { isoTimeToNano, nanoToISOTime, zeroISOTimeFields } from './dayAndTime'\nimport { splitEpochNano } from './epoch'\nimport { ISODateTimeFields, ISOTimeFields } from './isoFields'\nimport { computeNanoInDay, computeZonedDateTimeEpochNano } from './offset'\nimport { addDays } from './translate'\nimport { DAY, DayTimeUnitInt, TimeUnitInt } from './units'\n\nexport function roundDateTime(\n  fields: ISODateTimeFields,\n  roundingConfig: RoundingConfig<DayTimeUnitInt>,\n): ISODateTimeFields {\n  const timeNano = isoTimeToNano(fields)\n  const roundedTimeNano = roundNano(timeNano, roundingConfig)\n  const [isoTimeFields, dayDelta] = nanoToISOTime(roundedTimeNano)\n\n  const dayStartTranslated = addDays(fields, dayDelta)\n  return { ...dayStartTranslated, ...isoTimeFields }\n}\n\nexport function roundTime(\n  fields: ISOTimeFields,\n  roundingConfig: RoundingConfig<TimeUnitInt>,\n): ISOTimeFields {\n  const timeNano = isoTimeToNano(fields)\n  const roundedTimeNano = roundNano(timeNano, roundingConfig)\n  const [isoTimeFields] = nanoToISOTime(roundedTimeNano)\n  return isoTimeFields\n}\n\nexport function roundEpochNano(\n  epochNano: LargeInt,\n  roundingConfig: RoundingConfig<TimeUnitInt>,\n): LargeInt {\n  const [dayEpochNano, timeNano] = splitEpochNano(epochNano)\n  const roundedTimeNano = roundNano(timeNano, roundingConfig)\n  return dayEpochNano.add(roundedTimeNano)\n}\n\n// returns epochNano!\nexport function roundZonedDateTimeFields(\n  fields: ISODateTimeFields & {\n    calendar: Temporal.CalendarProtocol,\n    timeZone: Temporal.TimeZoneProtocol,\n  },\n  offsetNanoseconds: number,\n  roundingConfig: RoundingConfig<DayTimeUnitInt>,\n): LargeInt {\n  const { calendar, timeZone } = fields\n  let timeNano = isoTimeToNano(fields)\n  let isoTimeFields: ISOTimeFields\n  let dayDelta: number\n\n  if (roundingConfig.smallestUnit === DAY) {\n    isoTimeFields = zeroISOTimeFields\n    dayDelta = roundingConfig.roundingFunc(timeNano / computeNanoInDay(fields))\n  } else {\n    timeNano = roundNano(timeNano, roundingConfig)\n    ;([isoTimeFields, dayDelta] = nanoToISOTime(timeNano))\n  }\n\n  const dayStartTranslated = addDays(fields, dayDelta)\n  return computeZonedDateTimeEpochNano(\n    {\n      ...dayStartTranslated,\n      ...isoTimeFields,\n      offsetNanoseconds,\n      calendar, // !!!\n      timeZone, // !!!\n    },\n    false,\n    OFFSET_PREFER, // for offsetNanoseconds conflicts\n  )\n}\n\n// low-level utils (just for day-and-time)\n\nexport function roundNano(nano: number, roundingConfig: RoundingConfig<DayTimeUnitInt>): number {\n  return roundToIncrement(\n    nano,\n    roundingConfig.incNano,\n    roundingConfig.roundingFunc,\n  )\n}\n\nexport function roundNanoBI(\n  nano: LargeInt,\n  roundingConfig: RoundingConfig<DayTimeUnitInt>,\n): LargeInt {\n  return roundToIncrementBI(\n    nano,\n    roundingConfig.incNano,\n    roundingConfig.roundingFunc,\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { zeroISOTimeFields } from '../dateUtils/dayAndTime'\nimport { isoFieldsToEpochMilli } from '../dateUtils/epoch'\nimport { createDateTime } from '../public/plainDateTime'\nimport { TimeZone } from '../public/timeZone'\nimport { OrigDateTimeFormat } from './intlUtils'\n\n// factory types\n\nexport interface BaseEntity {\n  calendar?: Temporal.CalendarProtocol\n  timeZone?: Temporal.TimeZoneProtocol\n}\n\nexport interface FormatFactory<Entity extends BaseEntity> {\n  buildKey: KeyFactory<Entity>\n  buildFormat: (calendarID: string, timeZoneID: string) => Intl.DateTimeFormat\n  buildEpochMilli: (entity: Entity) => number\n}\n\nexport type FormatFactoryFactory<Entity extends BaseEntity> = (\n  locales: string[],\n  options: Intl.DateTimeFormatOptions,\n) => FormatFactory<Entity>\n\n// zoned format factory\n\ninterface ZonedEntity extends BaseEntity {\n  epochMilliseconds: number\n}\n\nexport function createZonedFormatFactoryFactory<Entity extends ZonedEntity>(\n  greedyDefaults: Intl.DateTimeFormatOptions,\n  nonGreedyDefaults: Intl.DateTimeFormatOptions,\n  finalOptions: Intl.DateTimeFormatOptions,\n): FormatFactoryFactory<Entity> {\n  return (locales: string[], options: Intl.DateTimeFormatOptions): FormatFactory<Entity> => {\n    const defaults = anyDefaultsOverridden(greedyDefaults, options)\n      ? {}\n      : { ...greedyDefaults, ...nonGreedyDefaults }\n\n    function buildFormat(calendarID: string, timeZoneID: string): Intl.DateTimeFormat {\n      return new OrigDateTimeFormat(locales, {\n        calendar: calendarID,\n        timeZone: timeZoneID || undefined, // empty string should mean current timezone\n        ...defaults,\n        ...options,\n        ...finalOptions,\n      })\n    }\n\n    return {\n      buildKey: createKeyFactory(locales, options, false),\n      buildFormat,\n      buildEpochMilli: getEpochMilliFromZonedEntity,\n    }\n  }\n}\n\nfunction getEpochMilliFromZonedEntity(entity: ZonedEntity): number {\n  return entity.epochMilliseconds\n}\n\n// plain format factory\n\ninterface PlainEntity extends BaseEntity {\n  getISOFields: () => Temporal.PlainDateISOFields // might have time fields too\n}\n\nexport function createPlainFormatFactoryFactory<Entity extends PlainEntity>(\n  greedyDefaults: Intl.DateTimeFormatOptions,\n  finalOptions: Intl.DateTimeFormatOptions,\n  strictCalendar?: boolean,\n): FormatFactoryFactory<Entity> {\n  return (locales: string[], options: Intl.DateTimeFormatOptions): FormatFactory<Entity> => {\n    const defaults = anyDefaultsOverridden(greedyDefaults, options) ? {} : greedyDefaults\n\n    function buildFormat(calendarID: string, timeZoneID: string) {\n      return new OrigDateTimeFormat(locales, {\n        calendar: calendarID,\n        ...defaults,\n        ...options,\n        ...finalOptions,\n        timeZone: timeZoneID, // guaranteed to be defined because of above 'UTC'\n        timeZoneName: undefined, // never show timeZone name\n      })\n    }\n\n    // TODO: investigate if Intl.DateTimeFormat allows passing in an object/protocol `TimeZone`\n    // value. If so, we shouldn't call `new TimeZone`, but instead ensureTimeZoneProtocol\n\n    return {\n      buildKey: createKeyFactory(locales, options, strictCalendar),\n      buildFormat,\n      buildEpochMilli: options.timeZone !== undefined\n        ? computeEpochMilliViaTimeZone.bind(null, new TimeZone(options.timeZone))\n        : computeEpochMilliViaISO,\n    }\n  }\n}\n\nfunction computeEpochMilliViaTimeZone(timeZone: TimeZone, entity: PlainEntity): number {\n  const plainDateTime = createDateTime({ // necessary? pass directly into getInstantFor?\n    ...zeroISOTimeFields,\n    ...entity.getISOFields(),\n  })\n  return timeZone.getInstantFor(plainDateTime).epochMilliseconds\n}\n\nfunction computeEpochMilliViaISO(entity: PlainEntity): number {\n  return isoFieldsToEpochMilli(entity.getISOFields())\n}\n\n// cached format factory\n\nexport type CachedFormatFactory<Entity extends BaseEntity> = {\n  buildFormat: (entity: Entity, otherEntity?: Entity) => Intl.DateTimeFormat\n  buildEpochMilli: (entity: Entity) => number\n}\n\nexport function buildCachedFormatFactory<Entity extends BaseEntity>(\n  formatFactory: FormatFactory<Entity>,\n): CachedFormatFactory<Entity> {\n  const cachedFormats: { [key: string]: Intl.DateTimeFormat } = {}\n\n  function buildFormat(entity: Entity, otherEntity?: Entity): Intl.DateTimeFormat {\n    const keys = formatFactory.buildKey(entity, otherEntity)\n    const key = keys.join('|')\n\n    return cachedFormats[key] ||\n      (cachedFormats[key] = formatFactory.buildFormat(...keys))\n  }\n\n  return {\n    buildFormat,\n    buildEpochMilli: formatFactory.buildEpochMilli,\n  }\n}\n\n// keys\n\nexport type KeyFactory<Entity extends BaseEntity> = (\n  entity: Entity,\n  otherEntity?: Entity\n) => [string, string] // [calendarID, timeZoneID]\n\nfunction createKeyFactory<Entity extends BaseEntity>(\n  locales: string[],\n  options: Intl.DateTimeFormatOptions,\n  strictCalendar: boolean | undefined,\n): KeyFactory<Entity> {\n  const optionsCalendarID = options.calendar ?? extractUnicodeCalendar(locales)\n  const optionsTimeZoneID = options.timeZone\n\n  return function(entity: Entity, otherEntity?: Entity): [string, string] {\n    const entityCalendarID = entity.calendar?.id\n    const entityTimeZoneID = entity.timeZone?.id\n\n    if (otherEntity) {\n      // TODO: use ensureCalendarsEqual somehow?\n      if (otherEntity.calendar?.id !== entityCalendarID) {\n        throw new RangeError('Mismatching calendar')\n      }\n      if (otherEntity.timeZone?.id !== entityTimeZoneID) {\n        throw new RangeError('Mismatching timeZone')\n      }\n    }\n\n    if (\n      (strictCalendar || entityCalendarID !== isoCalendarID) &&\n      entityCalendarID !== undefined &&\n      optionsCalendarID !== undefined &&\n      optionsCalendarID !== entityCalendarID\n    ) {\n      throw new RangeError('Non-iso calendar mismatch')\n    }\n\n    if (\n      entityTimeZoneID !== undefined &&\n      optionsTimeZoneID !== undefined &&\n      optionsTimeZoneID !== entityTimeZoneID\n    ) {\n      throw new RangeError('Given timeZone must agree')\n    }\n\n    const calendarID = optionsCalendarID || entityCalendarID || isoCalendarID\n    const timeZoneID = optionsTimeZoneID || entityTimeZoneID || 'UTC'\n\n    return [calendarID, timeZoneID]\n  }\n}\n\nfunction extractUnicodeCalendar(locales: string[]): string | undefined {\n  for (const locale of locales) {\n    const m = locale.match(/-u-ca-(.*)$/)\n    if (m) {\n      return m[1]\n    }\n  }\n\n  return undefined\n}\n\n// general utils\n// TODO: move elsewhere?\n\nfunction anyDefaultsOverridden(defaults: any, overrides: any): boolean {\n  for (const propName in defaults) {\n    if (overrides[propName] !== undefined) {\n      return true\n    }\n  }\n  return false\n}\n", "import { formatFactoryFactorySymbol } from '../dateUtils/abstract'\nimport { BaseEntity, FormatFactoryFactory } from './intlFactory'\nimport { LocalesArg, normalizeAndCopyLocalesArg } from './intlUtils'\n\nexport interface ToLocaleStringMethods {\n  toLocaleString(localesArg?: LocalesArg, options?: Intl.DateTimeFormatOptions): string\n}\n\nexport function mixinLocaleStringMethods<Entity extends (ToLocaleStringMethods & BaseEntity)>(\n  ObjClass: { prototype: Entity },\n  buildFormatFactory: FormatFactoryFactory<Entity>,\n): void {\n  ObjClass.prototype.toLocaleString = function(\n    this: Entity,\n    localesArg?: LocalesArg,\n    options?: Intl.DateTimeFormatOptions,\n  ): string {\n    const formatFactory = buildFormatFactory(\n      normalizeAndCopyLocalesArg(localesArg),\n      options || {},\n    )\n    return formatFactory.buildFormat(\n      ...formatFactory.buildKey(this),\n    ).format(\n      formatFactory.buildEpochMilli(this),\n    )\n  }\n\n  ;(ObjClass.prototype as any)[formatFactoryFactorySymbol] = buildFormatFactory\n}\n\nexport function extractFormatFactoryFactory<Entity>(\n  obj: any,\n): FormatFactoryFactory<Entity> | undefined {\n  return obj?.[formatFactoryFactorySymbol]\n}\n", "import { createLargeInt } from '../utils/largeInt'\nimport { excludeUndefined } from '../utils/obj'\nimport { nanoToDuration } from './dayAndTime'\nimport {\n  DurationFields,\n  UnsignedDurationFields,\n  negateDuration,\n  signDuration,\n} from './durationFields'\nimport { createParseError, parseNanoAfterDecimal, toIntMaybe } from './parse'\nimport { durationRegExp, normalizeDashes } from './parseRegExp'\nimport {\n  HOUR,\n  MILLISECOND,\n  MINUTE,\n  SECOND,\n  TimeUnitInt,\n  nanoIn,\n  nanoInSecond,\n} from './units'\n\nexport function parseDuration(str: string): DurationFields {\n  const res = tryParseDuration(str)\n  if (res === undefined) {\n    throw createParseError('duration', str)\n  }\n  return res\n}\n\nfunction tryParseDuration(str: string): DurationFields | undefined {\n  const match = durationRegExp.exec(normalizeDashes(str))\n  if (match) { // TODO: break out into parseDurationParts\n    let hours: number | undefined\n    let minutes: number | undefined\n    let seconds: number | undefined\n    let leftoverNano: number | undefined\n\n    ([hours, leftoverNano] = parseDurationTimeUnit(match[8], match[10], HOUR, undefined));\n    ([minutes, leftoverNano] = parseDurationTimeUnit(match[12], match[14], MINUTE, leftoverNano));\n    ([seconds, leftoverNano] = parseDurationTimeUnit(match[16], match[18], SECOND, leftoverNano))\n\n    const fields: Partial<UnsignedDurationFields> = excludeUndefined({\n      years: toIntMaybe(match[2]),\n      months: toIntMaybe(match[3]),\n      weeks: toIntMaybe(match[4]),\n      days: toIntMaybe(match[5]),\n      hours,\n      minutes,\n      seconds,\n    })\n\n    if (!Object.keys(fields).length) {\n      throw new RangeError('Duration string must have at least one field')\n    }\n\n    const small = nanoToDuration(createLargeInt(leftoverNano || 0), MILLISECOND)\n    // TODO: use mergeDurations somehow?\n    fields.milliseconds = small.milliseconds\n    fields.microseconds = small.microseconds\n    fields.nanoseconds = small.nanoseconds\n\n    let signedDuration = signDuration(fields as UnsignedDurationFields)\n\n    if (match[1] === '-') {\n      signedDuration = negateDuration(signedDuration)\n    }\n\n    return signedDuration\n  }\n}\n\nfunction parseDurationTimeUnit(\n  beforeDecimal: string | undefined,\n  afterDecimal: string | undefined,\n  unit: TimeUnitInt,\n  leftoverNano: number | undefined,\n): [number | undefined, number | undefined] { // [wholeUnits, leftoverNano]\n  if (beforeDecimal !== undefined) {\n    if (leftoverNano !== undefined) {\n      throw new RangeError('Partial units must be last unit')\n    }\n    return [\n      parseInt(beforeDecimal),\n      afterDecimal !== undefined\n        ? parseNanoAfterDecimal(afterDecimal) * (nanoIn[unit] / nanoInSecond) // mult by # of secs\n        : undefined,\n    ]\n  } else if (leftoverNano !== undefined) {\n    const wholeUnits = Math.trunc(leftoverNano / nanoIn[unit])\n    return [wholeUnits, leftoverNano - (wholeUnits * nanoIn[unit])]\n  } else {\n    return [undefined, undefined]\n  }\n}\n", "import { createOptionParser } from './refine'\n\nexport const OFFSET_DISPLAY_AUTO = 0\nexport const OFFSET_DISPLAY_NEVER = 1\nexport type OffsetDisplayInt = 0 | 1\n\nexport interface OffsetDisplayMap {\n  auto: 0\n  never: 1\n}\nexport const offsetDisplayMap: OffsetDisplayMap = {\n  auto: 0,\n  never: 1,\n}\n\nexport const parseOffsetDisplayOption = createOptionParser(\n  'offset',\n  offsetDisplayMap,\n  OFFSET_DISPLAY_AUTO,\n)\n", "import { Temporal } from 'temporal-spec'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { parseTimeToStringOptions } from '../argParse/isoFormatOptions'\nimport { OVERFLOW_REJECT, parseOverflowOption } from '../argParse/overflowHandling'\nimport { parseRoundingOptions } from '../argParse/roundingOptions'\nimport { timeUnitNames } from '../argParse/unitStr'\nimport { AbstractISOObj, ensureObj } from '../dateUtils/abstract'\nimport { compareTimes } from '../dateUtils/compare'\nimport { constrainTimeISO } from '../dateUtils/constrain'\nimport { isoTimeToNano } from '../dateUtils/dayAndTime'\nimport { diffTimes } from '../dateUtils/diff'\nimport { DurationFields, negateDuration } from '../dateUtils/durationFields'\nimport { processTimeFromFields, processTimeWithFields } from '../dateUtils/fromAndWith'\nimport { ISOTimeFields } from '../dateUtils/isoFields'\nimport { formatTimeISO } from '../dateUtils/isoFormat'\nimport { LocalTimeFields } from '../dateUtils/localFields'\nimport { attachStringTag, mixinISOFields } from '../dateUtils/mixins'\nimport { parseTime } from '../dateUtils/parse'\nimport { roundTime } from '../dateUtils/rounding'\nimport { translateTime } from '../dateUtils/translate'\nimport { HOUR, NANOSECOND, TimeUnitInt, nanoInMilli } from '../dateUtils/units'\nimport { FormatFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { OrigDateTimeFormat } from '../native/intlUtils'\nimport { createDefaultCalendar } from './calendar'\nimport { Duration, createDuration } from './duration'\nimport { PlainDate, PlainDateArg } from './plainDate'\nimport { TimeZone } from './timeZone'\nimport { createZonedDateTimeFromFields } from './zonedDateTime'\n\nexport type PlainTimeArg = Temporal.PlainTime | Temporal.PlainTimeLike | string\n\ntype DiffOptions = Temporal.DifferenceOptions<\n'hour' | 'minute' | 'second' |\n'millisecond' | 'microsecond' | 'nanosecond'\n>\n\ntype RoundOptions = Temporal.RoundTo<\n'hour' | 'minute' | 'second' |\n'millisecond' | 'microsecond' | 'nanosecond'\n>\n\ntype ToZonedDateTimeOptions = {\n  timeZone: Temporal.TimeZoneLike\n  plainDate: Temporal.PlainDate | Temporal.PlainDateLike | string\n}\n\nexport class PlainTime extends AbstractISOObj<Temporal.PlainTimeISOFields>\n  implements Temporal.PlainTime {\n  constructor(\n    isoHour = 0,\n    isoMinute = 0,\n    isoSecond = 0,\n    isoMillisecond = 0,\n    isoMicrosecond = 0,\n    isoNanosecond = 0,\n  ) {\n    super(\n      {\n        ...constrainTimeISO({\n          isoHour,\n          isoMinute,\n          isoSecond,\n          isoMillisecond,\n          isoMicrosecond,\n          isoNanosecond,\n        }, OVERFLOW_REJECT),\n        calendar: createDefaultCalendar(),\n      },\n    )\n  }\n\n  static from(arg: PlainTimeArg, options?: Temporal.AssignmentOptions): Temporal.PlainTime {\n    const overflowHandling = parseOverflowOption(options)\n\n    return createTime(\n      arg instanceof PlainTime\n        ? arg.getISOFields() // optimization\n        : typeof arg === 'object'\n          ? processTimeFromFields(arg, overflowHandling)\n          : parseTime(String(arg)),\n    )\n  }\n\n  static compare(a: PlainTimeArg, b: PlainTimeArg): Temporal.ComparisonResult {\n    return compareTimes(ensureObj(PlainTime, a), ensureObj(PlainTime, b))\n  }\n\n  with(fields: Temporal.PlainTimeLike, options?: Temporal.AssignmentOptions): Temporal.PlainTime {\n    return createTime(\n      processTimeWithFields(this, fields, parseOverflowOption(options)),\n    )\n  }\n\n  add(durationArg: Temporal.Duration | Temporal.DurationLike | string): Temporal.PlainTime {\n    return translatePlainTime(this, ensureObj(Duration, durationArg))\n  }\n\n  subtract(durationArg: Temporal.Duration | Temporal.DurationLike | string): Temporal.PlainTime {\n    return translatePlainTime(this, negateDuration(ensureObj(Duration, durationArg)))\n  }\n\n  until(other: PlainTimeArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainTimes(this, ensureObj(PlainTime, other), options)\n  }\n\n  since(other: PlainTimeArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainTimes(ensureObj(PlainTime, other), this, options)\n  }\n\n  round(options: RoundOptions): Temporal.PlainTime {\n    const roundingConfig = parseRoundingOptions<Temporal.TimeUnit, TimeUnitInt>(\n      options,\n      NANOSECOND, // minUnit\n      HOUR, // maxUnit\n    )\n\n    return createTime(roundTime(this.getISOFields(), roundingConfig))\n  }\n\n  equals(other: Temporal.PlainTime | Temporal.PlainTimeLike | string): boolean {\n    return !compareTimes(this, ensureObj(PlainTime, other))\n  }\n\n  toString(options?: Temporal.ToStringPrecisionOptions): string {\n    const formatConfig = parseTimeToStringOptions(options)\n    const roundedISOFields: ISOTimeFields = roundTime(this.getISOFields(), formatConfig)\n    return formatTimeISO(roundedISOFields, formatConfig)\n  }\n\n  toZonedDateTime(options: ToZonedDateTimeOptions): Temporal.ZonedDateTime {\n    // TODO: ensure options object first?\n    const plainDate = ensureObj(PlainDate, options.plainDate)\n    const timeZone = ensureObj(TimeZone, options.timeZone)\n\n    return createZonedDateTimeFromFields({\n      ...plainDate.getISOFields(),\n      ...this.getISOFields(),\n      timeZone,\n    })\n  }\n\n  toPlainDateTime(dateArg: PlainDateArg): Temporal.PlainDateTime {\n    return ensureObj(PlainDate, dateArg).toPlainDateTime(this)\n  }\n}\n\n// mixin\nexport interface PlainTime { [Symbol.toStringTag]: 'Temporal.PlainTime' }\nexport interface PlainTime extends LocalTimeFields { calendar: Temporal.Calendar }\nexport interface PlainTime extends ToLocaleStringMethods {}\nattachStringTag(PlainTime, 'PlainTime')\nmixinISOFields(PlainTime, timeUnitNames)\nmixinLocaleStringMethods(PlainTime, createPlainTimeFormatFactory)\n\nfunction createPlainTimeFormatFactory(\n  locales: string[],\n  options: Intl.DateTimeFormatOptions,\n): FormatFactory<PlainTime> {\n  return {\n    buildKey: () => ['', ''],\n    buildFormat: () => new OrigDateTimeFormat(locales, {\n      hour: 'numeric',\n      minute: '2-digit',\n      second: '2-digit',\n      ...options,\n      timeZone: 'UTC', // options can't override\n      timeZoneName: undefined,\n      year: undefined,\n      month: undefined,\n      day: undefined,\n      weekday: undefined,\n    }),\n    buildEpochMilli: (plainTime: PlainTime) => (\n      Math.trunc(isoTimeToNano(plainTime.getISOFields()) / nanoInMilli)\n    ),\n  }\n}\n\nexport function createTime(isoFields: ISOTimeFields): PlainTime {\n  return new PlainTime(\n    isoFields.isoHour,\n    isoFields.isoMinute,\n    isoFields.isoSecond,\n    isoFields.isoMillisecond,\n    isoFields.isoMicrosecond,\n    isoFields.isoNanosecond,\n  )\n}\n\n// Normally ensureObj and ::from would fail when undefined is specified\n// Fallback to 00:00 time\nexport function ensureLooseTime(arg: PlainTimeArg | undefined): PlainTime {\n  return ensureObj(PlainTime, arg ?? { hour: 0 })\n}\n\nfunction translatePlainTime(pt: PlainTime, dur: DurationFields): PlainTime {\n  return createTime(translateTime(pt.getISOFields(), dur))\n}\n\nfunction diffPlainTimes(\n  pt0: PlainTime,\n  pt1: PlainTime,\n  options: DiffOptions | undefined,\n): Duration {\n  const diffConfig = parseDiffOptions<Temporal.TimeUnit, TimeUnitInt>(\n    options,\n    HOUR, // largestUnitDefault\n    NANOSECOND, // smallestUnitDefault\n    NANOSECOND, // minUnit\n    HOUR, // maxUnit\n  )\n\n  return createDuration(\n    // TODO: use local-time-fields as-is somehow???\n    diffTimes(pt0.getISOFields(), pt1.getISOFields(), diffConfig),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { DiffConfig } from '../argParse/diffOptions'\nimport { OVERFLOW_CONSTRAIN } from '../argParse/overflowHandling'\nimport { unitNames } from '../argParse/unitStr'\nimport { CalendarImpl } from '../calendarImpl/calendarImpl'\nimport { createDate } from '../public/plainDate'\nimport { LargeInt, createLargeInt } from '../utils/largeInt'\nimport { compareValues, roundToIncrement, roundToIncrementBI } from '../utils/math'\nimport { compareLocalDateFields } from './compare'\nimport { constrainDateFields } from './constrain'\nimport { isoTimeToNano, nanoToDuration } from './dayAndTime'\nimport { DurationFields, mergeDurations, signDuration } from './durationFields'\nimport { EpochableObj, diffDaysMilli, toEpochNano } from './epoch'\nimport { ISOTimeFields } from './isoFields'\nimport { LocalDateFields } from './localFields'\nimport { roundDurationSpan } from './roundingDuration'\nimport { addMonths, addYears } from './translate'\nimport {\n  HOUR,\n  MONTH,\n  TimeUnitInt,\n  UnitInt,\n  WEEK,\n  YEAR,\n  isDateUnit,\n  nanoIn,\n} from './units'\n\nexport type DiffableObj = LocalDateFields & EpochableObj & {\n  add(durationFields: Partial<DurationFields>): DiffableObj\n}\n\n// used for zoned date times as well\nexport function diffDateTimes(\n  dt0: DiffableObj,\n  dt1: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n  flip: boolean,\n  diffConfig: DiffConfig,\n): DurationFields {\n  return roundDurationSpan(\n    diffAccurate(dt0, dt1, calendar, diffConfig.largestUnit),\n    dt0,\n    dt1,\n    calendar,\n    flip,\n    diffConfig,\n  )\n}\n\nexport function diffDates(\n  d0: DiffableObj,\n  d1: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n  flip: boolean,\n  diffConfig: DiffConfig,\n): DurationFields {\n  const balancedDuration = calendar.dateUntil(d0, d1, {\n    largestUnit: unitNames[diffConfig.largestUnit] as Temporal.DateUnit,\n  })\n  return roundDurationSpan(balancedDuration, d0, d1, calendar, flip, diffConfig)\n}\n\nexport function diffTimes(\n  t0: ISOTimeFields,\n  t1: ISOTimeFields,\n  diffConfig: DiffConfig<TimeUnitInt>,\n): DurationFields {\n  const roundedDiff = roundToIncrement(\n    isoTimeToNano(t1) - isoTimeToNano(t0),\n    nanoIn[diffConfig.smallestUnit] * diffConfig.roundingIncrement,\n    diffConfig.roundingFunc,\n  )\n  return nanoToDuration(createLargeInt(roundedDiff), diffConfig.largestUnit)\n}\n\nexport function diffEpochNanos(\n  epochNano0: LargeInt,\n  epochNano1: LargeInt,\n  diffConfig: DiffConfig<TimeUnitInt>,\n): DurationFields {\n  const roundedDiff = roundToIncrementBI(\n    epochNano1.sub(epochNano0),\n    nanoIn[diffConfig.smallestUnit] * diffConfig.roundingIncrement,\n    diffConfig.roundingFunc,\n  )\n  return nanoToDuration(roundedDiff, diffConfig.largestUnit)\n}\n\n// Utils\n// -------------------------------------------------------------------------------------------------\n\nexport function diffDateFields(\n  d0: LocalDateFields,\n  d1: LocalDateFields,\n  calendarImpl: CalendarImpl,\n  largestUnit: UnitInt,\n): DurationFields {\n  let years = 0; let months = 0; let weeks = 0; let days = 0\n\n  switch (largestUnit) {\n    case YEAR:\n      years = wholeYearsUntil(d0, d1, calendarImpl)\n      d0 = addYears(d0, years, calendarImpl, OVERFLOW_CONSTRAIN)\n      // fallthrough\n    case MONTH:\n      months = wholeMonthsUntil(d0, d1, calendarImpl)\n      d0 = addMonths(d0, months, calendarImpl, OVERFLOW_CONSTRAIN)\n  }\n\n  days = diffDaysMilli(\n    calendarImpl.epochMilliseconds(d0.year, d0.month, d0.day),\n    calendarImpl.epochMilliseconds(d1.year, d1.month, d1.day),\n  )\n\n  if (largestUnit === WEEK) {\n    weeks = Math.trunc(days / 7)\n    days %= 7\n  }\n\n  return signDuration({\n    years,\n    months,\n    weeks,\n    days,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    milliseconds: 0,\n    microseconds: 0,\n    nanoseconds: 0,\n  })\n}\n\nfunction wholeYearsUntil(\n  d0: LocalDateFields,\n  d1: LocalDateFields,\n  calendarImpl: CalendarImpl,\n): number {\n  // simulate destination year\n  const [, newMonth, newDay] = constrainDateFields(\n    d1.year,\n    d0.month,\n    d0.day,\n    calendarImpl,\n    OVERFLOW_CONSTRAIN,\n  )\n\n  const generalSign = compareLocalDateFields(d1, d0)\n  const monthSign = compareValues(d1.month, newMonth) || compareValues(d1.day, newDay)\n\n  return d1.year - d0.year - (\n    (monthSign && generalSign && monthSign !== generalSign)\n      ? generalSign\n      : 0\n  )\n}\n\nfunction wholeMonthsUntil(\n  d0: LocalDateFields,\n  d1: LocalDateFields,\n  calendarImpl: CalendarImpl,\n): number {\n  let monthsToAdd = 0\n  const generalSign = compareLocalDateFields(d1, d0)\n\n  if (generalSign) {\n    // move ahead by whole years\n    let { year } = d0\n    while (year !== d1.year) {\n      monthsToAdd += calendarImpl.monthsInYear(year) * generalSign\n      year += generalSign\n    }\n\n    // simulate destination year (same as wholeYearsUntil... optimization opportunity?)\n    const [, newMonth, newDay] = constrainDateFields(\n      d1.year,\n      d0.month,\n      d0.day,\n      calendarImpl,\n      OVERFLOW_CONSTRAIN,\n    )\n\n    // add remaining months (or subtract overshot months)\n    monthsToAdd += d1.month - newMonth\n\n    // correct when we overshoot the day-of-month\n    const daySign = compareValues(d1.day, newDay)\n    if (daySign && generalSign && daySign !== generalSign) {\n      monthsToAdd -= generalSign\n    }\n  }\n\n  return monthsToAdd\n}\n\nexport function diffAccurate(\n  dt0: DiffableObj,\n  dt1: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n  largestUnit: UnitInt,\n): DurationFields {\n  // a time unit\n  if (!isDateUnit(largestUnit)) {\n    return diffTimeScale(dt0, dt1, largestUnit)\n  }\n\n  const dateStart = createDate({ ...dt0.getISOFields(), calendar })\n  let dateMiddle = createDate({ ...dt1.getISOFields(), calendar })\n  let dateTimeMiddle: DiffableObj\n  let bigDuration: DurationFields\n  let timeDuration: DurationFields\n  let bigSign: Temporal.ComparisonResult\n  let timeSign: Temporal.ComparisonResult\n\n  do {\n    bigDuration = calendar.dateUntil(\n      dateStart,\n      dateMiddle,\n      { largestUnit: unitNames[largestUnit] as Temporal.DateUnit },\n    )\n    dateTimeMiddle = dt0.add(bigDuration)\n    timeDuration = diffTimeScale(dateTimeMiddle, dt1, HOUR)\n    bigSign = bigDuration.sign\n    timeSign = timeDuration.sign\n  } while (\n    // did we overshoot? keep backing up a day\n    bigSign && timeSign &&\n    bigSign !== timeSign &&\n    (dateMiddle = dateMiddle.add({ days: timeSign })) // move dateMiddle closer to dt0\n  )\n\n  return mergeDurations(bigDuration, timeDuration)\n}\n\nfunction diffTimeScale(\n  dt0: EpochableObj,\n  dt1: EpochableObj,\n  largestUnit: TimeUnitInt,\n): DurationFields {\n  return nanoToDuration(toEpochNano(dt1).sub(toEpochNano(dt0)), largestUnit)\n}\n", "import { Temporal } from 'temporal-spec'\nimport { getCommonCalendar } from '../argParse/calendar'\nimport { parseCalendarDisplayOption } from '../argParse/calendarDisplay'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { OVERFLOW_REJECT, parseOverflowOption } from '../argParse/overflowHandling'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { AbstractISOObj, ensureObj } from '../dateUtils/abstract'\nimport { compareDateTimes } from '../dateUtils/compare'\nimport { constrainDateISO } from '../dateUtils/constrain'\nimport { diffDates } from '../dateUtils/diff'\nimport { DurationFields, negateDuration } from '../dateUtils/durationFields'\nimport { processYearMonthFromFields, processYearMonthWithFields } from '../dateUtils/fromAndWith'\nimport { validateYearMonth } from '../dateUtils/isoFieldValidation'\nimport { formatCalendarID, formatDateISO, formatYearMonthISO } from '../dateUtils/isoFormat'\nimport {\n  YearMonthCalendarFields,\n  attachStringTag,\n  mixinCalendarFields,\n  mixinISOFields,\n  yearMonthCalendarFields,\n} from '../dateUtils/mixins'\nimport { parseYearMonth } from '../dateUtils/parse'\nimport { refineBaseObj } from '../dateUtils/parseRefine'\nimport { MONTH, YEAR, YearMonthUnitInt } from '../dateUtils/units'\nimport { createPlainFormatFactoryFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { Calendar, createDefaultCalendar } from './calendar'\nimport { Duration, DurationArg, createDuration } from './duration'\n\nexport type PlainYearMonthArg = Temporal.PlainYearMonth | Temporal.PlainYearMonthLike | string\n\ntype YearMonthUnit = 'year' | 'month'\ntype DiffOptions = Temporal.DifferenceOptions<YearMonthUnit>\n\nconst day1 = { day: 1 }\n\nexport class PlainYearMonth extends AbstractISOObj<Temporal.PlainDateISOFields>\n  implements Temporal.PlainYearMonth {\n  constructor(\n    isoYear: number,\n    isoMonth: number,\n    calendarArg: Temporal.CalendarLike = createDefaultCalendar(),\n    referenceISODay = 1,\n  ) {\n    const constrained = constrainDateISO({\n      isoYear,\n      isoMonth,\n      isoDay: referenceISODay,\n    }, OVERFLOW_REJECT)\n    const calendar = ensureObj(Calendar, calendarArg)\n\n    validateYearMonth(constrained, calendar.toString())\n\n    super({\n      ...constrained,\n      calendar,\n    })\n  }\n\n  static from(\n    arg: PlainYearMonthArg,\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainYearMonth {\n    parseOverflowOption(options) // unused, but need to validate, regardless of input type\n\n    if (arg instanceof PlainYearMonth) {\n      return createYearMonth(arg.getISOFields()) // optimization\n    }\n\n    if (typeof arg === 'object') {\n      return processYearMonthFromFields(arg, options)\n    }\n\n    // a string...\n    const parsed = parseYearMonth(String(arg))\n\n    // don't allow day-numbers in ISO strings\n    if (parsed.calendar === undefined) {\n      parsed.isoDay = 1\n    }\n\n    return createYearMonth(refineBaseObj(parsed))\n  }\n\n  static compare(a: PlainYearMonthArg, b: PlainYearMonthArg): Temporal.ComparisonResult {\n    return compareDateTimes(\n      ensureObj(PlainYearMonth, a),\n      ensureObj(PlainYearMonth, b),\n    )\n  }\n\n  with(\n    fields: Temporal.PlainYearMonthLike,\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainYearMonth {\n    return processYearMonthWithFields(this, fields, options)\n  }\n\n  add(\n    durationArg: DurationArg,\n    options?: Temporal.ArithmeticOptions,\n  ): Temporal.PlainYearMonth {\n    return translatePlainYearMonth(this, ensureObj(Duration, durationArg), options)\n  }\n\n  subtract(\n    durationArg: DurationArg,\n    options?: Temporal.ArithmeticOptions,\n  ): Temporal.PlainYearMonth {\n    return translatePlainYearMonth(this, negateDuration(ensureObj(Duration, durationArg)), options)\n  }\n\n  until(other: PlainYearMonthArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainYearMonths(this, ensureObj(PlainYearMonth, other), false, options)\n  }\n\n  since(other: PlainYearMonthArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainYearMonths(this, ensureObj(PlainYearMonth, other), true, options)\n  }\n\n  equals(other: PlainYearMonthArg): boolean {\n    return !compareDateTimes(this, ensureObj(PlainYearMonth, other))\n  }\n\n  toString(options?: Temporal.ShowCalendarOption): string {\n    const fields = this.getISOFields()\n    const calendarID = fields.calendar.toString() // see note in formatCalendarID\n    const calendarDisplay = parseCalendarDisplayOption(options)\n\n    return (\n      calendarID === isoCalendarID\n        ? formatYearMonthISO(fields)\n        : formatDateISO(fields)\n    ) + formatCalendarID(calendarID, calendarDisplay)\n  }\n\n  toPlainDate(fields: { day: number }): Temporal.PlainDate {\n    return this.calendar.dateFromFields({\n      year: this.year,\n      month: this.month,\n      day: fields.day,\n    })\n  }\n}\n\n// mixin\nexport interface PlainYearMonth { [Symbol.toStringTag]: 'Temporal.PlainYearMonth' }\nexport interface PlainYearMonth extends YearMonthCalendarFields {\n  calendar: Temporal.CalendarProtocol\n}\nexport interface PlainYearMonth extends ToLocaleStringMethods {}\nattachStringTag(PlainYearMonth, 'PlainYearMonth')\nmixinISOFields(PlainYearMonth)\nmixinCalendarFields(PlainYearMonth, yearMonthCalendarFields)\nmixinLocaleStringMethods(PlainYearMonth, createPlainFormatFactoryFactory({\n  year: 'numeric',\n  month: 'numeric',\n}, {\n  weekday: undefined,\n  day: undefined,\n  hour: undefined,\n  minute: undefined,\n  second: undefined,\n}, true)) // strictCalendar\n\nexport function createYearMonth(isoFields: Temporal.PlainDateISOFields): PlainYearMonth {\n  return new PlainYearMonth(\n    isoFields.isoYear,\n    isoFields.isoMonth,\n    isoFields.calendar,\n    isoFields.isoDay,\n  )\n}\n\nfunction translatePlainYearMonth(\n  yearMonth: PlainYearMonth,\n  duration: DurationFields,\n  options?: Temporal.ArithmeticOptions,\n): PlainYearMonth {\n  return yearMonth.toPlainDate({\n    day: duration.sign < 0\n      ? yearMonth.daysInMonth\n      : 1,\n  })\n    .add(duration, options)\n    .toPlainYearMonth()\n}\n\nfunction diffPlainYearMonths(\n  pym0: PlainYearMonth,\n  pym1: PlainYearMonth,\n  flip: boolean,\n  options: DiffOptions | undefined,\n): Duration {\n  return createDuration(\n    diffDates(\n      pym0.toPlainDate(day1),\n      pym1.toPlainDate(day1),\n      getCommonCalendar(pym0, pym1),\n      flip,\n      parseDiffOptions<YearMonthUnit, YearMonthUnitInt>(options, YEAR, MONTH, MONTH, YEAR),\n    ),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { getCommonCalendar, getStrangerCalendar } from '../argParse/calendar'\nimport { parseCalendarDisplayOption } from '../argParse/calendarDisplay'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { parseDisambigOption } from '../argParse/disambig'\nimport { parseTimeToStringOptions } from '../argParse/isoFormatOptions'\nimport { OFFSET_DISPLAY_AUTO, parseOffsetDisplayOption } from '../argParse/offsetDisplay'\nimport {\n  OFFSET_PREFER,\n  OFFSET_REJECT,\n  OffsetHandlingInt,\n  parseOffsetHandlingOption,\n} from '../argParse/offsetHandling'\nimport { parseOverflowOption } from '../argParse/overflowHandling'\nimport { RoundingConfig, parseRoundingOptions } from '../argParse/roundingOptions'\nimport { parseTimeZoneDisplayOption } from '../argParse/timeZoneDisplay'\nimport { timeUnitNames } from '../argParse/unitStr'\nimport { AbstractISOObj, ensureObj } from '../dateUtils/abstract'\nimport { compareEpochObjs, zonedDateTimesEqual } from '../dateUtils/compare'\nimport { DayTimeUnit, zeroISOTimeFields } from '../dateUtils/dayAndTime'\nimport { diffDateTimes } from '../dateUtils/diff'\nimport { DurationFields, negateDuration } from '../dateUtils/durationFields'\nimport { epochNanoSymbol, epochNanoToISOFields } from '../dateUtils/epoch'\nimport {\n  processZonedDateTimeFromFields,\n  processZonedDateTimeWithFields,\n} from '../dateUtils/fromAndWith'\nimport { validateDateTime } from '../dateUtils/isoFieldValidation'\nimport { ISODateTimeFields } from '../dateUtils/isoFields'\nimport {\n  formatCalendarID,\n  formatDateTimeISO,\n  formatOffsetISO,\n  formatTimeZoneID,\n} from '../dateUtils/isoFormat'\nimport { LocalTimeFields } from '../dateUtils/localFields'\nimport {\n  ComputedEpochFields,\n  DateCalendarFields,\n  attachStringTag,\n  dateCalendarFields,\n  mixinCalendarFields,\n  mixinEpochFields,\n  mixinISOFields,\n} from '../dateUtils/mixins'\nimport {\n  OffsetComputableFields,\n  computeNanoInDay,\n  computeZonedDateTimeEpochNano,\n} from '../dateUtils/offset'\nimport { parseZonedDateTime } from '../dateUtils/parse'\nimport { refineZonedObj } from '../dateUtils/parseRefine'\nimport { roundZonedDateTimeFields } from '../dateUtils/rounding'\nimport { getInstantFor } from '../dateUtils/timeZone'\nimport { translateZonedDateTimeFields } from '../dateUtils/translate'\nimport {\n  DAY,\n  DayTimeUnitInt,\n  HOUR,\n  NANOSECOND,\n  UnitInt,\n  YEAR,\n  nanoInHour,\n} from '../dateUtils/units'\nimport { createZonedFormatFactoryFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { LargeInt, LargeIntArg, createLargeInt } from '../utils/largeInt'\nimport { roundToMinute } from '../utils/math'\nimport { Calendar, createDefaultCalendar } from './calendar'\nimport { Duration, DurationArg, createDuration } from './duration'\nimport { Instant } from './instant'\nimport { PlainDate, PlainDateArg, createDate } from './plainDate'\nimport { createDateTime } from './plainDateTime'\nimport { PlainTime, PlainTimeArg, createTime } from './plainTime'\nimport { createYearMonth } from './plainYearMonth'\nimport { TimeZone } from './timeZone'\n\nexport type ZonedDateTimeArg = Temporal.ZonedDateTime | Temporal.ZonedDateTimeLike | string\n\ntype DiffOptions = Temporal.DifferenceOptions<\n'year' | 'month' | 'week' | 'day' |\n'hour' | 'minute' | 'second' | 'millisecond' | 'microsecond' | 'nanosecond'\n>\n\ntype RoundOptions = Temporal.RoundTo<\n'day' | 'hour' | 'minute' | 'second' |\n'millisecond' | 'microsecond' | 'nanosecond'\n>\n\nconst offsetNanoSymbol = Symbol()\n\nexport interface ZonedDateTime {\n  [offsetNanoSymbol]: number\n  [epochNanoSymbol]: LargeInt\n}\nexport class ZonedDateTime extends AbstractISOObj<Temporal.ZonedDateTimeISOFields>\n  implements Temporal.ZonedDateTime {\n  constructor(\n    epochNanoseconds: LargeIntArg,\n    timeZoneArg: Temporal.TimeZoneLike,\n    calendarArg: Temporal.CalendarLike = createDefaultCalendar(),\n  ) {\n    // TODO: throw error when number?\n    const timeZone = ensureObj(TimeZone, timeZoneArg)\n    const calendar = ensureObj(Calendar, calendarArg)\n\n    const epochNano = createLargeInt(epochNanoseconds) // TODO: do strict, like Instant?\n    const [isoFields, offsetNano] = buildZonedDateTimeISOFields(epochNano, timeZone)\n    validateDateTime(isoFields, calendar.toString())\n\n    super({\n      ...isoFields,\n      calendar,\n      timeZone,\n      // NOTE: must support TimeZone protocols that don't implement getOffsetStringFor\n      // TODO: more DRY with getOffsetStringFor\n      offset: formatOffsetISO(offsetNano),\n    })\n\n    this[epochNanoSymbol] = epochNano\n    this[offsetNanoSymbol] = offsetNano\n  }\n\n  // okay to have return-type be ZonedDateTime? needed\n  static from(arg: ZonedDateTimeArg, options?: Temporal.AssignmentOptions): ZonedDateTime {\n    const offsetHandling = parseOffsetHandlingOption(options, OFFSET_REJECT)\n    const overflowHandling = parseOverflowOption(options)\n\n    if (arg instanceof ZonedDateTime) {\n      return new ZonedDateTime(arg.epochNanoseconds, arg.timeZone, arg.calendar)\n    }\n\n    const isObject = typeof arg === 'object'\n    const fields = isObject\n      ? processZonedDateTimeFromFields(arg, overflowHandling, options)\n      : refineZonedObj(parseZonedDateTime(String(arg)))\n\n    return createZonedDateTimeFromFields(\n      fields,\n      !isObject, // fuzzyMatching (if string)\n      offsetHandling,\n      options,\n    )\n  }\n\n  static compare(a: ZonedDateTimeArg, b: ZonedDateTimeArg): Temporal.ComparisonResult {\n    return compareEpochObjs(\n      ensureObj(ZonedDateTime, a),\n      ensureObj(ZonedDateTime, b),\n    )\n  }\n\n  get timeZone(): Temporal.TimeZoneProtocol { return this.getISOFields().timeZone }\n  get offsetNanoseconds(): number { return this[offsetNanoSymbol] }\n  get offset(): string { return this.getISOFields().offset }\n\n  with(\n    fields: Temporal.ZonedDateTimeLike,\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.ZonedDateTime {\n    parseDisambigOption(options) // for validation\n    const overflowHandling = parseOverflowOption(options) // for validation (?)\n    const offsetHandling = parseOffsetHandlingOption(options, OFFSET_PREFER)\n    const refined = processZonedDateTimeWithFields(this, fields, overflowHandling, options)\n\n    return createZonedDateTimeFromFields(refined, false, offsetHandling, options)\n  }\n\n  withPlainDate(dateArg: PlainDateArg): Temporal.ZonedDateTime {\n    const date = ensureObj(PlainDate, dateArg)\n    const dateTime = date.toPlainDateTime(this) // timeArg=this\n    const { timeZone } = this\n    const instant = getInstantFor(timeZone, dateTime)\n\n    return new ZonedDateTime(\n      instant.epochNanoseconds,\n      timeZone,\n      getStrangerCalendar(this, date),\n    )\n  }\n\n  withPlainTime(timeArg?: PlainTimeArg): Temporal.ZonedDateTime {\n    return createZonedDateTimeFromFields({\n      ...this.getISOFields(),\n      ...(\n        timeArg === undefined\n          ? zeroISOTimeFields\n          : ensureObj(PlainTime, timeArg).getISOFields()\n      ),\n    })\n  }\n\n  withCalendar(calendarArg: Temporal.CalendarLike): Temporal.ZonedDateTime {\n    return new ZonedDateTime(\n      this.epochNanoseconds,\n      this.timeZone,\n      calendarArg,\n    )\n  }\n\n  withTimeZone(timeZoneArg: Temporal.TimeZoneLike): Temporal.ZonedDateTime {\n    return new ZonedDateTime(\n      this.epochNanoseconds,\n      timeZoneArg,\n      this.calendar,\n    )\n  }\n\n  add(durationArg: DurationArg, options?: Temporal.ArithmeticOptions): Temporal.ZonedDateTime {\n    return translateZonedDateTime(this, ensureObj(Duration, durationArg), options)\n  }\n\n  subtract(durationArg: DurationArg, options?: Temporal.ArithmeticOptions): Temporal.ZonedDateTime {\n    return translateZonedDateTime(this, negateDuration(ensureObj(Duration, durationArg)), options)\n  }\n\n  until(other: ZonedDateTimeArg, options?: DiffOptions): Temporal.Duration {\n    return diffZonedDateTimes(this, ensureObj(ZonedDateTime, other), false, options)\n  }\n\n  since(other: ZonedDateTimeArg, options?: DiffOptions): Temporal.Duration {\n    return diffZonedDateTimes(this, ensureObj(ZonedDateTime, other), true, options)\n  }\n\n  round(options: RoundOptions): Temporal.ZonedDateTime {\n    const roundingConfig = parseRoundingOptions<DayTimeUnit, DayTimeUnitInt>(\n      options,\n      NANOSECOND, // minUnit\n      DAY, // maxUnit\n    )\n\n    return roundZonedDateTime(this, roundingConfig)\n  }\n\n  equals(other: ZonedDateTimeArg): boolean {\n    return zonedDateTimesEqual(this, ensureObj(ZonedDateTime, other))\n  }\n\n  startOfDay(): Temporal.ZonedDateTime {\n    return createZonedDateTimeFromFields({\n      ...this.getISOFields(),\n      ...zeroISOTimeFields,\n      offsetNanoseconds: this.offsetNanoseconds,\n    }, false, OFFSET_PREFER)\n  }\n\n  // TODO: turn into a lazy-getter, like what mixinCalendarFields does\n  get hoursInDay(): number {\n    return computeNanoInDay(this.getISOFields()) / nanoInHour\n  }\n\n  toString(options?: Temporal.CalendarTypeToStringOptions): string {\n    const formatConfig = parseTimeToStringOptions(options)\n    const offsetDisplay = parseOffsetDisplayOption(options)\n    const timeZoneDisplay = parseTimeZoneDisplayOption(options)\n    const calendarDisplay = parseCalendarDisplayOption(options)\n    const roundedZdt = roundZonedDateTime(this, formatConfig)\n\n    return formatDateTimeISO(roundedZdt.getISOFields(), formatConfig) +\n      (offsetDisplay === OFFSET_DISPLAY_AUTO\n        ? formatOffsetISO(roundToMinute(roundedZdt.offsetNanoseconds))\n        : ''\n      ) +\n      formatTimeZoneID(this.timeZone.toString(), timeZoneDisplay) +\n      formatCalendarID(this.calendar.toString(), calendarDisplay)\n  }\n\n  toPlainYearMonth(): Temporal.PlainYearMonth { return createYearMonth(this.getISOFields()) }\n  toPlainMonthDay(): Temporal.PlainMonthDay { return this.calendar.monthDayFromFields(this) }\n  toPlainDateTime(): Temporal.PlainDateTime { return createDateTime(this.getISOFields()) }\n  toPlainDate(): Temporal.PlainDate { return createDate(this.getISOFields()) }\n  toPlainTime(): Temporal.PlainTime { return createTime(this.getISOFields()) }\n  toInstant(): Temporal.Instant { return new Instant(this.epochNanoseconds) }\n}\n\n// mixins\nexport interface ZonedDateTime { [Symbol.toStringTag]: 'Temporal.ZonedDateTime' }\nexport interface ZonedDateTime extends DateCalendarFields { calendar: Temporal.CalendarProtocol }\nexport interface ZonedDateTime extends LocalTimeFields {}\nexport interface ZonedDateTime extends ComputedEpochFields {}\nexport interface ZonedDateTime extends ToLocaleStringMethods {}\nattachStringTag(ZonedDateTime, 'ZonedDateTime')\nmixinISOFields(ZonedDateTime, timeUnitNames)\nmixinCalendarFields(ZonedDateTime, dateCalendarFields)\nmixinEpochFields(ZonedDateTime)\nmixinLocaleStringMethods(ZonedDateTime, createZonedFormatFactoryFactory({\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  weekday: undefined,\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit',\n}, {\n  timeZoneName: 'short',\n}, {}))\n\nexport function createZonedDateTimeFromFields(\n  fields: OffsetComputableFields,\n  fuzzyMatching?: boolean,\n  offsetHandling?: OffsetHandlingInt,\n  disambigOptions?: Temporal.AssignmentOptions,\n): ZonedDateTime {\n  const epochNano = computeZonedDateTimeEpochNano(\n    fields,\n    fuzzyMatching,\n    offsetHandling,\n    disambigOptions,\n  )\n  return new ZonedDateTime(epochNano, fields.timeZone, fields.calendar)\n}\n\nexport function buildZonedDateTimeISOFields(\n  epochNano: LargeInt,\n  timeZone: Temporal.TimeZoneProtocol,\n): [ISODateTimeFields, number] {\n  const instant = new Instant(epochNano) // will do validation\n  const offsetNano = timeZone.getOffsetNanosecondsFor(instant)\n  const isoFields = epochNanoToISOFields(epochNano.add(offsetNano))\n  return [isoFields, offsetNano]\n}\n\nfunction translateZonedDateTime(\n  zdt: ZonedDateTime,\n  dur: DurationFields,\n  options: Temporal.ArithmeticOptions | undefined,\n): ZonedDateTime {\n  const isoFields = zdt.getISOFields()\n  const epochNano = translateZonedDateTimeFields(isoFields, dur, options)\n  return new ZonedDateTime(epochNano, isoFields.timeZone, isoFields.calendar)\n}\n\nfunction roundZonedDateTime(\n  zdt: ZonedDateTime,\n  roundingConfig: RoundingConfig<DayTimeUnitInt>,\n): ZonedDateTime {\n  const isoFields = zdt.getISOFields()\n  const epochNano = roundZonedDateTimeFields(isoFields, zdt.offsetNanoseconds, roundingConfig)\n  return new ZonedDateTime(epochNano, isoFields.timeZone, isoFields.calendar)\n}\n\n// TODO: make common util with PlainDateTime, because leverages same diffDateTimes?\nfunction diffZonedDateTimes(\n  dt0: ZonedDateTime,\n  dt1: ZonedDateTime,\n  flip: boolean,\n  options: DiffOptions | undefined,\n): Duration {\n  const diffConfig = parseDiffOptions<Temporal.DateTimeUnit, UnitInt>(\n    options,\n    HOUR, // largestUnitDefault\n    NANOSECOND, // smallestUnitDefault\n    NANOSECOND, // minUnit\n    YEAR, // maxUnit\n  )\n  const { largestUnit } = diffConfig\n\n  if (largestUnit >= DAY && dt0.timeZone.id !== dt1.timeZone.id) {\n    throw new Error('Must be same timeZone')\n  }\n\n  return createDuration(\n    diffDateTimes(dt0, dt1, getCommonCalendar(dt0, dt1), flip, diffConfig),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { isObjectLike } from '../argParse/refine'\nimport { PlainDateTime, PlainDateTimeArg, createDateTime } from '../public/plainDateTime'\nimport {\n  ZonedDateTime,\n  ZonedDateTimeArg,\n  createZonedDateTimeFromFields,\n} from '../public/zonedDateTime'\nimport { ensureObj } from './abstract'\nimport { tryParseZonedDateTime } from './parse'\nimport { refineBaseObj, refineZonedObj } from './parseRefine'\n\nexport function extractRelativeTo(\n  arg: ZonedDateTimeArg | PlainDateTimeArg | undefined,\n): ZonedDateTime | PlainDateTime | undefined {\n  if (arg === undefined) {\n    return undefined\n  }\n\n  if (isObjectLike(arg)) {\n    if (arg instanceof ZonedDateTime || arg instanceof PlainDateTime) {\n      return arg\n    }\n    return ensureObj<ZonedDateTime | PlainDateTime, Temporal.ZonedDateTimeLike, []>(\n      (arg as Temporal.ZonedDateTimeLike).timeZone !== undefined\n        ? ZonedDateTime\n        : PlainDateTime,\n      arg as Temporal.ZonedDateTimeLike,\n    )\n  }\n\n  // assume a string...\n  // TODO: general toString util for ALL parsing that prevents parsing symbols\n  // https://github.com/ljharb/es-abstract/blob/main/2020/ToString.js\n  if (typeof arg === 'symbol') {\n    throw new TypeError('Incorrect relativeTo type')\n  }\n\n  const parsed = tryParseZonedDateTime(String(arg))\n  if (parsed) {\n    if (parsed.timeZone !== undefined) {\n      return createZonedDateTimeFromFields(refineZonedObj(parsed), true)\n    } else {\n      return createDateTime(refineBaseObj(parsed))\n    }\n  }\n\n  throw new RangeError('Invalid value of relativeTo')\n}\n", "import { Temporal } from 'temporal-spec'\nimport { unitNames } from '../argParse/unitStr'\nimport { PlainDate } from '../public/plainDate'\nimport { DiffableObj, diffAccurate } from './diff'\nimport { DurationFields, overrideDuration } from './durationFields'\nimport { DAY, DateUnitInt, UnitInt, WEEK } from './units'\n\nexport function spanDurationFrom(\n  duration: DurationFields,\n  largestUnit: UnitInt,\n  relativeTo: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n): DurationFields {\n  return (\n    relativeTo instanceof PlainDate\n      ? spanDurationFromDate(\n        duration,\n        Math.max(DAY, largestUnit) as DateUnitInt,\n        relativeTo,\n        calendar,\n      )\n      : spanDurationFromDateTime(duration, largestUnit, relativeTo, calendar)\n  )[0]\n}\n\n// does not need to worry about time fields at all! or dst!\n// only worries about date fields. can rely completely on calendar\nexport function spanDurationFromDate(\n  duration: DurationFields,\n  largestUnit: DateUnitInt,\n  relativeTo: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n): [DurationFields, DiffableObj] {\n  const translated = relativeTo.add(duration)\n  const newDuration = calendar.dateUntil(relativeTo, translated, {\n    largestUnit: unitNames[largestUnit] as Temporal.DateUnit,\n  })\n\n  return [newDuration, translated]\n}\n\nexport function spanDurationFromDateTime(\n  fields: DurationFields,\n  largestUnit: UnitInt,\n  relativeTo: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n  dissolveWeeks?: boolean,\n): [DurationFields, DiffableObj] {\n  // balancing does not care about weeks\n  // TODO: make this more readable. responsibility of caller?\n  const forcedWeeks = dissolveWeeks !== true && largestUnit > WEEK && fields.weeks\n  if (forcedWeeks) {\n    fields = overrideDuration(fields, { weeks: 0 })\n  }\n\n  let translated = relativeTo.add(fields)\n\n  // ***uses calendar.dateUntil under the hood\n  let balancedDuration = diffAccurate(relativeTo, translated, calendar, largestUnit)\n\n  // add weeks back in\n  if (forcedWeeks) {\n    balancedDuration = overrideDuration(balancedDuration, { weeks: forcedWeeks })\n    translated = translated.add({ weeks: forcedWeeks })\n  }\n\n  return [balancedDuration, translated]\n}\n", "import { Temporal } from 'temporal-spec'\nimport { durationUnitNames } from '../argParse/unitStr'\nimport { durationDayTimeToNano } from './dayAndTime'\nimport { DiffableObj } from './diff'\nimport {\n  DurationFields,\n  UnsignedDurationFields,\n  computeLargestDurationUnit,\n} from './durationFields'\nimport { spanDurationFromDateTime } from './durationSpan'\nimport { toEpochNano } from './epoch'\nimport { DAY, UnitInt, YEAR, isDayTimeUnit, nanoIn } from './units'\n\nexport function computeTotalUnits(\n  duration: DurationFields,\n  unit: UnitInt,\n  relativeTo: DiffableObj | undefined,\n  calendar: Temporal.CalendarProtocol | undefined,\n): number {\n  if (\n    relativeTo === undefined &&\n    computeLargestDurationUnit(duration) <= DAY &&\n    isDayTimeUnit(unit)\n  ) {\n    // TODO: accidentaly loss of precision?\n    return durationDayTimeToNano(duration).toNumber() / nanoIn[unit]\n  }\n\n  if (!relativeTo) {\n    throw new RangeError('Need relativeTo')\n  }\n\n  const [balancedDuration, relativeToTranslated] = spanDurationFromDateTime(\n    duration,\n    unit,\n    relativeTo,\n    calendar!,\n    true, // dissolveWeeks\n  )\n\n  const durationLike = computeExactDuration(\n    balancedDuration,\n    unit,\n    relativeTo,\n    relativeToTranslated,\n  )\n\n  const unitName = durationUnitNames[unit] as keyof UnsignedDurationFields\n  return durationLike[unitName]\n}\n\n// TODO: rename to computeFracDuration\n// PRECONDITION: dates have same calendar\n// RETURNS: raw duration fields that might have floating-point values\n// Those floating-point values will need to rounded before creating a proper Duration\nexport function computeExactDuration(\n  balancedDuration: DurationFields,\n  smallestUnit: UnitInt,\n  dt0: DiffableObj,\n  dt1: DiffableObj,\n): DurationFields {\n  const smallestUnitName = durationUnitNames[smallestUnit] as keyof UnsignedDurationFields\n  const { sign } = balancedDuration\n\n  if (!sign) { // prevents division by zero\n    return balancedDuration\n  }\n\n  // make a new duration object that excludes units smaller than smallestUnit\n  const dur: Partial<DurationFields> = {}\n  for (let unit = YEAR; unit >= smallestUnit; unit--) {\n    const durationUnit = durationUnitNames[unit] as keyof UnsignedDurationFields\n    dur[durationUnit] = balancedDuration[durationUnit]\n  }\n\n  // a single additional unit of `unit`\n  const incDur: Partial<DurationFields> = { [smallestUnitName]: sign }\n  const startDateTime = dt0.add(dur)\n  const endDateTime = startDateTime.add(incDur)\n\n  const startNano = toEpochNano(startDateTime)\n  const endNano = toEpochNano(endDateTime)\n  const middleNano = toEpochNano(dt1)\n  const unitFrac =\n    middleNano.sub(startNano).toNumber() /\n    endNano.sub(startNano).toNumber() * sign\n\n  dur[smallestUnitName]! += unitFrac // above loop populated this\n  return dur as DurationFields\n}\n", "import { Temporal } from 'temporal-spec'\nimport { DiffConfig } from '../argParse/diffOptions'\nimport { durationUnitNames } from '../argParse/unitStr'\nimport { roundToIncrement, roundToIncrementBI } from '../utils/math'\nimport { durationDayTimeToNano, nanoToDuration } from './dayAndTime'\nimport { DiffableObj } from './diff'\nimport {\n  DurationFields,\n  UnsignedDurationFields,\n  computeLargestDurationUnit,\n  negateDuration,\n} from './durationFields'\nimport { spanDurationFrom, spanDurationFromDateTime } from './durationSpan'\nimport { toEpochNano } from './epoch'\nimport { computeExactDuration } from './totalUnits'\nimport {\n  DAY,\n  NANOSECOND,\n  UnitInt,\n  isDateUnit,\n  isDayTimeUnit,\n  nanoIn,\n} from './units'\n\n// duration rounding is very different from datetime rounding\n// more similar to diffing\n// TODO: make a new type `DurationRoundingConfig` that includes relativeTo\n\nexport function roundDuration(\n  duration: DurationFields,\n  diffConfig: DiffConfig<UnitInt>,\n  relativeTo: DiffableObj | undefined, // TODO: start using `DurationRoundingConfig`\n  calendar: Temporal.CalendarProtocol | undefined,\n): DurationFields {\n  const { largestUnit, smallestUnit, roundingIncrement, roundingFunc } = diffConfig\n\n  if (\n    relativeTo === undefined && // skip this block if relativeTo defined\n    computeLargestDurationUnit(duration) <= DAY &&\n    isDayTimeUnit(largestUnit) &&\n    isDayTimeUnit(smallestUnit)\n  ) {\n    const nano = roundToIncrementBI(\n      durationDayTimeToNano(duration),\n      nanoIn[smallestUnit] * roundingIncrement,\n      roundingFunc,\n    )\n    return nanoToDuration(nano, largestUnit)\n  }\n\n  if (!relativeTo) {\n    throw new RangeError('Need relativeTo')\n  }\n\n  const [spannedDuration, relativeToTranslated] = spanDurationFromDateTime(\n    duration,\n    largestUnit,\n    relativeTo,\n    calendar!,\n  )\n\n  return roundDurationSpan(\n    spannedDuration,\n    relativeTo,\n    relativeToTranslated,\n    calendar!,\n    false,\n    diffConfig,\n  )\n}\n\nexport function roundDurationSpan(\n  spannedDuration: DurationFields,\n  d0: DiffableObj,\n  d1: DiffableObj,\n  calendar: Temporal.CalendarProtocol,\n  flip: boolean,\n  diffConfig: DiffConfig,\n): DurationFields {\n  const { largestUnit, smallestUnit, roundingIncrement, roundingFunc } = diffConfig\n\n  // optimize for time units\n  if (!isDateUnit(largestUnit)) {\n    const diffNano = toEpochNano(d1).sub(toEpochNano(d0)).mult(flip ? -1 : 1)\n    const diffNanoRounded = roundToIncrementBI(\n      diffNano,\n      nanoIn[smallestUnit] * roundingIncrement,\n      roundingFunc,\n    )\n    return nanoToDuration(diffNanoRounded, largestUnit)\n  }\n\n  let durationFields = computeExactDuration(spannedDuration, smallestUnit, d0, d1)\n  const unitName = durationUnitNames[smallestUnit] as keyof UnsignedDurationFields\n\n  function doRound() {\n    const orig = durationFields[unitName] // computeExactDuration guarantees value\n    durationFields[unitName] = roundToIncrement(orig, roundingIncrement, roundingFunc)\n  }\n\n  if (roundingFunc === Math.round) {\n    // 'halfExpand' cares about point-to-point translation\n    doRound()\n  }\n  if (flip) {\n    durationFields = negateDuration(durationFields)\n  }\n  if (roundingFunc !== Math.round) {\n    // other rounding techniques operate on final number\n    doRound()\n  }\n\n  // TODO: instead of this mess, have a halfExpandDirection arg\n  // rebalance\n  if (smallestUnit > NANOSECOND) {\n    if (flip) {\n      // yuck\n      durationFields = negateDuration(\n        spanDurationFrom(negateDuration(durationFields), largestUnit, d0, calendar),\n      )\n    } else {\n      durationFields = spanDurationFrom(durationFields, largestUnit, d0, calendar)\n    }\n  }\n\n  return durationFields\n}\n", "import { Temporal } from 'temporal-spec'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { DurationToStringUnitInt, parseTimeToStringOptions } from '../argParse/isoFormatOptions'\nimport { ensureOptionsObj, isObjectLike } from '../argParse/refine'\nimport { parseTotalConfig } from '../argParse/totalOptions'\nimport { AbstractNoValueObj, ensureObj } from '../dateUtils/abstract'\nimport { compareDurations } from '../dateUtils/compare'\nimport {\n  DurationFields,\n  UnsignedDurationFields,\n  absDuration,\n  computeLargestDurationUnit,\n  negateDuration,\n  refineDurationNumbers,\n} from '../dateUtils/durationFields'\nimport { processDurationFields } from '../dateUtils/fromAndWith'\nimport { formatDurationISO } from '../dateUtils/isoFormat'\nimport { attachStringTag } from '../dateUtils/mixins'\nimport { parseDuration } from '../dateUtils/parseDuration'\nimport { extractRelativeTo } from '../dateUtils/relativeTo'\nimport { roundDuration } from '../dateUtils/roundingDuration'\nimport { computeTotalUnits } from '../dateUtils/totalUnits'\nimport { addDurationFields } from '../dateUtils/translate'\nimport { NANOSECOND, SECOND, UnitInt, YEAR } from '../dateUtils/units'\nimport { LocalesArg } from '../native/intlUtils'\nimport { createWeakMap } from '../utils/obj'\nimport { PlainDateTimeArg } from './plainDateTime'\nimport { ZonedDateTimeArg } from './zonedDateTime'\n\nexport type DurationArg = Temporal.Duration | Temporal.DurationLike | string\n\n// guaranteed options object\ntype DurationRoundingOptions = Temporal.DifferenceOptions<Temporal.DateTimeUnit> & {\n  relativeTo?: ZonedDateTimeArg | PlainDateTimeArg\n}\n\nconst [getFields, setFields] = createWeakMap<Duration, DurationFields>()\n\nexport class Duration extends AbstractNoValueObj implements Temporal.Duration {\n  constructor(\n    years = 0,\n    months = 0,\n    weeks = 0,\n    days = 0,\n    hours = 0,\n    minutes = 0,\n    seconds = 0,\n    milliseconds = 0,\n    microseconds = 0,\n    nanoseconds = 0,\n  ) {\n    super()\n    const numberFields = processDurationFields({ // TODO: overkill. does hasAnyProps\n      years,\n      months,\n      weeks,\n      days,\n      hours,\n      minutes,\n      seconds,\n      milliseconds,\n      microseconds,\n      nanoseconds,\n    })\n    setFields(this, refineDurationNumbers(numberFields))\n  }\n\n  static from(arg: DurationArg): Temporal.Duration {\n    return createDuration(\n      typeof arg === 'object'\n        ? processDurationFields(arg)\n        : parseDuration(arg),\n    )\n  }\n\n  static compare(\n    a: DurationArg,\n    b: DurationArg,\n    options?: Temporal.DurationArithmeticOptions,\n  ): Temporal.ComparisonResult {\n    return compareDurations(\n      ensureObj(Duration, a),\n      ensureObj(Duration, b),\n      extractRelativeTo(ensureOptionsObj(options).relativeTo),\n    )\n  }\n\n  get years(): number { return getFields(this).years }\n  get months(): number { return getFields(this).months }\n  get weeks(): number { return getFields(this).weeks }\n  get days(): number { return getFields(this).days }\n  get hours(): number { return getFields(this).hours }\n  get minutes(): number { return getFields(this).minutes }\n  get seconds(): number { return getFields(this).seconds }\n  get milliseconds(): number { return getFields(this).milliseconds }\n  get microseconds(): number { return getFields(this).microseconds }\n  get nanoseconds(): number { return getFields(this).nanoseconds }\n  get sign(): Temporal.ComparisonResult { return getFields(this).sign }\n  get blank(): boolean { return !this.sign }\n\n  with(fields: Temporal.DurationLike): Temporal.Duration {\n    return createDuration({\n      ...getFields(this),\n      ...processDurationFields(fields),\n    })\n  }\n\n  negated(): Temporal.Duration {\n    return createDuration(negateDuration(getFields(this)))\n  }\n\n  abs(): Temporal.Duration {\n    return createDuration(absDuration(getFields(this)))\n  }\n\n  add(other: DurationArg, options?: Temporal.DurationArithmeticOptions): Temporal.Duration {\n    return addDurations(this, ensureObj(Duration, other), options)\n  }\n\n  subtract(other: DurationArg, options?: Temporal.DurationArithmeticOptions): Temporal.Duration {\n    return addDurations(this, negateDuration(ensureObj(Duration, other)), options)\n  }\n\n  round(options: Temporal.DurationRoundTo): Temporal.Duration {\n    const optionsObj: DurationRoundingOptions = typeof options === 'string'\n      ? { smallestUnit: options }\n      : options\n\n    if (!isObjectLike(optionsObj)) {\n      throw new TypeError('Must specify options') // best place for this?\n    } else if (optionsObj.largestUnit === undefined && optionsObj.smallestUnit === undefined) {\n      throw new RangeError('Must specify either largestUnit or smallestUnit')\n    }\n\n    const defaultLargestUnit = computeLargestDurationUnit(this)\n    const diffConfig = parseDiffOptions<Temporal.DateTimeUnit, UnitInt>(\n      optionsObj,\n      defaultLargestUnit, // largestUnitDefault\n      NANOSECOND, // smallestUnitDefault\n      NANOSECOND, // minUnit\n      YEAR, // maxUnit\n      true, // forDurationRounding\n    )\n\n    const relativeTo = extractRelativeTo((optionsObj as DurationRoundingOptions).relativeTo)\n    // weird\n\n    return createDuration(\n      roundDuration(this, diffConfig, relativeTo, relativeTo ? relativeTo.calendar : undefined),\n    )\n  }\n\n  total(options: Temporal.DurationTotalOf): number {\n    const totalConfig = parseTotalConfig(options)\n    const relativeTo = extractRelativeTo(totalConfig.relativeTo)\n\n    return computeTotalUnits(\n      this,\n      totalConfig.unit,\n      relativeTo,\n      relativeTo ? relativeTo.calendar : undefined,\n    )\n  }\n\n  toString(options?: Temporal.ToStringPrecisionOptions): string {\n    const formatConfig = parseTimeToStringOptions<DurationToStringUnitInt>(\n      options, SECOND,\n    )\n    return formatDurationISO(getFields(this), formatConfig)\n  }\n\n  toLocaleString(_locales?: LocalesArg, _options?: unknown): string {\n    // the spec recommends this in the absence of Intl.DurationFormat\n    return this.toString()\n  }\n}\n\n// mixins\nexport interface Duration { [Symbol.toStringTag]: 'Temporal.Duration' }\nattachStringTag(Duration, 'Duration')\n\nexport function createDuration(fields: UnsignedDurationFields): Duration {\n  return new Duration(\n    fields.years,\n    fields.months,\n    fields.weeks,\n    fields.days,\n    fields.hours,\n    fields.minutes,\n    fields.seconds,\n    fields.milliseconds,\n    fields.microseconds,\n    fields.nanoseconds,\n  )\n}\n\nfunction addDurations(\n  d0: DurationFields,\n  d1: DurationFields,\n  options?: Temporal.DurationArithmeticOptions,\n): Duration {\n  const relativeTo = extractRelativeTo(ensureOptionsObj(options).relativeTo)\n\n  return createDuration(\n    addDurationFields(d0, d1, relativeTo, relativeTo ? relativeTo.calendar : undefined),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { NANOSECOND, UnitInt, YEAR } from '../dateUtils/units'\nimport { PlainDateTimeArg } from '../public/plainDateTime'\nimport { ensureOptionsObj } from './refine'\nimport { parseUnit } from './unitStr'\n\n// only for duration\n\nexport interface DurationTotalConfig {\n  unit: UnitInt,\n  relativeTo?: PlainDateTimeArg\n}\n\nexport function parseTotalConfig(optionsArg: Temporal.DurationTotalOf): DurationTotalConfig {\n  let relativeTo: PlainDateTimeArg | undefined\n  let unitName: Temporal.TotalUnit<Temporal.DateTimeUnit> | undefined\n\n  if (typeof optionsArg === 'string') {\n    unitName = optionsArg\n  } else {\n    unitName = ensureOptionsObj(optionsArg).unit\n    relativeTo = optionsArg.relativeTo\n  }\n\n  return {\n    unit: parseUnit<UnitInt>(unitName, undefined, NANOSECOND, YEAR),\n    relativeTo,\n  }\n}\n", "import { Temporal } from 'temporal-spec'\nimport { getCommonCalendar, getStrangerCalendar } from '../argParse/calendar'\nimport { parseCalendarDisplayOption } from '../argParse/calendarDisplay'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { parseDisambigOption } from '../argParse/disambig'\nimport { parseTimeToStringOptions } from '../argParse/isoFormatOptions'\nimport { OVERFLOW_REJECT, parseOverflowOption } from '../argParse/overflowHandling'\nimport { parseRoundingOptions } from '../argParse/roundingOptions'\nimport { timeUnitNames } from '../argParse/unitStr'\nimport { AbstractISOObj, ensureObj } from '../dateUtils/abstract'\nimport { compareDateTimes, dateTimesEqual } from '../dateUtils/compare'\nimport { constrainDateTimeISO } from '../dateUtils/constrain'\nimport { DayTimeUnit } from '../dateUtils/dayAndTime'\nimport { diffDateTimes } from '../dateUtils/diff'\nimport { DurationFields, negateDuration } from '../dateUtils/durationFields'\nimport { processDateTimeFromFields, processDateTimeWithFields } from '../dateUtils/fromAndWith'\nimport { validateDateTime } from '../dateUtils/isoFieldValidation'\nimport { formatCalendarID, formatDateTimeISO } from '../dateUtils/isoFormat'\nimport { LocalTimeFields } from '../dateUtils/localFields'\nimport {\n  DateCalendarFields,\n  attachStringTag,\n  dateCalendarFields,\n  mixinCalendarFields,\n  mixinISOFields,\n} from '../dateUtils/mixins'\nimport { parseDateTime } from '../dateUtils/parse'\nimport { refineBaseObj } from '../dateUtils/parseRefine'\nimport { roundDateTime } from '../dateUtils/rounding'\nimport { getInstantFor } from '../dateUtils/timeZone'\nimport { translateDateTime } from '../dateUtils/translate'\nimport { DAY, DayTimeUnitInt, NANOSECOND, UnitInt, YEAR } from '../dateUtils/units'\nimport { createPlainFormatFactoryFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { Calendar, createDefaultCalendar } from './calendar'\nimport { Duration, DurationArg, createDuration } from './duration'\nimport { PlainDate, PlainDateArg, createDate } from './plainDate'\nimport { PlainTimeArg, createTime, ensureLooseTime } from './plainTime'\nimport { createYearMonth } from './plainYearMonth'\nimport { TimeZone } from './timeZone'\nimport { ZonedDateTime } from './zonedDateTime'\n\nexport type PlainDateTimeArg = Temporal.PlainDateTime | Temporal.PlainDateTimeLike | string\n\ntype DiffOptions = Temporal.DifferenceOptions<\n'year' | 'month' | 'week' | 'day' |\n'hour' | 'minute' | 'second' | 'millisecond' | 'microsecond' | 'nanosecond'\n>\n\ntype RoundOptions = Temporal.RoundTo<\n'day' | 'hour' | 'minute' | 'second' |\n'millisecond' | 'microsecond' | 'nanosecond'\n>\n\nexport class PlainDateTime extends AbstractISOObj<Temporal.PlainDateTimeISOFields>\n  implements Temporal.PlainDateTime {\n  constructor(\n    isoYear: number,\n    isoMonth: number,\n    isoDay: number,\n    isoHour = 0,\n    isoMinute = 0,\n    isoSecond = 0,\n    isoMillisecond = 0,\n    isoMicrosecond = 0,\n    isoNanosecond = 0,\n    calendarArg: Temporal.CalendarLike = createDefaultCalendar(),\n  ) {\n    const constrained = constrainDateTimeISO({\n      isoYear,\n      isoMonth,\n      isoDay,\n      isoHour,\n      isoMinute,\n      isoSecond,\n      isoMillisecond,\n      isoMicrosecond,\n      isoNanosecond,\n    }, OVERFLOW_REJECT)\n    const calendar = ensureObj(Calendar, calendarArg)\n\n    validateDateTime(constrained, calendar.toString())\n\n    super({\n      ...constrained,\n      calendar,\n    })\n  }\n\n  static from(arg: PlainDateTimeArg, options?: Temporal.AssignmentOptions): Temporal.PlainDateTime {\n    const overflowHandling = parseOverflowOption(options)\n\n    return createDateTime(\n      arg instanceof PlainDateTime\n        ? arg.getISOFields() // optimization\n        : typeof arg === 'object'\n          ? processDateTimeFromFields(arg, overflowHandling, options)\n          : refineBaseObj(parseDateTime(String(arg))),\n    )\n  }\n\n  static compare(a: PlainDateTimeArg, b: PlainDateTimeArg): Temporal.ComparisonResult {\n    return compareDateTimes(\n      ensureObj(PlainDateTime, a),\n      ensureObj(PlainDateTime, b),\n    )\n  }\n\n  with(\n    fields: Temporal.PlainDateTimeLike,\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainDateTime {\n    const overflowHandling = parseOverflowOption(options)\n    return createDateTime(\n      processDateTimeWithFields(this, fields, overflowHandling, options),\n    )\n  }\n\n  withPlainDate(dateArg: PlainDateArg): Temporal.PlainDateTime {\n    const date = ensureObj(PlainDate, dateArg)\n    return createDateTime({\n      ...this.getISOFields(), // provides time fields\n      ...date.getISOFields(),\n      calendar: getStrangerCalendar(this, date),\n    })\n  }\n\n  withPlainTime(timeArg?: PlainTimeArg): Temporal.PlainDateTime {\n    return createDateTime({\n      ...this.getISOFields(), // provides date & calendar fields\n      ...ensureLooseTime(timeArg).getISOFields(),\n    })\n  }\n\n  withCalendar(calendarArg: Temporal.CalendarLike): Temporal.PlainDateTime {\n    return createDateTime({\n      ...this.getISOFields(),\n      calendar: ensureObj(Calendar, calendarArg),\n    })\n  }\n\n  add(durationArg: DurationArg, options?: Temporal.ArithmeticOptions): Temporal.PlainDateTime {\n    return translatePlainDateTime(this, ensureObj(Duration, durationArg), options)\n  }\n\n  subtract(durationArg: DurationArg, options?: Temporal.ArithmeticOptions): Temporal.PlainDateTime {\n    return translatePlainDateTime(this, negateDuration(ensureObj(Duration, durationArg)), options)\n  }\n\n  until(other: PlainDateTimeArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainDateTimes(\n      this,\n      ensureObj(PlainDateTime, other),\n      false,\n      options,\n    )\n  }\n\n  since(other: PlainDateTimeArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainDateTimes(\n      this,\n      ensureObj(PlainDateTime, other),\n      true,\n      options,\n    )\n  }\n\n  round(options: RoundOptions): Temporal.PlainDateTime {\n    const roundingConfig = parseRoundingOptions<DayTimeUnit, DayTimeUnitInt>(\n      options,\n      NANOSECOND, // minUnit\n      DAY, // maxUnit\n    )\n\n    return createDateTime({\n      ...roundDateTime(this.getISOFields(), roundingConfig),\n      calendar: this.calendar,\n    })\n  }\n\n  equals(other: PlainDateTimeArg): boolean {\n    return dateTimesEqual(this, ensureObj(PlainDateTime, other))\n  }\n\n  toString(options?: Temporal.CalendarTypeToStringOptions): string {\n    const formatConfig = parseTimeToStringOptions(options)\n    const calendarDisplay = parseCalendarDisplayOption(options)\n    const isoFields = roundDateTime(this.getISOFields(), formatConfig)\n\n    return formatDateTimeISO(isoFields, formatConfig) +\n      formatCalendarID(this.calendar.toString(), calendarDisplay)\n  }\n\n  toZonedDateTime(\n    timeZoneArg: Temporal.TimeZoneLike,\n    options?: Temporal.ToInstantOptions,\n  ): Temporal.ZonedDateTime {\n    const timeZone = ensureObj(TimeZone, timeZoneArg)\n    const instant = getInstantFor(timeZone, this, parseDisambigOption(options))\n\n    // more succinct than createZonedDateTimeFromFields\n    return new ZonedDateTime(instant.epochNanoseconds, timeZone, this.calendar)\n  }\n\n  toPlainYearMonth(): Temporal.PlainYearMonth { return createYearMonth(this.getISOFields()) }\n  toPlainMonthDay(): Temporal.PlainMonthDay { return this.calendar.monthDayFromFields(this) }\n  toPlainDate(): Temporal.PlainDate { return createDate(this.getISOFields()) }\n  toPlainTime(): Temporal.PlainTime { return createTime(this.getISOFields()) }\n}\n\n// mixin\nexport interface PlainDateTime { [Symbol.toStringTag]: 'Temporal.PlainDateTime' }\nexport interface PlainDateTime extends DateCalendarFields { calendar: Temporal.CalendarProtocol }\nexport interface PlainDateTime extends LocalTimeFields {}\nexport interface PlainDateTime extends ToLocaleStringMethods {}\nattachStringTag(PlainDateTime, 'PlainDateTime')\nmixinISOFields(PlainDateTime, timeUnitNames)\nmixinCalendarFields(PlainDateTime, dateCalendarFields)\nmixinLocaleStringMethods(PlainDateTime, createPlainFormatFactoryFactory({\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  weekday: undefined,\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit',\n}, {}))\n\n// creation\nexport function createDateTime(isoFields: Temporal.PlainDateTimeISOFields): PlainDateTime {\n  return new PlainDateTime(\n    isoFields.isoYear,\n    isoFields.isoMonth,\n    isoFields.isoDay,\n    isoFields.isoHour,\n    isoFields.isoMinute,\n    isoFields.isoSecond,\n    isoFields.isoMillisecond,\n    isoFields.isoMicrosecond,\n    isoFields.isoNanosecond,\n    isoFields.calendar,\n  )\n}\n\nfunction translatePlainDateTime(\n  pdt0: PlainDateTime,\n  dur: DurationFields,\n  options: Temporal.ArithmeticOptions | undefined,\n): PlainDateTime {\n  const isoFields = translateDateTime(pdt0.getISOFields(), dur, options)\n  return createDateTime({\n    ...isoFields,\n    calendar: pdt0.calendar,\n  })\n}\n\nfunction diffPlainDateTimes(\n  pdt0: PlainDateTime,\n  pdt1: PlainDateTime,\n  flip: boolean,\n  options: DiffOptions | undefined,\n): Duration {\n  const diffConfig = parseDiffOptions<Temporal.DateTimeUnit, UnitInt>(\n    options,\n    DAY, // largestUnitDefault\n    NANOSECOND, // smallestUnitDefault\n    NANOSECOND, // minUnit\n    YEAR, // maxUnit\n  )\n\n  return createDuration(\n    diffDateTimes(pdt0, pdt1, getCommonCalendar(pdt0, pdt1), flip, diffConfig),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { parseCalendarDisplayOption } from '../argParse/calendarDisplay'\nimport { OVERFLOW_REJECT, parseOverflowOption } from '../argParse/overflowHandling'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { AbstractISOObj, ensureObj } from '../dateUtils/abstract'\nimport { compareDateTimes } from '../dateUtils/compare'\nimport { constrainDateISO } from '../dateUtils/constrain'\nimport { isoEpochLeapYear } from '../dateUtils/epoch'\nimport { processMonthDayFromFields, processMonthDayWithFields } from '../dateUtils/fromAndWith'\nimport { formatCalendarID, formatDateISO, formatMonthDayISO } from '../dateUtils/isoFormat'\nimport {\n  MonthDayCalendarFields,\n  attachStringTag,\n  mixinCalendarFields,\n  mixinISOFields,\n  monthDayCalendarFields,\n} from '../dateUtils/mixins'\nimport { parseMonthDay } from '../dateUtils/parse'\nimport { refineBaseObj } from '../dateUtils/parseRefine'\nimport { createPlainFormatFactoryFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { Calendar, createDefaultCalendar } from './calendar'\n\nexport type PlainMonthDayArg = Temporal.PlainMonthDay | Temporal.PlainMonthDayLike | string\n\nexport class PlainMonthDay extends AbstractISOObj<Temporal.PlainDateISOFields>\n  implements Temporal.PlainMonthDay {\n  constructor(\n    isoMonth: number,\n    isoDay: number,\n    calendar: Temporal.CalendarLike = createDefaultCalendar(),\n    referenceISOYear: number = isoEpochLeapYear,\n  ) {\n    super({\n      ...constrainDateISO({ isoYear: referenceISOYear, isoMonth, isoDay }, OVERFLOW_REJECT),\n      calendar: ensureObj(Calendar, calendar),\n    })\n  }\n\n  static from(arg: PlainMonthDayArg, options?: Temporal.AssignmentOptions): Temporal.PlainMonthDay {\n    parseOverflowOption(options) // unused, but need to validate, regardless of input type\n\n    if (arg instanceof PlainMonthDay) {\n      return createMonthDay(arg.getISOFields()) // optimization\n    }\n\n    if (typeof arg === 'object') {\n      return processMonthDayFromFields(arg, options)\n    }\n\n    // a string...\n    const parsed = parseMonthDay(String(arg))\n\n    // for strings, force ISO year if no calendar specified\n    // TODO: more DRY with processMonthDayLike?\n    if (parsed.calendar === undefined) {\n      parsed.isoYear = isoEpochLeapYear\n    }\n\n    return createMonthDay(refineBaseObj(parsed))\n  }\n\n  with(\n    fields: Temporal.PlainMonthDayLike,\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainMonthDay {\n    return processMonthDayWithFields(this, fields, options)\n  }\n\n  equals(other: PlainMonthDayArg): boolean {\n    return !compareDateTimes(this, ensureObj(PlainMonthDay, other))\n  }\n\n  toString(options?: Temporal.ShowCalendarOption): string {\n    const fields = this.getISOFields()\n    const calendarID = fields.calendar.toString() // see note in formatCalendarID\n    const calendarDisplay = parseCalendarDisplayOption(options)\n\n    return (\n      calendarID === isoCalendarID\n        ? formatMonthDayISO(fields)\n        : formatDateISO(fields)\n    ) + formatCalendarID(calendarID, calendarDisplay)\n  }\n\n  toPlainDate(fields: { year: number }): Temporal.PlainDate {\n    return this.calendar.dateFromFields({\n      year: fields.year,\n      monthCode: this.monthCode,\n      day: this.day,\n    }, {\n      overflow: 'reject', // always reject\n    })\n  }\n}\n\n// mixin\nexport interface PlainMonthDay { [Symbol.toStringTag]: 'Temporal.PlainMonthDay' }\nexport interface PlainMonthDay extends MonthDayCalendarFields {\n  calendar: Temporal.CalendarProtocol\n}\nexport interface PlainMonthDay extends ToLocaleStringMethods {}\nattachStringTag(PlainMonthDay, 'PlainMonthDay')\nmixinISOFields(PlainMonthDay)\nmixinCalendarFields(PlainMonthDay, monthDayCalendarFields)\nmixinLocaleStringMethods(PlainMonthDay, createPlainFormatFactoryFactory({\n  month: 'numeric',\n  day: 'numeric',\n}, {\n  weekday: undefined,\n  year: undefined,\n  hour: undefined,\n  minute: undefined,\n  second: undefined,\n}, true)) // strictCalendar\n\n// create\nexport function createMonthDay(isoFields: Temporal.PlainDateISOFields): PlainMonthDay {\n  return new PlainMonthDay(\n    isoFields.isoMonth,\n    isoFields.isoDay,\n    isoFields.calendar,\n    isoFields.isoYear,\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { ensureCalendarsEqual } from '../argParse/calendar'\nimport { OVERFLOW_REJECT, parseOverflowOption } from '../argParse/overflowHandling'\nimport { CalendarImpl, convertEraYear } from '../calendarImpl/calendarImpl'\nimport { PlainDate, PlainDateArg, createDate } from '../public/plainDate'\nimport { PlainDateTime } from '../public/plainDateTime'\nimport { PlainMonthDay } from '../public/plainMonthDay'\nimport { PlainYearMonth } from '../public/plainYearMonth'\nimport { ZonedDateTime } from '../public/zonedDateTime'\nimport { constrainDateFields } from './constrain'\nimport { diffDaysMilli, epochMilliToISOFields } from './epoch'\nimport { ISODateFields } from './isoFields'\nimport { LocalDateFields } from './localFields'\n\n// Date-type Testing (TODO: move this?)\n\nexport type DateLikeInstance = // has year/month/day\n  PlainDate |\n  PlainDateTime |\n  ZonedDateTime\n\nexport type DateISOInstance = // has isoYear/isoMonth/isoDay\n  DateLikeInstance |\n  PlainYearMonth |\n  PlainMonthDay\n\nfunction isDateISOInstance(arg: unknown): arg is DateISOInstance {\n  return (\n    arg instanceof PlainDate ||\n    arg instanceof PlainDateTime ||\n    arg instanceof ZonedDateTime ||\n    arg instanceof PlainYearMonth ||\n    arg instanceof PlainMonthDay\n  )\n}\n\n// Calendar-dependent Field Querying\n\nexport function queryDateFields(\n  arg: DateISOInstance | PlainDateArg,\n  calendar: Temporal.CalendarProtocol,\n  disallowMonthDay?: boolean,\n): LocalDateFields {\n  let date: PlainDate\n\n  if (arg instanceof PlainDate) {\n    date = arg\n  } else if (isDateISOInstance(arg)) {\n    if (disallowMonthDay && arg instanceof PlainMonthDay) {\n      throw new TypeError('PlainMonthDay not allowed')\n    }\n    date = createDate(arg.getISOFields())\n  } else {\n    date = PlainDate.from(arg)\n  }\n\n  ensureCalendarsEqual(date.calendar, calendar)\n  return date\n}\n\n// ISO Field Querying\n\nexport function queryDateISOFields(\n  dateLike: DateISOInstance | Temporal.PlainDateLike,\n  calendarImpl: CalendarImpl,\n  options: Temporal.AssignmentOptions | undefined,\n): ISODateFields {\n  if (isDateISOInstance(dateLike)) {\n    return dateLike.getISOFields() // hard work has already been done\n  }\n\n  let { era, eraYear, year, month, monthCode, day } = dateLike\n  const yearFromEra = (eraYear !== undefined && era !== undefined)\n    ? convertEraYear(calendarImpl.id, eraYear, era)\n    : undefined\n\n  if (year === undefined) {\n    if (yearFromEra !== undefined) {\n      year = yearFromEra\n    } else {\n      throw new TypeError('Must specify either a year or an era & eraYear')\n    }\n  } else {\n    if (yearFromEra !== undefined) {\n      if (yearFromEra !== year) {\n        throw new RangeError('year and era/eraYear must match')\n      }\n    }\n  }\n\n  if (day === undefined) {\n    throw new TypeError('Must specify day')\n  }\n\n  const overflow = parseOverflowOption(options)\n\n  if (monthCode !== undefined) {\n    const [tryMonth, unusedLeap] = calendarImpl.convertMonthCode(monthCode, year)\n\n    if (month !== undefined && month !== tryMonth) {\n      throw new RangeError('Month doesnt match with monthCode')\n    }\n\n    month = tryMonth\n\n    if (unusedLeap) {\n      if (overflow === OVERFLOW_REJECT) {\n        throw new RangeError('Month code out of range')\n      }\n      // constrain to last day of month\n      day = calendarImpl.daysInMonth(year, month)\n    }\n  } else if (month === undefined) {\n    throw new TypeError('Must specify either a month or monthCode')\n  }\n\n  [year, month, day] = constrainDateFields(\n    year, month, day,\n    calendarImpl,\n    overflow,\n  )\n\n  return epochMilliToISOFields(calendarImpl.epochMilliseconds(year, month, day))\n}\n\nexport function getExistingDateISOFields(\n  dateArg: DateISOInstance | PlainDateArg,\n  disallowMonthDay?: boolean,\n): ISODateFields {\n  if (isDateISOInstance(dateArg)) {\n    if (disallowMonthDay && dateArg instanceof PlainMonthDay) {\n      throw new TypeError('PlainMonthDay not allowed')\n    }\n    return dateArg.getISOFields()\n  } else {\n    return PlainDate.from(dateArg).getISOFields()\n  }\n}\n\n// Calendar-dependent Math\n\nexport function computeDaysInYear(calendarImpl: CalendarImpl, year: number): number {\n  return diffDaysMilli(\n    calendarImpl.epochMilliseconds(year, 1, 1),\n    calendarImpl.epochMilliseconds(year + 1, 1, 1),\n  )\n}\n\nexport function computeDayOfYear(\n  calendarImpl: CalendarImpl,\n  year: number,\n  month: number,\n  day: number,\n): number {\n  return diffDaysMilli(\n    calendarImpl.epochMilliseconds(year, 1, 1),\n    calendarImpl.epochMilliseconds(year, month, day),\n  ) + 1 // 1-based\n}\n", "import { computeDaysInYear } from '../dateUtils/calendar'\nimport {\n  addDaysMilli,\n  diffDaysMilli,\n  isoEpochOriginYear,\n  isoToEpochMilli,\n} from '../dateUtils/epoch'\nimport { hashIntlFormatParts, normalizeShortEra } from '../dateUtils/intlFormat'\nimport { OrigDateTimeFormat } from '../native/intlUtils'\nimport {\n  CalendarImpl,\n  CalendarImplFields,\n  CalendarImplFieldsDumb,\n  convertEraYear,\n  getCalendarIDBase,\n  hasEras,\n} from './calendarImpl'\n\ntype MonthCache = [\n  number[], // epochMillis\n  string[], // monthStrs\n  { [monthStr: string]: number }, // monthStrToNum (value is 1-based)\n]\n\nconst calLeapMonths: { [cal: string]: number } = {\n  hebrew: 6, // consistent month\n  chinese: 0, // zero implies variable month\n  dangi: 0, // \"\n}\n\nexport class IntlCalendarImpl extends CalendarImpl {\n  private format: Intl.DateTimeFormat\n\n  // difference between iso year numbers and the calendar's at 1980\n  private yearCorrection: number\n\n  // epochMilli starting points for each month\n  private monthCacheByYear: { [year: string]: MonthCache }\n\n  constructor(id: string) {\n    const format = buildFormat(id)\n\n    if (!isRelatedCalendar(id, format.resolvedOptions().calendar)) {\n      throw new RangeError('Invalid calendar: ' + id)\n    }\n\n    super(id)\n    this.format = format\n    this.yearCorrection = this.computeFieldsDumb(0).year - isoEpochOriginYear\n    this.monthCacheByYear = {}\n  }\n\n  epochMilliseconds(year: number, month: number, day: number): number {\n    const epochMillis = this.queryMonthCache(year)[0]\n    const marker = epochMillis[month - 1]\n\n    // move to correct day-of-month\n    return addDaysMilli(marker, day - 1)\n  }\n\n  daysInMonth(year: number, month: number): number {\n    const epochMillis = this.queryMonthCache(year)[0]\n    const startMarker = epochMillis[month - 1]\n\n    // The `month` variable, which is 1-based, should now be considered an index for `monthCache`\n    // It is +1 from the previous index, used to compute the `endMarker`\n    if (month >= epochMillis.length) {\n      year++\n      month = 0\n    }\n\n    const endMarker = this.queryMonthCache(year)[0][month]\n    return diffDaysMilli(startMarker, endMarker)\n  }\n\n  monthsInYear(year: number): number {\n    const epochMillis = this.queryMonthCache(year)[0]\n    return epochMillis.length\n  }\n\n  // month -> monthCode\n  monthCode(month: number, year: number): string {\n    const leapMonth = this.queryLeapMonthByYear(year)\n\n    if (!leapMonth || month < leapMonth) {\n      return super.monthCode(month, year)\n    }\n\n    return super.monthCode(month - 1, year) +\n      (month === leapMonth ? 'L' : '')\n  }\n\n  // monthCode -> month\n  convertMonthCode(monthCode: string, year: number): [number, boolean] {\n    const leapMonth = this.queryLeapMonthByYear(year) // 0 if none\n\n    // TODO: more DRY\n    let monthCodeIsLeap = /L$/.test(monthCode)\n    let monthCodeInt = parseInt(monthCode.substr(1)) // chop off 'M'\n    let unusedLeap = false\n\n    // validate the leap-month\n    if (monthCodeIsLeap) {\n      const presetLeapMonth = calLeapMonths[this.id] // TODO: use base ID?\n\n      if (presetLeapMonth === undefined) {\n        throw new RangeError('Calendar system doesnt support leap months')\n      }\n\n      if (presetLeapMonth) {\n        if (monthCodeInt !== presetLeapMonth - 1) {\n          throw new RangeError('Invalid leap-month month code')\n        }\n      } else { // variable leap months (HACK: hardcoded for chinese/dangi)\n        if (monthCodeInt <= 1 || monthCodeInt >= 12) {\n          throw new RangeError('Invalid leap-month month code')\n        }\n      }\n    }\n\n    if (monthCodeIsLeap && !(leapMonth && monthCodeInt === leapMonth - 1)) {\n      unusedLeap = true\n      monthCodeIsLeap = false // yuck\n    }\n\n    if (monthCodeIsLeap || (leapMonth && monthCodeInt >= leapMonth)) {\n      monthCodeInt++\n    }\n\n    return [monthCodeInt, unusedLeap]\n  }\n\n  // TODO: look at number of months too?\n  inLeapYear(year: number): boolean {\n    const days = computeDaysInYear(this, year)\n    return days > computeDaysInYear(this, year - 1) &&\n      days > computeDaysInYear(this, year + 1)\n  }\n\n  guessYearForMonthDay(monthCode: string, day: number): number {\n    let year = isoEpochOriginYear + this.yearCorrection\n    const maxYear = year + 100\n\n    for (; year < maxYear; year++) {\n      const [month, unusedLeap] = this.convertMonthCode(monthCode, year)\n\n      if (\n        !unusedLeap &&\n        month <= this.monthsInYear(year) &&\n        day <= this.daysInMonth(year, month)\n      ) {\n        return year\n      }\n    }\n\n    throw new Error('Could not guess year') // TODO: better error\n  }\n\n  normalizeISOYearForMonthDay(isoYear: number): number {\n    return isoYear\n  }\n\n  computeFields(epochMilli: number): CalendarImplFields {\n    const dumbFields = this.computeFieldsDumb(epochMilli)\n    const monthStrToNum = this.queryMonthCache(dumbFields.year)[2]\n\n    return {\n      ...dumbFields,\n      month: monthStrToNum[dumbFields.month],\n    }\n  }\n\n  // returns a *string* month, not numeric\n  private computeFieldsDumb(epochMilli: number): CalendarImplFieldsDumb {\n    const partHash = hashIntlFormatParts(this.format, epochMilli)\n    let era: string | undefined\n    let eraYear: number | undefined\n    let year = parseInt(partHash.relatedYear || partHash.year)\n\n    if (partHash.era && hasEras(this.id)) {\n      era = normalizeShortEra(partHash.era)\n      eraYear = year\n      year = convertEraYear(this.id, eraYear, era, true) // fromDateTimeFormat=true\n    }\n\n    return {\n      era,\n      eraYear,\n      year,\n      month: partHash.month,\n      day: parseInt(partHash.day),\n    }\n  }\n\n  // the month number (1-based) that the leap-month falls on\n  // for example, the '3bis' leap month would fall on `4`\n  // TODO: cache somehow?\n  private queryLeapMonthByYear(year: number): number | undefined {\n    const currentCache = this.queryMonthCache(year)\n    const prevCache = this.queryMonthCache(year - 1)\n    const nextCache = this.queryMonthCache(year + 1)\n\n    // in a leap year?\n    // TODO: consolidate with inLeapYear?\n    if (\n      currentCache[0].length > prevCache[0].length &&\n      currentCache[0].length > nextCache[0].length\n    ) {\n      const currentMonthStrs = currentCache[1]\n      const prevMonthStrs = prevCache[1]\n\n      for (let i = 0; i < prevMonthStrs.length; i++) {\n        if (prevMonthStrs[i] !== currentMonthStrs[i]) {\n          return i + 1 // convert to 1-based\n        }\n      }\n    }\n\n    return undefined\n  }\n\n  private queryMonthCache(year: number): MonthCache {\n    const { monthCacheByYear } = this\n\n    return monthCacheByYear[year] ||\n      (monthCacheByYear[year] = this.buildMonthCache(year))\n  }\n\n  private buildMonthCache(year: number): MonthCache {\n    const epochMillis: number[] = []\n    const monthStrs: string[] = []\n    const monthStrToNum: { [monthStr: string]: number } = {}\n\n    // either part-way through the desired year or very slightly before\n    let epochMilli = isoToEpochMilli(this.guessISOYear(year), 1, 1)\n\n    // ensure marker is in year+1\n    epochMilli = addDaysMilli(epochMilli, 400)\n\n    // move epochMilli into past through each month\n    while (true) {\n      const fields = this.computeFieldsDumb(epochMilli)\n\n      // stop if month went too far into past\n      if (fields.year < year) {\n        break\n      }\n\n      // move to start-of-month\n      epochMilli = addDaysMilli(epochMilli, 1 - fields.day)\n\n      // only record the epochMilli if NOT in future year\n      if (fields.year === year) {\n        epochMillis.unshift(epochMilli)\n        monthStrs.unshift(fields.month)\n      }\n\n      // move to last day of previous month\n      epochMilli = addDaysMilli(epochMilli, -1)\n    }\n\n    for (let i = 0; i < monthStrs.length; i++) {\n      monthStrToNum[monthStrs[i]] = i + 1\n    }\n\n    return [epochMillis, monthStrs, monthStrToNum]\n  }\n\n  // subclasses that override should round UP\n  protected guessISOYear(year: number): number {\n    return year - this.yearCorrection\n  }\n}\n\n// Exposed Internals, for subclasses\n\nexport function buildFormat(calendarID: string): Intl.DateTimeFormat {\n  return new OrigDateTimeFormat('en-US', {\n    calendar: calendarID,\n    era: 'short', // 'narrow' is too terse for japanese months\n    year: 'numeric',\n    month: 'short', // easier to identify monthCodes\n    day: 'numeric',\n    timeZone: 'UTC',\n  })\n}\n\n// utils\n\nfunction isRelatedCalendar(specificCalendarID: string, relatedCalendarID: string): boolean {\n  return getCalendarIDBase(specificCalendarID) === getCalendarIDBase(relatedCalendarID)\n}\n", "import { isoToEpochMilli } from '../dateUtils/epoch'\nimport { hashIntlFormatParts, normalizeShortEra } from '../dateUtils/intlFormat'\nimport { CalendarImplFields } from './calendarImpl'\nimport { GregoryCalendarImpl } from './gregoryCalendarImpl'\nimport { buildFormat } from './intlCalendarImpl'\n\nconst primaryEraMilli = isoToEpochMilli(1868, 9, 8)\n\n/*\nThe Japanese calendar has same months like Gregorian, same eraYears,\nbut has era names that are Japanese after a certain point.\n*/\nexport class JapaneseCalendarImpl extends GregoryCalendarImpl {\n  private format = buildFormat('japanese')\n\n  computeFields(epochMilli: number): CalendarImplFields {\n    const fields = super.computeFields(epochMilli)\n\n    if (epochMilli >= primaryEraMilli) {\n      const partHash = hashIntlFormatParts(this.format, epochMilli)\n      fields.era = normalizeShortEra(partHash.era)\n      fields.eraYear = parseInt(partHash.relatedYear || partHash.year) // TODO: more DRY w/ intl\n    }\n\n    return fields\n  }\n}\n", "import { CalendarImpl, getCalendarIDBase } from './calendarImpl'\nimport { GregoryCalendarImpl } from './gregoryCalendarImpl'\nimport { IntlCalendarImpl } from './intlCalendarImpl'\nimport { IslamicCalendarImpl } from './islamicCalendarImpl'\nimport { isoCalendarID, isoCalendarImpl } from './isoCalendarImpl'\nimport { JapaneseCalendarImpl } from './japaneseCalendarImpl'\n\nconst implClasses: { [calendarID: string]: { new(id: string): CalendarImpl } } = {\n  gregory: GregoryCalendarImpl,\n  japanese: JapaneseCalendarImpl,\n  islamic: IslamicCalendarImpl,\n}\n\nconst implCache: { [calendarID: string]: CalendarImpl } = {\n  [isoCalendarID]: isoCalendarImpl,\n}\n\nexport function queryCalendarImpl(id: string): CalendarImpl {\n  id = String(id)\n  const key = id.toLocaleLowerCase() // lowercase matches isoCalendarID\n\n  return implCache[key] ||\n    (implCache[key] = new (\n      implClasses[getCalendarIDBase(key)] ||\n      IntlCalendarImpl\n    )(id))\n}\n", "import { IntlCalendarImpl } from './intlCalendarImpl'\n\nexport class IslamicCalendarImpl extends IntlCalendarImpl {\n  protected guessISOYear(year: number): number {\n    // https://en.wikipedia.org/wiki/Hijri_year#Formula\n    // round UP because superclass said so\n    return Math.ceil(year * 32 / 33 + 622)\n  }\n}\n", "import { isoToEpochMilli } from '../dateUtils/epoch'\nimport { milliInDay, nanoInMilli } from '../dateUtils/units'\nimport { LargeInt } from '../utils/largeInt'\nimport { queryCalendarImpl } from './calendarImplQuery'\nimport { IntlCalendarImpl } from './intlCalendarImpl'\n\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1173158\nconst good1582 = isoToEpochMilli(1582, 10, 15)\n\n// https://bugs.chromium.org/p/v8/issues/detail?id=10527\nconst goodIslamic = isoToEpochMilli(622, 7, 18)\n\nconst goodEpochMillis: { [cal: string]: number } = {\n  buddhist: good1582,\n  japanese: good1582,\n  roc: good1582,\n  islamic: goodIslamic,\n  'islamic-rgsa': goodIslamic,\n  indian: 0, // https://bugs.chromium.org/p/v8/issues/detail?id=10529\n}\n\nconst hasBugByID: { [cal: string]: boolean } = {}\n\nexport function checkEpochNanoBuggy(epochNano: LargeInt, calendarID: string): void {\n  return checkEpochMilliBuggy(epochNano.div(nanoInMilli).toNumber(), calendarID)\n}\n\nexport function checkEpochMilliBuggy(epochMilli: number, calendarID: string): void {\n  if (isEpochMilliBuggy(epochMilli, calendarID)) {\n    throw new RangeError('Invalid timestamp for calendar')\n  }\n}\n\nfunction isEpochMilliBuggy(epochMilli: number, calendarID: string): boolean {\n  return hasEpochMilliBug(calendarID) && epochMilli < goodEpochMillis[calendarID]\n}\n\nfunction hasEpochMilliBug(calendarID: string) {\n  let hasBug = hasBugByID[calendarID]\n  if (hasBug === undefined) {\n    const goodEpochMilli = goodEpochMillis[calendarID]\n    if (goodEpochMilli === undefined) {\n      hasBug = false\n    } else {\n      let impl = queryCalendarImpl(calendarID)\n\n      // HACK\n      // Even if Japanese, must leverage Intl.DateTimeFormat, so force IntlCalendarImpl\n      if (!(impl instanceof IntlCalendarImpl)) {\n        impl = new IntlCalendarImpl(calendarID)\n      }\n\n      const badEpochMilli = goodEpochMilli - milliInDay\n      const fields = impl.computeFields(badEpochMilli)\n      hasBug = badEpochMilli !== impl.epochMilliseconds(fields.year, fields.month, fields.day)\n    }\n    hasBugByID[calendarID] = hasBug\n  }\n  return hasBug\n}\n", "import { isoCalendarImpl } from '../calendarImpl/isoCalendarImpl'\nimport { positiveModulo } from '../utils/math'\nimport { computeDayOfYear, computeDaysInYear } from './calendar'\nimport { computeISODayOfWeek } from './epoch'\n\n// TODO: fix lots of 1-index problems!!!\n\nexport function computeWeekOfISOYear(\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n  firstDay: number,\n  minimalDays: number,\n): number {\n  // Days to ignore till first week\n  const weekOffset = computeFirstWeekOffset(\n    isoYear,\n    firstDay,\n    minimalDays,\n  )\n  // Current week #\n  const week =\n    Math.floor(\n      (computeDayOfYear(isoCalendarImpl, isoYear, isoMonth, isoDay) - weekOffset - 1) / 7,\n    ) + 1\n\n  // Go to previous year if 0 weeks\n  if (week < 1) {\n    return week + computeWeeksInISOYear(isoYear - 1, firstDay, minimalDays)\n  }\n\n  const weeksYear = computeWeeksInISOYear(isoYear, firstDay, minimalDays)\n\n  // Go to next year if greater than weeks in current year\n  if (week > weeksYear) {\n    return week - weeksYear\n  }\n\n  return week\n}\n\nfunction computeFirstWeekOffset(\n  isoYear: number,\n  firstDay: number,\n  minimalDays: number,\n): number {\n  // Which january is always in the first week (4 for iso, 1 for other)\n  const firstWeekDay = 7 + firstDay - minimalDays\n\n  // Which local weekday is first week day\n  const localWeek = positiveModulo(\n    computeISODayOfWeek(isoYear, 1, firstWeekDay) - firstDay,\n    7,\n  )\n\n  return -localWeek + firstWeekDay - 1\n}\n\nfunction computeWeeksInISOYear(\n  isoYear: number,\n  firstDay: number,\n  minimalDays: number,\n): number {\n  const weekOffset = computeFirstWeekOffset(isoYear, firstDay, minimalDays)\n  const weekOffsetNext = computeFirstWeekOffset(\n    isoYear + 1,\n    firstDay,\n    minimalDays,\n  )\n  return (\n    (computeDaysInYear(isoCalendarImpl, isoYear) -\n      weekOffset +\n      weekOffsetNext) /\n    7\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { calendarFromObj, ensureCalendarsEqual, getCommonCalendar } from '../argParse/calendar'\nimport { dateFieldMap, monthDayFieldMap, yearMonthFieldMap } from '../argParse/fieldStr'\nimport { parseOverflowOption } from '../argParse/overflowHandling'\nimport { ensureOptionsObj, isObjectLike, refineFields } from '../argParse/refine'\nimport { parseUnit } from '../argParse/unitStr'\nimport { checkEpochMilliBuggy } from '../calendarImpl/bugs'\nimport { CalendarImpl, CalendarImplFields, convertEraYear } from '../calendarImpl/calendarImpl'\nimport { queryCalendarImpl } from '../calendarImpl/calendarImplQuery'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { AbstractObj, ensureObj } from '../dateUtils/abstract'\nimport {\n  computeDayOfYear,\n  computeDaysInYear,\n  getExistingDateISOFields,\n  queryDateFields,\n  queryDateISOFields,\n} from '../dateUtils/calendar'\nimport { diffDateFields } from '../dateUtils/diff'\nimport { computeISODayOfWeek, isoEpochLeapYear, isoToEpochMilli } from '../dateUtils/epoch'\nimport { attachStringTag } from '../dateUtils/mixins'\nimport { tryParseDateTime } from '../dateUtils/parse'\nimport { translateDate } from '../dateUtils/translate'\nimport { DAY, DateUnitInt, YEAR } from '../dateUtils/units'\nimport { computeWeekOfISOYear } from '../dateUtils/week'\nimport { createWeakMap } from '../utils/obj'\nimport { Duration, DurationArg, createDuration } from './duration'\nimport { PlainDate, PlainDateArg } from './plainDate'\nimport { PlainMonthDay } from './plainMonthDay'\nimport { PlainYearMonth } from './plainYearMonth'\n\n// FYI: the Temporal.CalendarLike type includes `string`,\n// unlike many other object types\n\nconst [getImpl, setImpl] = createWeakMap<Calendar, CalendarImpl>()\n\nexport class Calendar extends AbstractObj implements Temporal.Calendar {\n  constructor(id: string) {\n    super()\n\n    if (id === 'islamicc') { // deprecated... TODO: use conversion map\n      id = 'islamic-civil'\n    }\n\n    setImpl(this, queryCalendarImpl(id))\n  }\n\n  static from(arg: Temporal.CalendarLike): Temporal.CalendarProtocol {\n    if (isObjectLike(arg)) {\n      return calendarFromObj(arg)\n    }\n\n    const parsed = tryParseDateTime(String(arg), false, true) // allowZ=true\n    return new Calendar(\n      parsed // a date-time string?\n        ? parsed.calendar || isoCalendarID\n        : String(arg), // any other type of string\n    )\n  }\n\n  get id(): string {\n    return this.toString()\n  }\n\n  era(\n    arg: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.PlainDateLike | string,\n  ): string | undefined {\n    const isoFields = getExistingDateISOFields(arg, true) // disallowMonthDay=true\n    return isoToEpochNanoSafe(\n      getImpl(this),\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n    ).era\n  }\n\n  eraYear(\n    arg: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.PlainDateLike | string,\n  ): number | undefined {\n    const isoFields = getExistingDateISOFields(arg, true) // disallowMonthDay=true\n    return isoToEpochNanoSafe(\n      getImpl(this),\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n    ).eraYear\n  }\n\n  year(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainDateLike\n    | string,\n  ): number {\n    const isoFields = getExistingDateISOFields(arg, true) // disallowMonthDay=true\n    return isoToEpochNanoSafe(\n      getImpl(this),\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n    ).year\n  }\n\n  month(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainMonthDay\n    | Temporal.PlainDateLike\n    | string,\n  ): number {\n    const isoFields = getExistingDateISOFields(arg, true) // disallowMonthDay=true\n    return isoToEpochNanoSafe(\n      getImpl(this),\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n    ).month\n  }\n\n  monthCode(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainMonthDay\n    | Temporal.PlainDateLike\n    | string,\n  ): string {\n    const fields = queryDateFields(arg, this)\n    return getImpl(this).monthCode(fields.month, fields.year)\n  }\n\n  day(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainMonthDay\n    | Temporal.PlainDateLike\n    | string,\n  ): number {\n    const isoFields = getExistingDateISOFields(arg)\n    return isoToEpochNanoSafe(\n      getImpl(this),\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n    ).day\n  }\n\n  dayOfWeek(\n    arg: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.PlainDateLike | string,\n  ): number {\n    const isoFields = getExistingDateISOFields(arg, true) // disallowMonthDay=true\n    return computeISODayOfWeek(isoFields.isoYear, isoFields.isoMonth, isoFields.isoDay)\n  }\n\n  dayOfYear(\n    arg: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.PlainDateLike | string,\n  ): number {\n    const fields = queryDateFields(arg, this, true) // disallowMonthDay=true\n    return computeDayOfYear(getImpl(this), fields.year, fields.month, fields.day)\n  }\n\n  weekOfYear(\n    arg: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.PlainDateLike | string,\n  ): number {\n    const isoFields = getExistingDateISOFields(arg, true) // disallowMonthDay=true\n    return computeWeekOfISOYear(\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n      1, // TODO: document what this means\n      4, // \"\n    )\n  }\n\n  daysInWeek(\n    arg: Temporal.PlainDate | Temporal.PlainDateTime | Temporal.PlainDateLike | string,\n  ): number {\n    // will throw error if invalid type\n    getExistingDateISOFields(arg, true) // disallowMonthDay=true\n\n    // All calendars seem to have 7-day weeks\n    return 7\n  }\n\n  daysInMonth(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainDateLike\n    | string,\n  ): number {\n    const fields = queryDateFields(arg, this, true) // disallowMonthDay=true\n    return getImpl(this).daysInMonth(fields.year, fields.month)\n  }\n\n  daysInYear(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainDateLike\n    | string,\n  ): number {\n    const fields = queryDateFields(arg, this, true) // disallowMonthDay=true\n    return computeDaysInYear(getImpl(this), fields.year)\n  }\n\n  monthsInYear(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainDateLike\n    | string,\n  ): number {\n    const calFields = queryDateFields(arg, this, true) // disallowMonthDay=true\n    return getImpl(this).monthsInYear(calFields.year)\n  }\n\n  inLeapYear(\n    arg:\n    | Temporal.PlainDate\n    | Temporal.PlainDateTime\n    | Temporal.PlainYearMonth\n    | Temporal.PlainDateLike\n    | string,\n  ): boolean {\n    return getImpl(this).inLeapYear(this.year(arg))\n  }\n\n  dateFromFields(\n    fields: Temporal.YearOrEraAndEraYear & Temporal.MonthOrMonthCode & { day: number },\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainDate {\n    const refinedFields = refineFields(fields, dateFieldMap)\n    const isoFields = queryDateISOFields(refinedFields, getImpl(this), options)\n\n    return new PlainDate(\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n      this,\n    )\n  }\n\n  yearMonthFromFields(\n    fields: Temporal.YearOrEraAndEraYear & Temporal.MonthOrMonthCode,\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainYearMonth {\n    const refinedFields = refineFields(fields, yearMonthFieldMap)\n    const isoFields = queryDateISOFields({ ...refinedFields, day: 1 }, getImpl(this), options)\n\n    return new PlainYearMonth(\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      this,\n      isoFields.isoDay,\n    )\n  }\n\n  monthDayFromFields(\n    fields: Temporal.MonthCodeOrMonthAndYear & { day: number },\n    options?: Temporal.AssignmentOptions,\n  ): Temporal.PlainMonthDay {\n    const impl = getImpl(this)\n    let { era, eraYear, year, month, monthCode, day } = refineFields(fields, monthDayFieldMap)\n\n    if (day === undefined) {\n      throw new TypeError('required property \\'day\\' missing or undefined')\n    }\n\n    if (monthCode !== undefined) {\n      year = isoEpochLeapYear\n    } else if (era !== undefined && eraYear !== undefined) {\n      year = convertEraYear(impl.id, eraYear, era)\n    }\n\n    if (year === undefined) {\n      if (monthCode !== undefined) {\n        year = impl.guessYearForMonthDay(monthCode, day)\n      } else {\n        throw new TypeError('either year or monthCode required with month')\n      }\n    }\n\n    const isoFields = queryDateISOFields(\n      { year, month: month!, monthCode: monthCode!, day }, // HACKs!\n      impl,\n      options,\n    )\n\n    return new PlainMonthDay(\n      isoFields.isoMonth,\n      isoFields.isoDay,\n      this,\n      impl.normalizeISOYearForMonthDay(isoFields.isoYear),\n    )\n  }\n\n  dateAdd(\n    dateArg: PlainDateArg,\n    durationArg: DurationArg,\n    options?: Temporal.ArithmeticOptions,\n  ): Temporal.PlainDate {\n    const impl = getImpl(this)\n    const date = ensureObj(PlainDate, dateArg, options)\n    const duration = ensureObj(Duration, durationArg)\n    const overflowHandling = parseOverflowOption(options)\n    const isoFields = translateDate(date, duration, impl, overflowHandling)\n\n    return new PlainDate(\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n      this,\n    )\n  }\n\n  dateUntil(\n    dateArg0: PlainDateArg,\n    dateArg1: PlainDateArg,\n    options?: Temporal.DifferenceOptions<'year' | 'month' | 'week' | 'day'>,\n  ): Temporal.Duration {\n    const impl = getImpl(this)\n    const d0 = ensureObj(PlainDate, dateArg0)\n    const d1 = ensureObj(PlainDate, dateArg1)\n    const largestUnitStr = ensureOptionsObj(options).largestUnit\n    const largestUnit = largestUnitStr === 'auto'\n      ? DAY // TODO: util for this?\n      : parseUnit<DateUnitInt>(largestUnitStr, DAY, DAY, YEAR)\n\n    ensureCalendarsEqual(this, getCommonCalendar(d0, d1))\n\n    return createDuration(\n      diffDateFields(d0, d1, impl, largestUnit),\n    )\n  }\n\n  /*\n  Given a date-type's core field names, returns the field names that should be\n  given to Calendar::yearMonthFromFields/monthDayFromFields/dateFromFields\n  */\n  // TODO: for inFields, use Iterable<string>\n  fields(inFields: string[]): string[] {\n    return inFields.slice() // copy\n  }\n\n  /*\n  Given a date-instance, and fields to override, returns the fields that should be\n  given to Calendar::yearMonthFromFields/monthDayFromFields/dateFromFields\n  */\n  // TODO: use Record<string, unknown>\n  mergeFields(baseFields: any, additionalFields: any): any {\n    return mergeCalFields(baseFields, additionalFields)\n  }\n\n  toString(): string {\n    return getImpl(this).id\n  }\n}\n\n// mixins\nexport interface Calendar { [Symbol.toStringTag]: 'Temporal.Calendar' }\nattachStringTag(Calendar, 'Calendar')\n\nexport function createDefaultCalendar(): Calendar {\n  return new Calendar(isoCalendarID)\n}\n\n// TODO: better types?\nexport function mergeCalFields(baseFields: any, additionalFields: any): any {\n  const merged = { ...baseFields, ...additionalFields } as any\n\n  if (baseFields.year !== undefined) {\n    delete merged.era\n    delete merged.eraYear\n    delete merged.year\n\n    let anyAdditionalYear = false\n\n    if (additionalFields.era !== undefined || additionalFields.eraYear !== undefined) {\n      merged.era = additionalFields.era\n      merged.eraYear = additionalFields.eraYear\n      anyAdditionalYear = true\n    }\n    if (additionalFields.year !== undefined) {\n      merged.year = additionalFields.year\n      anyAdditionalYear = true\n    }\n    if (!anyAdditionalYear) {\n      merged.year = baseFields.year\n    }\n  }\n\n  if (baseFields.monthCode !== undefined) {\n    delete merged.monthCode\n    delete merged.month\n\n    let anyAdditionalMonth = false\n\n    if (additionalFields.month !== undefined) {\n      merged.month = additionalFields.month\n      anyAdditionalMonth = true\n    }\n    if (additionalFields.monthCode !== undefined) {\n      merged.monthCode = additionalFields.monthCode\n      anyAdditionalMonth = true\n    }\n    if (!anyAdditionalMonth) {\n      merged.monthCode = baseFields.monthCode\n    }\n  }\n\n  if (baseFields.day !== undefined) {\n    merged.day = additionalFields.day ?? baseFields.day\n  }\n\n  return merged\n}\n\n// utils\n\n// TODO: can we eliminate this now that it's checked in public date classes?\nfunction isoToEpochNanoSafe(\n  calendarImpl: CalendarImpl,\n  isoYear: number,\n  isoMonth: number,\n  isoDay: number,\n): CalendarImplFields {\n  const epochMilli = isoToEpochMilli(isoYear, isoMonth, isoDay)\n  checkEpochMilliBuggy(epochMilli, calendarImpl.id)\n  return calendarImpl.computeFields(epochMilli)\n}\n", "import { Temporal } from 'temporal-spec'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { ensureObj } from '../dateUtils/abstract'\nimport { Calendar, createDefaultCalendar } from '../public/calendar'\nimport { isObjectLike } from './refine'\n\n// TODO: move to argParse like timeZoneFromObj?\nexport function calendarFromObj(obj: any): Temporal.CalendarProtocol {\n  const innerCalendar = obj.calendar\n  if (innerCalendar === undefined) {\n    return obj\n  }\n  if (isObjectLike(innerCalendar) && innerCalendar.calendar === undefined) {\n    return innerCalendar as any\n  }\n  return new Calendar(innerCalendar)\n}\n\nexport function extractCalendar(input: any): Temporal.CalendarProtocol {\n  if (input.calendar === undefined) {\n    return createDefaultCalendar()\n  }\n  return ensureObj(Calendar, input.calendar)\n}\n\nexport function getCommonCalendar(\n  obj0: { calendar: Temporal.CalendarProtocol },\n  obj1: { calendar: Temporal.CalendarProtocol },\n): Temporal.CalendarProtocol {\n  const { calendar } = obj0\n  ensureCalendarsEqual(calendar, obj1.calendar)\n  return calendar\n}\n\nexport function getStrangerCalendar(\n  obj0: { calendar: Temporal.CalendarProtocol },\n  obj1: { calendar: Temporal.CalendarProtocol },\n): Temporal.CalendarProtocol {\n  const calendar0 = obj0.calendar\n  const calendar1 = obj1.calendar\n\n  if (calendar0.id === isoCalendarID) {\n    return calendar1\n  }\n  if (calendar1.id === isoCalendarID) {\n    return calendar0\n  }\n  if (calendar0.id !== calendar1.id) {\n    throw new RangeError('Non-ISO calendars incompatible')\n  }\n\n  return calendar0\n}\n\nexport function ensureCalendarsEqual(\n  calendar0: Temporal.CalendarProtocol,\n  calendar1: Temporal.CalendarProtocol,\n): void {\n  if (calendar0.toString() !== calendar1.toString()) {\n    throw new RangeError('Calendars must match')\n  }\n}\n", "import { Temporal } from 'temporal-spec'\nimport { getCommonCalendar } from '../argParse/calendar'\nimport { parseCalendarDisplayOption } from '../argParse/calendarDisplay'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { OVERFLOW_REJECT, parseOverflowOption } from '../argParse/overflowHandling'\nimport { AbstractISOObj, ensureObj } from '../dateUtils/abstract'\nimport { compareDateTimes } from '../dateUtils/compare'\nimport { constrainDateISO } from '../dateUtils/constrain'\nimport { zeroISOTimeFields } from '../dateUtils/dayAndTime'\nimport { diffDates } from '../dateUtils/diff'\nimport { processDateFromFields, processDateWithFields } from '../dateUtils/fromAndWith'\nimport { validateDate } from '../dateUtils/isoFieldValidation'\nimport { formatCalendarID, formatDateISO } from '../dateUtils/isoFormat'\nimport {\n  DateCalendarFields,\n  attachStringTag,\n  dateCalendarFields,\n  mixinCalendarFields,\n  mixinISOFields,\n} from '../dateUtils/mixins'\nimport { parseDateTime } from '../dateUtils/parse'\nimport { refineBaseObj } from '../dateUtils/parseRefine'\nimport { DAY, DateUnitInt, YEAR } from '../dateUtils/units'\nimport { createPlainFormatFactoryFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { Calendar, createDefaultCalendar } from './calendar'\nimport { Duration, DurationArg, createDuration } from './duration'\nimport { createDateTime } from './plainDateTime'\nimport { PlainTime, PlainTimeArg, ensureLooseTime } from './plainTime'\nimport { createYearMonth } from './plainYearMonth'\nimport { TimeZone } from './timeZone'\nimport { createZonedDateTimeFromFields } from './zonedDateTime'\n\nexport type PlainDateArg = Temporal.PlainDate | Temporal.PlainDateLike | string\n\n// inlined in the spec. not easy to get out\ntype ToZonedDateTimeOptions = Temporal.TimeZoneProtocol | string | {\n  timeZone: Temporal.TimeZoneLike\n  plainTime?: Temporal.PlainTime | Temporal.PlainTimeLike | string\n}\n\ntype DiffOptions = Temporal.DifferenceOptions<'year' | 'month' | 'week' | 'day'>\n\nexport class PlainDate extends AbstractISOObj<Temporal.PlainDateISOFields>\n  implements Temporal.PlainDate {\n  constructor(\n    isoYear: number,\n    isoMonth: number,\n    isoDay: number,\n    calendarArg: Temporal.CalendarLike = createDefaultCalendar(),\n  ) {\n    const constrained = constrainDateISO({ isoYear, isoMonth, isoDay }, OVERFLOW_REJECT)\n    const calendar = ensureObj(Calendar, calendarArg)\n\n    validateDate(constrained, calendar.toString())\n\n    super({\n      ...constrained,\n      calendar,\n    })\n  }\n\n  static from(arg: PlainDateArg, options?: Temporal.AssignmentOptions): Temporal.PlainDate {\n    parseOverflowOption(options) // unused, but need to validate, regardless of input type\n\n    if (arg instanceof PlainDate) {\n      return createDate(arg.getISOFields()) // optimization\n    }\n\n    if (typeof arg === 'object') {\n      return processDateFromFields(arg, options)\n    }\n\n    return createDate(refineBaseObj(parseDateTime(String(arg))))\n  }\n\n  static compare(a: PlainDateArg, b: PlainDateArg): Temporal.ComparisonResult {\n    return compareDateTimes(\n      ensureObj(PlainDate, a),\n      ensureObj(PlainDate, b),\n    )\n  }\n\n  with(fields: Temporal.PlainDateLike, options?: Temporal.AssignmentOptions): Temporal.PlainDate {\n    return processDateWithFields(this, fields, options)\n  }\n\n  withCalendar(calendarArg: Temporal.CalendarLike): Temporal.PlainDate {\n    const isoFields = this.getISOFields()\n    return new PlainDate(\n      isoFields.isoYear,\n      isoFields.isoMonth,\n      isoFields.isoDay,\n      calendarArg,\n    )\n  }\n\n  add(durationArg: DurationArg, options?: Temporal.ArithmeticOptions): Temporal.PlainDate {\n    return this.calendar.dateAdd(this, durationArg, options)\n  }\n\n  subtract(durationArg: DurationArg, options?: Temporal.ArithmeticOptions): Temporal.PlainDate {\n    return this.calendar.dateAdd(this, ensureObj(Duration, durationArg).negated(), options)\n  }\n\n  until(other: PlainDateArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainDates(\n      this,\n      ensureObj(PlainDate, other),\n      false,\n      options,\n    )\n  }\n\n  since(other: PlainDateArg, options?: DiffOptions): Temporal.Duration {\n    return diffPlainDates(\n      this,\n      ensureObj(PlainDate, other),\n      true,\n      options,\n    )\n  }\n\n  equals(other: PlainDateArg): boolean {\n    return !compareDateTimes(this, ensureObj(PlainDate, other))\n  }\n\n  toString(options?: Temporal.ShowCalendarOption): string {\n    const calendarDisplay = parseCalendarDisplayOption(options)\n    const fields = this.getISOFields()\n\n    return formatDateISO(fields) +\n      formatCalendarID(fields.calendar.toString(), calendarDisplay)\n  }\n\n  toZonedDateTime(options: ToZonedDateTimeOptions): Temporal.ZonedDateTime {\n    const refinedOptions = processToZonedDateTimeOptions(options)\n    const timeZone = ensureObj(TimeZone, refinedOptions.timeZone)\n    const plainTime = refinedOptions.plainTime === undefined\n      ? undefined\n      : ensureObj(PlainTime, refinedOptions.plainTime)\n\n    return createZonedDateTimeFromFields({\n      ...this.getISOFields(),\n      ...(plainTime ? plainTime.getISOFields() : zeroISOTimeFields),\n      timeZone,\n    })\n  }\n\n  toPlainDateTime(timeArg?: PlainTimeArg): Temporal.PlainDateTime {\n    return createDateTime({\n      ...this.getISOFields(),\n      ...ensureLooseTime(timeArg).getISOFields(),\n    })\n  }\n\n  toPlainYearMonth(): Temporal.PlainYearMonth {\n    return createYearMonth(this.getISOFields())\n  }\n\n  toPlainMonthDay(): Temporal.PlainMonthDay {\n    return this.calendar.monthDayFromFields(this)\n  }\n}\n\n// mixin\nexport interface PlainDate { [Symbol.toStringTag]: 'Temporal.PlainDate' }\nexport interface PlainDate extends DateCalendarFields { calendar: Temporal.CalendarProtocol }\nexport interface PlainDate extends ToLocaleStringMethods {}\nattachStringTag(PlainDate, 'PlainDate')\nmixinISOFields(PlainDate)\nmixinCalendarFields(PlainDate, dateCalendarFields)\nmixinLocaleStringMethods(PlainDate, createPlainFormatFactoryFactory({\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  weekday: undefined,\n}, {\n  hour: undefined,\n  minute: undefined,\n  second: undefined,\n}))\n\n// creation\nexport function createDate(isoFields: Temporal.PlainDateISOFields): PlainDate {\n  return new PlainDate(\n    isoFields.isoYear,\n    isoFields.isoMonth,\n    isoFields.isoDay,\n    isoFields.calendar,\n  )\n}\n\n// argument processing\nfunction processToZonedDateTimeOptions(\n  options?: ToZonedDateTimeOptions,\n): {\n    plainTime?: PlainTimeArg,\n    timeZone: Temporal.TimeZoneLike,\n  } {\n  let plainTime: PlainTimeArg | undefined\n  let timeZone: Temporal.TimeZoneLike | undefined\n\n  if (typeof options === 'string') {\n    timeZone = options\n  } else if (typeof options === 'object') {\n    if ((options as Temporal.TimeZoneProtocol).id !== undefined) {\n      timeZone = options as Temporal.TimeZoneProtocol\n    } else {\n      timeZone = options.timeZone\n      plainTime = (options as { plainTime?: PlainTimeArg }).plainTime\n    }\n    if (timeZone === undefined) {\n      throw new TypeError('Invalid timeZone argument')\n    }\n  } else {\n    throw new TypeError('Invalid options/timeZone argument')\n  }\n\n  return { plainTime, timeZone }\n}\n\nfunction diffPlainDates(\n  pd0: PlainDate,\n  pd1: PlainDate,\n  flip: boolean,\n  options: DiffOptions | undefined,\n): Duration {\n  return createDuration(\n    diffDates(\n      pd0,\n      pd1,\n      getCommonCalendar(pd0, pd1),\n      flip,\n      parseDiffOptions<Temporal.DateUnit, DateUnitInt>(options, DAY, DAY, DAY, YEAR),\n    ),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { parseDiffOptions } from '../argParse/diffOptions'\nimport { OVERFLOW_REJECT } from '../argParse/overflowHandling'\nimport { ensureOptionsObj, isObjectLike } from '../argParse/refine'\nimport { parseRoundingOptions } from '../argParse/roundingOptions'\nimport { AbstractNoValueObj, ensureObj } from '../dateUtils/abstract'\nimport { compareEpochObjs } from '../dateUtils/compare'\nimport { constrainDateTimeISO } from '../dateUtils/constrain'\nimport { diffEpochNanos } from '../dateUtils/diff'\nimport { negateDuration } from '../dateUtils/durationFields'\nimport { epochNanoSymbol, isoFieldsToEpochNano } from '../dateUtils/epoch'\nimport { validateInstant } from '../dateUtils/isoFieldValidation'\nimport { ComputedEpochFields, attachStringTag, mixinEpochFields } from '../dateUtils/mixins'\nimport { parseZonedDateTime } from '../dateUtils/parse'\nimport { roundEpochNano } from '../dateUtils/rounding'\nimport { translateEpochNano } from '../dateUtils/translate'\nimport {\n  HOUR,\n  NANOSECOND,\n  SECOND,\n  nanoInMicro,\n  nanoInMilli,\n  nanoInSecond,\n} from '../dateUtils/units'\nimport { createZonedFormatFactoryFactory } from '../native/intlFactory'\nimport { ToLocaleStringMethods, mixinLocaleStringMethods } from '../native/intlMixins'\nimport { LargeInt, LargeIntArgStrict, createLargeInt } from '../utils/largeInt'\nimport { Duration, createDuration } from './duration'\nimport { ZonedDateTime } from './zonedDateTime'\n\nexport type InstantArg = Temporal.Instant | string\n\ntype TranslateArg = Omit<\nTemporal.Duration | Temporal.DurationLike,\n'years' | 'months' | 'weeks' | 'days'\n> | string\n\ntype DiffOptions = Temporal.DifferenceOptions<\n'hour' | 'minute' | 'second' | 'millisecond' | 'microsecond' | 'nanosecond'\n>\n\ntype RoundOptions = Temporal.RoundTo<\n'hour' | 'minute' | 'second' |\n'millisecond' | 'microsecond' | 'nanosecond'\n>\n\ntype ToZonedDateTimeOptions = {\n  timeZone: Temporal.TimeZoneLike\n  calendar: Temporal.CalendarLike\n}\n\nexport interface Instant {\n  [epochNanoSymbol]: LargeInt\n}\nexport class Instant extends AbstractNoValueObj implements Temporal.Instant {\n  constructor(epochNanoseconds: LargeIntArgStrict) {\n    super()\n    const epochNano = createLargeInt(epochNanoseconds, true) // strict=true\n    validateInstant(epochNano)\n    this[epochNanoSymbol] = epochNano\n  }\n\n  static from(arg: InstantArg): Instant { // okay to have return-type be Instant? needed\n    if (arg instanceof Instant) {\n      return new Instant(arg.epochNanoseconds)\n    }\n\n    const fields = parseZonedDateTime(String(arg))\n    const offsetNano = fields.offsetNanoseconds\n    if (offsetNano === undefined) {\n      throw new RangeError('Must specify an offset')\n    }\n\n    return new Instant(\n      isoFieldsToEpochNano(constrainDateTimeISO(fields, OVERFLOW_REJECT))\n        .sub(offsetNano),\n    )\n  }\n\n  static fromEpochSeconds(epochSeconds: number): Temporal.Instant {\n    return new Instant(createLargeInt(epochSeconds).mult(nanoInSecond))\n  }\n\n  static fromEpochMilliseconds(epochMilliseconds: number): Temporal.Instant {\n    return new Instant(createLargeInt(epochMilliseconds).mult(nanoInMilli))\n  }\n\n  static fromEpochMicroseconds(epochMicroseconds: bigint): Temporal.Instant {\n    return new Instant(epochMicroseconds * BigInt(nanoInMicro))\n  }\n\n  static fromEpochNanoseconds(epochNanoseconds: bigint): Temporal.Instant {\n    return new Instant(epochNanoseconds)\n  }\n\n  static compare(a: InstantArg, b: InstantArg): Temporal.ComparisonResult {\n    return compareEpochObjs(\n      ensureObj(Instant, a),\n      ensureObj(Instant, b),\n    )\n  }\n\n  add(durationArg: TranslateArg): Temporal.Instant {\n    return new Instant(\n      translateEpochNano(this[epochNanoSymbol], ensureObj(Duration, durationArg)),\n    )\n  }\n\n  subtract(durationArg: TranslateArg): Temporal.Instant {\n    return new Instant(\n      translateEpochNano(this[epochNanoSymbol], negateDuration(ensureObj(Duration, durationArg))),\n    )\n  }\n\n  until(other: InstantArg, options?: DiffOptions): Temporal.Duration {\n    return diffInstants(this, ensureObj(Instant, other), options)\n  }\n\n  since(other: InstantArg, options?: DiffOptions): Temporal.Duration {\n    return diffInstants(ensureObj(Instant, other), this, options)\n  }\n\n  round(options: RoundOptions): Temporal.Instant {\n    const roundingConfig = parseRoundingOptions(options, NANOSECOND, HOUR, true)\n\n    return new Instant(\n      roundEpochNano(this[epochNanoSymbol], roundingConfig),\n    )\n  }\n\n  equals(other: InstantArg): boolean {\n    return !compareEpochObjs(this, ensureObj(Instant, other))\n  }\n\n  toString(options?: Temporal.InstantToStringOptions): string {\n    const timeZoneArg = ensureOptionsObj(options).timeZone\n    const zonedDateTime = this.toZonedDateTimeISO(timeZoneArg ?? 'UTC') // TODO: don't use util!!!\n    return zonedDateTime.toString({\n      ...options,\n      offset: timeZoneArg === undefined ? 'never' : 'auto',\n      timeZoneName: 'never',\n    }) + (timeZoneArg === undefined ? 'Z' : '')\n  }\n\n  toZonedDateTimeISO(timeZoneArg: Temporal.TimeZoneLike): Temporal.ZonedDateTime {\n    return new ZonedDateTime(this.epochNanoseconds, timeZoneArg)\n  }\n\n  toZonedDateTime(options: ToZonedDateTimeOptions): Temporal.ZonedDateTime {\n    // TODO: more official options-processing utils for this\n    if (!isObjectLike(options)) {\n      throw new TypeError('Must specify options')\n    } else if (options.calendar === undefined) {\n      throw new TypeError('Must specify a calendar')\n    } else if (options.timeZone === undefined) {\n      throw new TypeError('Must specify a timeZone')\n    }\n\n    return new ZonedDateTime(\n      this.epochNanoseconds,\n      options.timeZone,\n      options.calendar,\n    )\n  }\n}\n\n// mixins\nexport interface Instant { [Symbol.toStringTag]: 'Temporal.Instant' }\nexport interface Instant extends ComputedEpochFields {}\nexport interface Instant extends ToLocaleStringMethods {}\nattachStringTag(Instant, 'Instant')\nmixinEpochFields(Instant)\nmixinLocaleStringMethods(Instant, createZonedFormatFactoryFactory({\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  weekday: undefined,\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit',\n}, {\n  timeZoneName: undefined,\n}, {}))\n\nfunction diffInstants(\n  inst0: Instant,\n  inst1: Instant,\n  options: DiffOptions | undefined,\n): Duration {\n  const diffConfig = parseDiffOptions(\n    options,\n    SECOND,\n    NANOSECOND,\n    NANOSECOND,\n    HOUR,\n  )\n\n  return createDuration(\n    diffEpochNanos(inst0[epochNanoSymbol], inst1[epochNanoSymbol], diffConfig),\n  )\n}\n", "import { Temporal } from 'temporal-spec'\nimport { Instant } from '../public/instant'\n\n// types\n\nexport interface DateTemporalMethods {\n  toTemporalInstant(): Instant\n}\n\nexport type DateWithTemporal = Date & DateTemporalMethods\n\n// implementation\n\nexport function toTemporalInstant(this: Date): Temporal.Instant {\n  return Instant.fromEpochMilliseconds(this.valueOf())\n}\n", "import { Intl as IntlSpec } from 'temporal-spec'\nimport { CachedFormatFactory, FormatFactoryFactory, buildCachedFormatFactory } from './intlFactory'\nimport { extractFormatFactoryFactory } from './intlMixins'\nimport { LocalesArg, flattenOptions, normalizeAndCopyLocalesArg } from './intlUtils'\n\ntype DateArg = IntlSpec.Formattable | number\n\nconst origLocalesSymbol = Symbol()\nconst origOptionsSymbol = Symbol()\nconst factoryMapSymbol = Symbol()\n\n/*\nWe can't monkeypatch Intl.DateTimeFormat because this auto-bound .format would be inaccessible\nto our override method.\n\nTODO: accept timeZone and calendar OBJECTS in options\n*/\ninterface _DateTimeFormat {\n  [origLocalesSymbol]: string[]\n  [origOptionsSymbol]: Intl.DateTimeFormatOptions\n  [factoryMapSymbol]: Map<FormatFactoryFactory<any>, CachedFormatFactory<any>>\n}\nclass _DateTimeFormat extends Intl.DateTimeFormat {\n  constructor(localesArg?: LocalesArg, options?: IntlSpec.DateTimeFormatOptions) {\n    const normLocales = normalizeAndCopyLocalesArg(localesArg)\n    const normOptions = flattenOptions(options || {}) // so that props aren't accessed again\n\n    super(normLocales, normOptions)\n\n    this[origLocalesSymbol] = normLocales\n    this[origOptionsSymbol] = normOptions\n    this[factoryMapSymbol] = new Map()\n  }\n\n  format(dateArg?: DateArg): string {\n    const parts = createSingleArgs(this, dateArg)\n\n    // HACK to overcome .format being bounded\n    // See NOTE here: https://tc39.es/ecma402/#sec-intl.datetimeformat.prototype.format\n    if (parts[0] === this) {\n      return super.format(parts[1])\n    }\n\n    return parts[0].format(parts[1])\n  }\n\n  formatToParts(dateArg?: DateArg): Intl.DateTimeFormatPart[] {\n    return super.formatToParts.call(...createSingleArgs(this, dateArg))\n  }\n\n  formatRange<T extends IntlSpec.Formattable>(\n    startArg: T,\n    endArg: T,\n  ): string {\n    return super.formatRange.call(...createRangeArgs(this, startArg, endArg))\n  }\n\n  formatRangeToParts<T extends IntlSpec.Formattable>(\n    startArg: T,\n    endArg: T,\n  ): IntlSpec.DateTimeFormatRangePart[] {\n    return super.formatRangeToParts.call(\n      ...createRangeArgs(this, startArg, endArg),\n    ) as IntlSpec.DateTimeFormatRangePart[]\n  }\n}\n\n// compliance with globalThis.Intl.DateTimeFormat\nexport const DateTimeFormat = _DateTimeFormat as ((typeof _DateTimeFormat) & {\n  // constructor without `new`. this comes for free\n  (locales?: string | string[], options?: IntlSpec.DateTimeFormatOptions): _DateTimeFormat;\n\n  // retrofitted to accept better DateTimeFormatOptions\n  // TODO: implement this!?\n  supportedLocalesOf(\n    locales: string | string[],\n    options?: IntlSpec.DateTimeFormatOptions\n  ): string[];\n})\n\nfunction createSingleArgs(\n  origDateTimeFormat: _DateTimeFormat,\n  dateArg: DateArg | undefined,\n): [Intl.DateTimeFormat, Date | number | undefined] {\n  const buildFormatFactory = extractFormatFactoryFactory(dateArg)\n\n  if (buildFormatFactory) {\n    const formatFactory = queryFormatFactoryForType(origDateTimeFormat, buildFormatFactory)\n    return [\n      formatFactory.buildFormat(dateArg),\n      formatFactory.buildEpochMilli(dateArg),\n    ]\n  }\n\n  return [origDateTimeFormat, dateArg as (Date | undefined)]\n}\n\nfunction createRangeArgs(\n  origDateTimeFormat: _DateTimeFormat,\n  startArg: IntlSpec.Formattable,\n  endArg: IntlSpec.Formattable,\n): [Intl.DateTimeFormat, Date, Date] {\n  const buildFormatFactory = extractFormatFactoryFactory(startArg)\n  const buildFormatFactoryOther = extractFormatFactoryFactory(endArg)\n\n  if (buildFormatFactory !== buildFormatFactoryOther) {\n    throw new TypeError('Mismatch of types')\n  }\n\n  if (buildFormatFactory) {\n    const formatFactory = queryFormatFactoryForType(origDateTimeFormat, buildFormatFactory)\n    return [\n      formatFactory.buildFormat(startArg, endArg),\n      new Date(formatFactory.buildEpochMilli(startArg)), // TODO: sure it needs to be Date?\n      new Date(formatFactory.buildEpochMilli(endArg)), // \"\n    ]\n  }\n\n  return [origDateTimeFormat, startArg as Date, endArg as Date]\n}\n\nfunction queryFormatFactoryForType<Entity>(\n  origDateTimeFormat: _DateTimeFormat,\n  buildFormatFactory: FormatFactoryFactory<Entity>,\n): CachedFormatFactory<Entity> {\n  const formatFactoryMap = origDateTimeFormat[factoryMapSymbol]\n  let formatFactory = formatFactoryMap.get(buildFormatFactory)\n\n  if (!formatFactory) {\n    formatFactory = buildCachedFormatFactory(\n      buildFormatFactory(\n        origDateTimeFormat[origLocalesSymbol],\n        origDateTimeFormat[origOptionsSymbol],\n      ),\n    )\n    formatFactoryMap.set(buildFormatFactory, formatFactory)\n  }\n\n  return formatFactory\n}\n", "import { Temporal } from 'temporal-spec'\nimport { isoCalendarID } from '../calendarImpl/isoCalendarImpl'\nimport { ensureObj } from '../dateUtils/abstract'\nimport { ISODateTimeFields } from '../dateUtils/isoFields'\nimport { attachStringTag } from '../dateUtils/mixins'\nimport { nanoInMilli } from '../dateUtils/units'\nimport { OrigDateTimeFormat } from '../native/intlUtils'\nimport { LargeInt, createLargeInt } from '../utils/largeInt'\nimport { Calendar } from './calendar'\nimport { Instant } from './instant'\nimport { createDate } from './plainDate'\nimport { createDateTime } from './plainDateTime'\nimport { createTime } from './plainTime'\nimport { TimeZone } from './timeZone'\nimport {\n  buildZonedDateTimeISOFields,\n  createZonedDateTimeFromFields,\n} from './zonedDateTime'\n\nconst _Now = {\n  zonedDateTimeISO: getZonedDateTimeISO,\n  zonedDateTime: getZonedDateTime,\n  plainDateTimeISO: getPlainDateTimeISO,\n  plainDateTime: getPlainDateTime,\n  plainDateISO: getPlainDateISO,\n  plainDate: getPlainDate,\n  plainTimeISO: getPlainTimeISO,\n  instant: getInstant,\n  timeZone: getTimeZone,\n}\n\nattachStringTag(_Now, 'Now')\n\nexport const Now = _Now as (typeof _Now & { [Symbol.toStringTag]: 'Temporal.Now' })\n\nfunction getZonedDateTimeISO(timeZoneArg?: Temporal.TimeZoneLike): Temporal.ZonedDateTime {\n  return createZonedDateTimeFromFields(buidZonedFields(isoCalendarID, timeZoneArg))\n}\n\nfunction getZonedDateTime(\n  calendarArg: Temporal.CalendarLike,\n  timeZoneArg?: Temporal.TimeZoneLike,\n): Temporal.ZonedDateTime {\n  return createZonedDateTimeFromFields(buidZonedFields(calendarArg, timeZoneArg))\n}\n\nfunction getPlainDateTimeISO(timeZoneArg?: Temporal.TimeZoneLike): Temporal.PlainDateTime {\n  return createDateTime(buidZonedFields(isoCalendarID, timeZoneArg))\n}\n\nfunction getPlainDateTime(\n  calendarArg: Temporal.CalendarLike,\n  timeZoneArg?: Temporal.TimeZoneLike,\n): Temporal.PlainDateTime {\n  return createDateTime(buidZonedFields(calendarArg, timeZoneArg))\n}\n\nfunction getPlainDateISO(timeZoneArg?: Temporal.TimeZoneLike): Temporal.PlainDate {\n  return createDate(buidZonedFields(isoCalendarID, timeZoneArg))\n}\n\nfunction getPlainDate(\n  calendarArg: Temporal.CalendarLike,\n  timeZoneArg?: Temporal.TimeZoneLike,\n): Temporal.PlainDate {\n  return createDate(buidZonedFields(calendarArg, timeZoneArg))\n}\n\nfunction getPlainTimeISO(timeZoneArg?: Temporal.TimeZoneLike): Temporal.PlainTime {\n  return createTime(buidZonedFields(isoCalendarID, timeZoneArg))\n}\n\nfunction getInstant(): Temporal.Instant {\n  return new Instant(getEpochNano())\n}\n\nfunction getTimeZone(): Temporal.TimeZone {\n  return new TimeZone(new OrigDateTimeFormat().resolvedOptions().timeZone)\n}\n\n// utils\n\nfunction buidZonedFields(\n  calendarArg: Temporal.CalendarLike,\n  timeZoneArg: Temporal.TimeZoneLike = getTimeZone(),\n): ISODateTimeFields & {\n    timeZone: Temporal.TimeZoneProtocol,\n    calendar: Temporal.CalendarProtocol,\n  } {\n  const timeZone = ensureObj(TimeZone, timeZoneArg)\n  return {\n    ...buildZonedDateTimeISOFields(getEpochNano(), timeZone)[0],\n    // build these in to buildZonedDateTimeISOFields?\n    timeZone,\n    calendar: ensureObj(Calendar, calendarArg),\n  }\n}\n\nfunction getEpochNano(): LargeInt {\n  return createLargeInt(Date.now()).mult(nanoInMilli)\n}\n", "\nimport { Calendar } from './calendar'\nimport { Duration } from './duration'\nimport { Instant } from './instant'\nimport { Now } from './now'\nimport { PlainDate } from './plainDate'\nimport { PlainDateTime } from './plainDateTime'\nimport { PlainMonthDay } from './plainMonthDay'\nimport { PlainTime } from './plainTime'\nimport { PlainYearMonth } from './plainYearMonth'\nimport { TimeZone } from './timeZone'\nimport { ZonedDateTime } from './zonedDateTime'\n\nexport const Temporal = {\n  PlainYearMonth,\n  PlainMonthDay,\n  PlainDate,\n  PlainTime,\n  PlainDateTime,\n  ZonedDateTime,\n  Instant,\n  Calendar,\n  TimeZone,\n  Duration,\n  Now,\n  [Symbol.toStringTag]: 'Temporal', // TODO: make readonly, dry with attachStringTag?\n}\n", "\ndeclare const window: any\n\n// BAD because `any`\n// TODO: make this variaible available as part of intro/outro that wraps everything\nexport function getGlobalThis(): any {\n  return typeof globalThis !== 'undefined' ? globalThis : window\n}\n", "export * from 'temporal-spec'\n", "import { Temporal } from 'temporal-polyfill';\n\nexport function isOlderThan(date: Date, hours: number | string): boolean {\n\tconst convertedDate = Temporal.PlainDateTime.from({\n\t\tyear: date.getFullYear(),\n\t\tmonth: date.getMonth() + 1,\n\t\tday: date.getDate(),\n\t\thour: date.getHours(),\n\t\tminute: date.getMinutes(),\n\t\tsecond: date.getSeconds(),\n\t\tmillisecond: date.getMilliseconds(),\n\t});\n\n\tconst now = Temporal.Now.plainDateTimeISO();\n\tconst diffInHours = now.since(convertedDate, { largestUnit: 'hours' }).hours;\n\treturn diffInHours >= Number(hours);\n}\n", "import { isOlderThan } from './isOlderThan';\n\nexport const RECORDS_BATCH_SIZE = 500;\n\nfunction R2KeysForDeletion() {\n\tlet keys: string[] = [];\n\treturn {\n\t\tadd: function (key: string) {\n\t\t\tkeys.push(key);\n\t\t},\n\t\tgetKeys: function () {\n\t\t\treturn keys;\n\t\t},\n\t};\n}\n\nasync function deleteKeys(env: Env, keysForDeletion: ReturnType<typeof R2KeysForDeletion>) {\n\tif (keysForDeletion.getKeys().length > 0) {\n\t\tawait env.R2_STORE.delete(keysForDeletion.getKeys());\n\t}\n}\n\nasync function processList(list: R2Objects, env: Env) {\n\tconst keysForDeletion = R2KeysForDeletion();\n\tfor (const object of list.objects) {\n\t\tif (isOlderThan(object.uploaded, env.EXPIRATION_HOURS)) {\n\t\t\tkeysForDeletion.add(object.key);\n\t\t}\n\t}\n\n\tawait deleteKeys(env, keysForDeletion);\n}\n\nexport async function deleteOldCache(env: Env, cursor?: string) {\n\tconst list = await env.R2_STORE.list({ limit: RECORDS_BATCH_SIZE, cursor });\n\tawait processList(list, env);\n\n\tif (list.truncated) {\n\t\tawait deleteOldCache(env, list.cursor);\n\t}\n}\n", "// src/utils/url.ts\nvar splitPath = (path) => {\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  return paths;\n};\nvar splitRoutingPath = (path) => {\n  const groups = [];\n  for (let i = 0; ; ) {\n    let replaced = false;\n    path = path.replace(/\\{[^}]+\\}/g, (m) => {\n      const mark = `@\\\\${i}`;\n      groups[i] = [mark, m];\n      i++;\n      replaced = true;\n      return mark;\n    });\n    if (!replaced) {\n      break;\n    }\n  }\n  const paths = path.split(\"/\");\n  if (paths[0] === \"\") {\n    paths.shift();\n  }\n  for (let i = groups.length - 1; i >= 0; i--) {\n    const [mark] = groups[i];\n    for (let j = paths.length - 1; j >= 0; j--) {\n      if (paths[j].indexOf(mark) !== -1) {\n        paths[j] = paths[j].replace(mark, groups[i][1]);\n        break;\n      }\n    }\n  }\n  return paths;\n};\nvar patternCache = {};\nvar getPattern = (label) => {\n  if (label === \"*\") {\n    return \"*\";\n  }\n  const match = label.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n  if (match) {\n    if (!patternCache[label]) {\n      if (match[2]) {\n        patternCache[label] = [label, match[1], new RegExp(\"^\" + match[2] + \"$\")];\n      } else {\n        patternCache[label] = [label, match[1], true];\n      }\n    }\n    return patternCache[label];\n  }\n  return null;\n};\nvar getPath = (request) => {\n  const match = request.url.match(/^https?:\\/\\/[^/]+(\\/[^?]*)/);\n  return match ? match[1] : \"\";\n};\nvar getQueryStrings = (url) => {\n  const queryIndex = url.indexOf(\"?\", 8);\n  return queryIndex === -1 ? \"\" : \"?\" + url.slice(queryIndex + 1);\n};\nvar getPathNoStrict = (request) => {\n  const result = getPath(request);\n  return result.length > 1 && result[result.length - 1] === \"/\" ? result.slice(0, -1) : result;\n};\nvar mergePath = (...paths) => {\n  let p = \"\";\n  let endsWithSlash = false;\n  for (let path of paths) {\n    if (p[p.length - 1] === \"/\") {\n      p = p.slice(0, -1);\n      endsWithSlash = true;\n    }\n    if (path[0] !== \"/\") {\n      path = `/${path}`;\n    }\n    if (path === \"/\" && endsWithSlash) {\n      p = `${p}/`;\n    } else if (path !== \"/\") {\n      p = `${p}${path}`;\n    }\n    if (path === \"/\" && p === \"\") {\n      p = \"/\";\n    }\n  }\n  return p;\n};\nvar checkOptionalParameter = (path) => {\n  const match = path.match(/^(.+|)(\\/\\:[^\\/]+)\\?$/);\n  if (!match)\n    return null;\n  const base = match[1];\n  const optional = base + match[2];\n  return [base === \"\" ? \"/\" : base.replace(/\\/$/, \"\"), optional];\n};\nvar _decodeURI = (value) => {\n  if (!/[%+]/.test(value)) {\n    return value;\n  }\n  if (value.indexOf(\"+\") !== -1) {\n    value = value.replace(/\\+/g, \" \");\n  }\n  return /%/.test(value) ? decodeURIComponent_(value) : value;\n};\nvar _getQueryParam = (url, key, multiple) => {\n  let encoded;\n  if (!multiple && key && !/[%+]/.test(key)) {\n    let keyIndex2 = url.indexOf(`?${key}`, 8);\n    if (keyIndex2 === -1) {\n      keyIndex2 = url.indexOf(`&${key}`, 8);\n    }\n    while (keyIndex2 !== -1) {\n      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);\n      if (trailingKeyCode === 61) {\n        const valueIndex = keyIndex2 + key.length + 2;\n        const endIndex = url.indexOf(\"&\", valueIndex);\n        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? void 0 : endIndex));\n      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {\n        return \"\";\n      }\n      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);\n    }\n    encoded = /[%+]/.test(url);\n    if (!encoded) {\n      return void 0;\n    }\n  }\n  const results = {};\n  encoded ?? (encoded = /[%+]/.test(url));\n  let keyIndex = url.indexOf(\"?\", 8);\n  while (keyIndex !== -1) {\n    const nextKeyIndex = url.indexOf(\"&\", keyIndex + 1);\n    let valueIndex = url.indexOf(\"=\", keyIndex);\n    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {\n      valueIndex = -1;\n    }\n    let name = url.slice(\n      keyIndex + 1,\n      valueIndex === -1 ? nextKeyIndex === -1 ? void 0 : nextKeyIndex : valueIndex\n    );\n    if (encoded) {\n      name = _decodeURI(name);\n    }\n    keyIndex = nextKeyIndex;\n    if (name === \"\") {\n      continue;\n    }\n    let value;\n    if (valueIndex === -1) {\n      value = \"\";\n    } else {\n      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? void 0 : nextKeyIndex);\n      if (encoded) {\n        value = _decodeURI(value);\n      }\n    }\n    if (multiple) {\n      ;\n      (results[name] ?? (results[name] = [])).push(value);\n    } else {\n      results[name] ?? (results[name] = value);\n    }\n  }\n  return key ? results[key] : results;\n};\nvar getQueryParam = _getQueryParam;\nvar getQueryParams = (url, key) => {\n  return _getQueryParam(url, key, true);\n};\nvar decodeURIComponent_ = decodeURIComponent;\nexport {\n  checkOptionalParameter,\n  decodeURIComponent_,\n  getPath,\n  getPathNoStrict,\n  getPattern,\n  getQueryParam,\n  getQueryParams,\n  getQueryStrings,\n  mergePath,\n  splitPath,\n  splitRoutingPath\n};\n", "// src/utils/cookie.ts\nimport { decodeURIComponent_ } from \"./url.js\";\nvar makeSignature = async (value, secret) => {\n  const algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\n  const encoder = new TextEncoder();\n  const key = await crypto.subtle.importKey(\"raw\", encoder.encode(secret), algorithm, false, [\n    \"sign\",\n    \"verify\"\n  ]);\n  const signature = await crypto.subtle.sign(algorithm.name, key, encoder.encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar _parseCookiePairs = (cookie, name) => {\n  const pairs = cookie.split(/;\\s*/g);\n  const cookiePairs = pairs.map((pairStr) => pairStr.split(/\\s*=\\s*([^\\s]+)/));\n  if (!name)\n    return cookiePairs;\n  return cookiePairs.filter((pair) => pair[0] === name);\n};\nvar parse = (cookie, name) => {\n  const parsedCookie = {};\n  const unsignedCookies = _parseCookiePairs(cookie, name).filter((pair) => {\n    const valueSplit = pair[1].split(\".\");\n    const signature = valueSplit[1] ? decodeURIComponent_(valueSplit[1]) : void 0;\n    if (valueSplit.length === 2 && signature && signature.length === 44 && signature.endsWith(\"=\")) {\n      return false;\n    }\n    return true;\n  });\n  for (let [key, value] of unsignedCookies) {\n    value = decodeURIComponent_(value);\n    parsedCookie[key] = value;\n  }\n  return parsedCookie;\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const signedCookies = _parseCookiePairs(cookie, name).filter((pair) => {\n    const valueSplit = pair[1].split(\".\");\n    const signature = valueSplit[1] ? decodeURIComponent_(valueSplit[1]) : void 0;\n    if (valueSplit.length !== 2 || !signature || signature.length !== 44 || !signature.endsWith(\"=\")) {\n      console.log(\"VALUE SPLIT\", valueSplit);\n      return false;\n    }\n    return true;\n  });\n  for (let [key, value] of signedCookies) {\n    value = decodeURIComponent_(value);\n    const signedPair = value.split(\".\");\n    const signatureToCompare = await makeSignature(signedPair[0], secret);\n    if (signedPair[1] !== signatureToCompare) {\n      parsedCookie[key] = false;\n      continue;\n    }\n    parsedCookie[key] = signedPair[0];\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain) {\n    cookie += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    cookie += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    cookie += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite}`;\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt = {}) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nexport {\n  parse,\n  parseSigned,\n  serialize,\n  serializeSigned\n};\n", "// src/helper/cookie/index.ts\nimport { parse, parseSigned, serialize, serializeSigned } from \"../../utils/cookie.js\";\nvar getCookie = (c, key) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie)\n      return void 0;\n    const obj2 = parse(cookie);\n    return obj2[key];\n  }\n  if (!cookie)\n    return {};\n  const obj = parse(cookie);\n  return obj;\n};\nvar getSignedCookie = async (c, secret, key) => {\n  const cookie = c.req.raw.headers.get(\"Cookie\");\n  if (typeof key === \"string\") {\n    if (!cookie)\n      return void 0;\n    const obj2 = await parseSigned(cookie, secret, key);\n    return obj2[key];\n  }\n  if (!cookie)\n    return {};\n  const obj = await parseSigned(cookie, secret);\n  return obj;\n};\nvar setCookie = (c, name, value, opt) => {\n  const cookie = serialize(name, value, opt);\n  c.header(\"set-cookie\", cookie, { append: true });\n};\nvar setSignedCookie = async (c, name, value, secret, opt) => {\n  const cookie = await serializeSigned(name, value, secret, opt);\n  c.header(\"set-cookie\", cookie, { append: true });\n};\nvar deleteCookie = (c, name, opt) => {\n  setCookie(c, name, \"\", { ...opt, maxAge: 0 });\n};\nexport {\n  deleteCookie,\n  getCookie,\n  getSignedCookie,\n  setCookie,\n  setSignedCookie\n};\n", "// src/validator/validator.ts\nimport { getCookie } from \"../helper/cookie/index.js\";\nvar validator = (target, validationFunc) => {\n  return async (c, next) => {\n    let value = {};\n    switch (target) {\n      case \"json\":\n        try {\n          value = await c.req.json();\n        } catch {\n          console.error(\"Error: Malformed JSON in request body\");\n          return c.json(\n            {\n              success: false,\n              message: \"Malformed JSON in request body\"\n            },\n            400\n          );\n        }\n        break;\n      case \"form\":\n        value = await c.req.parseBody();\n        break;\n      case \"query\":\n        value = Object.fromEntries(\n          Object.entries(c.req.queries()).map(([k, v]) => {\n            return v.length === 1 ? [k, v[0]] : [k, v];\n          })\n        );\n        break;\n      case \"queries\":\n        value = c.req.queries();\n        console.log(\"Warnings: Validate type `queries` is deprecated. Use `query` instead.\");\n        break;\n      case \"param\":\n        value = c.req.param();\n        break;\n      case \"header\":\n        value = c.req.header();\n        break;\n      case \"cookie\":\n        value = getCookie(c);\n        break;\n    }\n    const res = await validationFunc(value, c);\n    if (res instanceof Response) {\n      return res;\n    }\n    c.req.addValidatedData(target, res);\n    await next();\n  };\n};\nexport {\n  validator\n};\n", "import { validator } from 'hono/validator';\nexport const zValidator = (target, schema, hook) => validator(target, (value, c) => {\n    const result = schema.safeParse(value);\n    if (hook) {\n        const hookResult = hook({ data: value, ...result }, c);\n        if (hookResult) {\n            if (hookResult instanceof Response || hookResult instanceof Promise) {\n                return hookResult;\n            }\n            if ('response' in hookResult) {\n                return hookResult.response;\n            }\n        }\n    }\n    if (!result.success) {\n        return c.json(result, 400);\n    }\n    const data = result.data;\n    return data;\n});\n", "// src/types.ts\nvar FetchEventLike = class {\n};\nexport {\n  FetchEventLike\n};\n", "// src/context.ts\nimport { FetchEventLike } from \"./types.js\";\nimport { serialize } from \"./utils/cookie.js\";\nvar Context = class {\n  constructor(req, options) {\n    this.env = {};\n    this.finalized = false;\n    this.error = void 0;\n    this._status = 200;\n    this._h = void 0;\n    this._pH = void 0;\n    this._init = true;\n    this.notFoundHandler = () => new Response();\n    this.header = (name, value, options) => {\n      if (value === void 0) {\n        if (this._h) {\n          this._h.delete(name);\n        } else if (this._pH) {\n          delete this._pH[name.toLocaleLowerCase()];\n        }\n        if (this.finalized) {\n          this.res.headers.delete(name);\n        }\n        return;\n      }\n      if (options?.append) {\n        if (!this._h) {\n          this._init = false;\n          this._h = new Headers(this._pH);\n          this._pH = {};\n        }\n        this._h.append(name, value);\n      } else {\n        if (this._h) {\n          this._h.set(name, value);\n        } else {\n          this._pH ?? (this._pH = {});\n          this._pH[name.toLowerCase()] = value;\n        }\n      }\n      if (this.finalized) {\n        if (options?.append) {\n          this.res.headers.append(name, value);\n        } else {\n          this.res.headers.set(name, value);\n        }\n      }\n    };\n    this.status = (status) => {\n      this._status = status;\n    };\n    this.set = (key, value) => {\n      this._map || (this._map = {});\n      this._map[key] = value;\n    };\n    this.get = (key) => {\n      return this._map ? this._map[key] : void 0;\n    };\n    this.newResponse = (data, arg, headers) => {\n      if (this._init && !headers && !arg && this._status === 200) {\n        return new Response(data, {\n          headers: this._pH\n        });\n      }\n      if (arg && typeof arg !== \"number\") {\n        const res = new Response(data, arg);\n        const contentType = this._pH?.[\"content-type\"];\n        if (contentType) {\n          res.headers.set(\"content-type\", contentType);\n        }\n        return res;\n      }\n      const status = arg ?? this._status;\n      this._pH ?? (this._pH = {});\n      this._h ?? (this._h = new Headers());\n      for (const [k, v] of Object.entries(this._pH)) {\n        this._h.set(k, v);\n      }\n      if (this._res) {\n        this._res.headers.forEach((v, k) => {\n          this._h?.set(k, v);\n        });\n        for (const [k, v] of Object.entries(this._pH)) {\n          this._h.set(k, v);\n        }\n      }\n      headers ?? (headers = {});\n      for (const [k, v] of Object.entries(headers)) {\n        if (typeof v === \"string\") {\n          this._h.set(k, v);\n        } else {\n          this._h.delete(k);\n          for (const v2 of v) {\n            this._h.append(k, v2);\n          }\n        }\n      }\n      return new Response(data, {\n        status,\n        headers: this._h\n      });\n    };\n    this.body = (data, arg, headers) => {\n      return typeof arg === \"number\" ? this.newResponse(data, arg, headers) : this.newResponse(data, arg);\n    };\n    this.text = (text, arg, headers) => {\n      if (!this._pH) {\n        if (this._init && !headers && !arg) {\n          return new Response(text);\n        }\n        this._pH = {};\n      }\n      if (this._pH[\"content-type\"]) {\n        this._pH[\"content-type\"] = \"text/plain; charset=UTF-8\";\n      }\n      return typeof arg === \"number\" ? this.newResponse(text, arg, headers) : this.newResponse(text, arg);\n    };\n    this.json = (object, arg, headers) => {\n      const body = JSON.stringify(object);\n      this._pH ?? (this._pH = {});\n      this._pH[\"content-type\"] = \"application/json; charset=UTF-8\";\n      return typeof arg === \"number\" ? this.newResponse(body, arg, headers) : this.newResponse(body, arg);\n    };\n    this.jsonT = (object, arg, headers) => {\n      return {\n        response: typeof arg === \"number\" ? this.json(object, arg, headers) : this.json(object, arg),\n        data: object,\n        format: \"json\"\n      };\n    };\n    this.html = (html, arg, headers) => {\n      this._pH ?? (this._pH = {});\n      this._pH[\"content-type\"] = \"text/html; charset=UTF-8\";\n      return typeof arg === \"number\" ? this.newResponse(html, arg, headers) : this.newResponse(html, arg);\n    };\n    this.redirect = (location, status = 302) => {\n      this._h ?? (this._h = new Headers());\n      this._h.set(\"Location\", location);\n      return this.newResponse(null, status);\n    };\n    this.cookie = (name, value, opt) => {\n      const cookie = serialize(name, value, opt);\n      this.header(\"set-cookie\", cookie, { append: true });\n    };\n    this.notFound = () => {\n      return this.notFoundHandler(this);\n    };\n    this.req = req;\n    if (options) {\n      this._exCtx = options.executionCtx;\n      this.env = options.env;\n      if (options.notFoundHandler) {\n        this.notFoundHandler = options.notFoundHandler;\n      }\n    }\n  }\n  get event() {\n    if (this._exCtx instanceof FetchEventLike) {\n      return this._exCtx;\n    } else {\n      throw Error(\"This context has no FetchEvent\");\n    }\n  }\n  get executionCtx() {\n    if (this._exCtx) {\n      return this._exCtx;\n    } else {\n      throw Error(\"This context has no ExecutionContext\");\n    }\n  }\n  get res() {\n    this._init = false;\n    return this._res || (this._res = new Response(\"404 Not Found\", { status: 404 }));\n  }\n  set res(_res) {\n    this._init = false;\n    if (this._res && _res) {\n      this._res.headers.delete(\"content-type\");\n      this._res.headers.forEach((v, k) => {\n        _res.headers.set(k, v);\n      });\n    }\n    this._res = _res;\n    this.finalized = true;\n  }\n  get runtime() {\n    const global = globalThis;\n    if (global?.Deno !== void 0) {\n      return \"deno\";\n    }\n    if (global?.Bun !== void 0) {\n      return \"bun\";\n    }\n    if (typeof global?.WebSocketPair === \"function\") {\n      return \"workerd\";\n    }\n    if (typeof global?.EdgeRuntime === \"string\") {\n      return \"edge-light\";\n    }\n    if (global?.fastly !== void 0) {\n      return \"fastly\";\n    }\n    if (global?.__lagon__ !== void 0) {\n      return \"lagon\";\n    }\n    if (global?.process?.release?.name === \"node\") {\n      return \"node\";\n    }\n    return \"other\";\n  }\n};\nexport {\n  Context\n};\n", "// src/compose.ts\nimport { Context } from \"./context.js\";\nvar compose = (middleware, onError, onNotFound) => {\n  const middlewareLength = middleware.length;\n  return (context, next) => {\n    let index = -1;\n    return dispatch(0);\n    function dispatch(i) {\n      if (i <= index) {\n        throw new Error(\"next() called multiple times\");\n      }\n      let handler = middleware[i];\n      index = i;\n      if (i === middlewareLength && next)\n        handler = next;\n      let res;\n      let isError = false;\n      if (!handler) {\n        if (context instanceof Context && context.finalized === false && onNotFound) {\n          res = onNotFound(context);\n        }\n      } else {\n        try {\n          res = handler(context, () => {\n            const dispatchRes = dispatch(i + 1);\n            return dispatchRes instanceof Promise ? dispatchRes : Promise.resolve(dispatchRes);\n          });\n        } catch (err) {\n          if (err instanceof Error && context instanceof Context && onError) {\n            context.error = err;\n            res = onError(err, context);\n            isError = true;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (!(res instanceof Promise)) {\n        if (res !== void 0 && \"response\" in res) {\n          res = res[\"response\"];\n        }\n        if (res && (context.finalized === false || isError)) {\n          context.res = res;\n        }\n        return context;\n      } else {\n        return res.then((res2) => {\n          if (res2 !== void 0 && \"response\" in res2) {\n            res2 = res2[\"response\"];\n          }\n          if (res2 && context.finalized === false) {\n            context.res = res2;\n          }\n          return context;\n        }).catch(async (err) => {\n          if (err instanceof Error && context instanceof Context && onError) {\n            context.error = err;\n            context.res = await onError(err, context);\n            return context;\n          }\n          throw err;\n        });\n      }\n    }\n  };\n};\nexport {\n  compose\n};\n", "// src/http-exception.ts\nvar HTTPException = class extends Error {\n  constructor(status = 500, options) {\n    super(options?.message);\n    this.res = options?.res;\n    this.status = status;\n  }\n  getResponse() {\n    if (this.res) {\n      return this.res;\n    }\n    return new Response(this.message, {\n      status: this.status\n    });\n  }\n};\nexport {\n  HTTPException\n};\n", "// src/utils/body.ts\nvar parseBody = async (r) => {\n  let body = {};\n  const contentType = r.headers.get(\"Content-Type\");\n  if (contentType && (contentType.startsWith(\"multipart/form-data\") || contentType.startsWith(\"application/x-www-form-urlencoded\"))) {\n    const form = {};\n    (await r.formData()).forEach((value, key) => {\n      form[key] = value;\n    });\n    body = form;\n  }\n  return body;\n};\nexport {\n  parseBody\n};\n", "// src/request.ts\nimport { parseBody } from \"./utils/body.js\";\nimport { parse } from \"./utils/cookie.js\";\nimport { getQueryParam, getQueryParams, decodeURIComponent_ } from \"./utils/url.js\";\nvar HonoRequest = class {\n  constructor(request, path = \"/\", paramData) {\n    this.bodyCache = {};\n    this.cachedBody = (key) => {\n      const { bodyCache, raw } = this;\n      const cachedBody = bodyCache[key];\n      if (cachedBody)\n        return cachedBody;\n      return bodyCache[key] = raw[key]();\n    };\n    this.raw = request;\n    this.path = path;\n    this.paramData = paramData;\n    this.vData = {};\n  }\n  param(key) {\n    if (this.paramData) {\n      if (key) {\n        const param = this.paramData[key];\n        return param ? /\\%/.test(param) ? decodeURIComponent_(param) : param : void 0;\n      } else {\n        const decoded = {};\n        for (const [key2, value] of Object.entries(this.paramData)) {\n          if (value && typeof value === \"string\") {\n            decoded[key2] = /\\%/.test(value) ? decodeURIComponent_(value) : value;\n          }\n        }\n        return decoded;\n      }\n    }\n    return null;\n  }\n  query(key) {\n    return getQueryParam(this.url, key);\n  }\n  queries(key) {\n    return getQueryParams(this.url, key);\n  }\n  header(name) {\n    if (name)\n      return this.raw.headers.get(name.toLowerCase()) ?? void 0;\n    const headerData = {};\n    this.raw.headers.forEach((value, key) => {\n      headerData[key] = value;\n    });\n    return headerData;\n  }\n  cookie(key) {\n    const cookie = this.raw.headers.get(\"Cookie\");\n    if (!cookie)\n      return;\n    const obj = parse(cookie);\n    if (key) {\n      const value = obj[key];\n      return value;\n    } else {\n      return obj;\n    }\n  }\n  async parseBody() {\n    return await parseBody(this);\n  }\n  json() {\n    return this.cachedBody(\"json\");\n  }\n  text() {\n    return this.cachedBody(\"text\");\n  }\n  arrayBuffer() {\n    return this.cachedBody(\"arrayBuffer\");\n  }\n  blob() {\n    return this.cachedBody(\"blob\");\n  }\n  formData() {\n    return this.cachedBody(\"formData\");\n  }\n  addValidatedData(target, data) {\n    this.vData[target] = data;\n  }\n  valid(target) {\n    return this.vData[target];\n  }\n  get url() {\n    return this.raw.url;\n  }\n  get method() {\n    return this.raw.method;\n  }\n  get headers() {\n    return this.raw.headers;\n  }\n  get body() {\n    return this.raw.body;\n  }\n  get bodyUsed() {\n    return this.raw.bodyUsed;\n  }\n  get integrity() {\n    return this.raw.integrity;\n  }\n  get keepalive() {\n    return this.raw.keepalive;\n  }\n  get referrer() {\n    return this.raw.referrer;\n  }\n  get signal() {\n    return this.raw.signal;\n  }\n};\nexport {\n  HonoRequest\n};\n", "// src/router.ts\nvar METHOD_NAME_ALL = \"ALL\";\nvar METHOD_NAME_ALL_LOWERCASE = \"all\";\nvar METHODS = [\"get\", \"post\", \"put\", \"delete\", \"options\", \"patch\"];\nvar UnsupportedPathError = class extends Error {\n};\nexport {\n  METHODS,\n  METHOD_NAME_ALL,\n  METHOD_NAME_ALL_LOWERCASE,\n  UnsupportedPathError\n};\n", "// src/hono-base.ts\nimport { compose } from \"./compose.js\";\nimport { Context } from \"./context.js\";\nimport { HTTPException } from \"./http-exception.js\";\nimport { HonoRequest } from \"./request.js\";\nimport { METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE, METHODS } from \"./router.js\";\nimport { getPath, getPathNoStrict, getQueryStrings, mergePath } from \"./utils/url.js\";\nfunction defineDynamicClass() {\n  return class {\n  };\n}\nvar notFoundHandler = (c) => {\n  return c.text(\"404 Not Found\", 404);\n};\nvar errorHandler = (err, c) => {\n  if (err instanceof HTTPException) {\n    return err.getResponse();\n  }\n  console.trace(err);\n  const message = \"Internal Server Error\";\n  return c.text(message, 500);\n};\nvar Hono = class extends defineDynamicClass() {\n  constructor(init = {}) {\n    super();\n    this._basePath = \"/\";\n    this.path = \"/\";\n    this.routes = [];\n    this.notFoundHandler = notFoundHandler;\n    this.errorHandler = errorHandler;\n    this.head = () => {\n      console.warn(\"`app.head()` is no longer used. `app.get()` implicitly handles the HEAD method.\");\n      return this;\n    };\n    this.handleEvent = (event) => {\n      return this.dispatch(event.request, event, void 0, event.request.method);\n    };\n    this.fetch = (request, Env, executionCtx) => {\n      return this.dispatch(request, executionCtx, Env, request.method);\n    };\n    this.request = (input, requestInit) => {\n      if (input instanceof Request) {\n        if (requestInit !== void 0) {\n          input = new Request(input, requestInit);\n        }\n        return this.fetch(input);\n      }\n      input = input.toString();\n      const path = /^https?:\\/\\//.test(input) ? input : `http://localhost${mergePath(\"/\", input)}`;\n      const req = new Request(path, requestInit);\n      return this.fetch(req);\n    };\n    this.fire = () => {\n      addEventListener(\"fetch\", (event) => {\n        event.respondWith(this.dispatch(event.request, event, void 0, event.request.method));\n      });\n    };\n    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];\n    allMethods.map((method) => {\n      this[method] = (args1, ...args) => {\n        if (typeof args1 === \"string\") {\n          this.path = args1;\n        } else {\n          this.addRoute(method, this.path, args1);\n        }\n        args.map((handler) => {\n          if (typeof handler !== \"string\") {\n            this.addRoute(method, this.path, handler);\n          }\n        });\n        return this;\n      };\n    });\n    this.on = (method, path, ...handlers) => {\n      if (!method)\n        return this;\n      this.path = path;\n      for (const m of [method].flat()) {\n        handlers.map((handler) => {\n          this.addRoute(m.toUpperCase(), this.path, handler);\n        });\n      }\n      return this;\n    };\n    this.use = (arg1, ...handlers) => {\n      if (typeof arg1 === \"string\") {\n        this.path = arg1;\n      } else {\n        handlers.unshift(arg1);\n      }\n      handlers.map((handler) => {\n        this.addRoute(METHOD_NAME_ALL, this.path, handler);\n      });\n      return this;\n    };\n    const strict = init.strict ?? true;\n    delete init.strict;\n    Object.assign(this, init);\n    this.getPath = strict ? init.getPath ?? getPath : getPathNoStrict;\n  }\n  clone() {\n    const clone = new Hono({\n      router: this.router,\n      getPath: this.getPath\n    });\n    clone.routes = this.routes;\n    return clone;\n  }\n  route(path, app) {\n    const subApp = this.basePath(path);\n    if (!app) {\n      return subApp;\n    }\n    app.routes.map((r) => {\n      const handler = app.errorHandler === errorHandler ? r.handler : async (c, next) => (await compose([r.handler], app.errorHandler)(c, next)).res;\n      subApp.addRoute(r.method, r.path, handler);\n    });\n    return this;\n  }\n  basePath(path) {\n    const subApp = this.clone();\n    subApp._basePath = mergePath(this._basePath, path);\n    return subApp;\n  }\n  onError(handler) {\n    this.errorHandler = handler;\n    return this;\n  }\n  notFound(handler) {\n    this.notFoundHandler = handler;\n    return this;\n  }\n  showRoutes() {\n    const length = 8;\n    this.routes.map((route) => {\n      console.log(\n        `\\x1B[32m${route.method}\\x1B[0m ${\" \".repeat(length - route.method.length)} ${route.path}`\n      );\n    });\n  }\n  mount(path, applicationHandler, optionHandler) {\n    const mergedPath = mergePath(this._basePath, path);\n    const pathPrefixLength = mergedPath === \"/\" ? 0 : mergedPath.length;\n    const handler = async (c, next) => {\n      let executionContext = void 0;\n      try {\n        executionContext = c.executionCtx;\n      } catch {\n      }\n      const options = optionHandler ? optionHandler(c) : [c.env, executionContext];\n      const optionsArray = Array.isArray(options) ? options : [options];\n      const queryStrings = getQueryStrings(c.req.url);\n      const res = await applicationHandler(\n        new Request(\n          new URL((c.req.path.slice(pathPrefixLength) || \"/\") + queryStrings, c.req.url),\n          c.req.raw\n        ),\n        ...optionsArray\n      );\n      if (res)\n        return res;\n      await next();\n    };\n    this.addRoute(METHOD_NAME_ALL, mergePath(path, \"*\"), handler);\n    return this;\n  }\n  get routerName() {\n    this.matchRoute(\"GET\", \"/\");\n    return this.router.name;\n  }\n  addRoute(method, path, handler) {\n    method = method.toUpperCase();\n    if (this._basePath) {\n      path = mergePath(this._basePath, path);\n    }\n    this.router.add(method, path, handler);\n    const r = { path, method, handler };\n    this.routes.push(r);\n  }\n  matchRoute(method, path) {\n    return this.router.match(method, path) || { handlers: [], params: {} };\n  }\n  handleError(err, c) {\n    if (err instanceof Error) {\n      return this.errorHandler(err, c);\n    }\n    throw err;\n  }\n  dispatch(request, executionCtx, env, method) {\n    const path = this.getPath(request, { env });\n    if (method === \"HEAD\") {\n      return (async () => new Response(null, await this.dispatch(request, executionCtx, env, \"GET\")))();\n    }\n    const { handlers, params } = this.matchRoute(method, path);\n    const c = new Context(new HonoRequest(request, path, params), {\n      env,\n      executionCtx,\n      notFoundHandler: this.notFoundHandler\n    });\n    if (handlers.length === 1) {\n      let res;\n      try {\n        res = handlers[0](c, async () => {\n        });\n        if (!res) {\n          return this.notFoundHandler(c);\n        }\n      } catch (err) {\n        return this.handleError(err, c);\n      }\n      if (res.constructor.name === \"Response\")\n        return res;\n      if (\"response\" in res) {\n        res = res.response;\n      }\n      if (res.constructor.name === \"Response\")\n        return res;\n      return (async () => {\n        let awaited;\n        try {\n          awaited = await res;\n          if (awaited !== void 0 && \"response\" in awaited) {\n            awaited = awaited[\"response\"];\n          }\n          if (!awaited) {\n            return this.notFoundHandler(c);\n          }\n        } catch (err) {\n          return this.handleError(err, c);\n        }\n        return awaited;\n      })();\n    }\n    const composed = compose(handlers, this.errorHandler, this.notFoundHandler);\n    return (async () => {\n      try {\n        const tmp = composed(c);\n        const context = tmp.constructor.name === \"Promise\" ? await tmp : tmp;\n        if (!context.finalized) {\n          throw new Error(\n            \"Context is not finalized. You may forget returning Response object or `await next()`\"\n          );\n        }\n        return context.res;\n      } catch (err) {\n        return this.handleError(err, c);\n      }\n    })();\n  }\n};\nexport {\n  Hono as HonoBase\n};\n", "// src/router/reg-exp-router/node.ts\nvar LABEL_REG_EXP_STR = \"[^/]+\";\nvar ONLY_WILDCARD_REG_EXP_STR = \".*\";\nvar TAIL_WILDCARD_REG_EXP_STR = \"(?:|/.*)\";\nvar PATH_ERROR = Symbol();\nfunction compareKey(a, b) {\n  if (a.length === 1) {\n    return b.length === 1 ? a < b ? -1 : 1 : -1;\n  }\n  if (b.length === 1) {\n    return 1;\n  }\n  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {\n    return 1;\n  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {\n    return -1;\n  }\n  if (a === LABEL_REG_EXP_STR) {\n    return 1;\n  } else if (b === LABEL_REG_EXP_STR) {\n    return -1;\n  }\n  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;\n}\nvar Node = class {\n  constructor() {\n    this.children = {};\n  }\n  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {\n    if (tokens.length === 0) {\n      if (this.index !== void 0) {\n        throw PATH_ERROR;\n      }\n      if (pathErrorCheckOnly) {\n        return;\n      }\n      this.index = index;\n      return;\n    }\n    const [token, ...restTokens] = tokens;\n    const pattern = token === \"*\" ? restTokens.length === 0 ? [\"\", \"\", ONLY_WILDCARD_REG_EXP_STR] : [\"\", \"\", LABEL_REG_EXP_STR] : token === \"/*\" ? [\"\", \"\", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\\:([^\\{\\}]+)(?:\\{(.+)\\})?$/);\n    let node;\n    if (pattern) {\n      const name = pattern[1];\n      const regexpStr = pattern[2] || LABEL_REG_EXP_STR;\n      node = this.children[regexpStr];\n      if (!node) {\n        if (Object.keys(this.children).some(\n          (k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.children[regexpStr] = new Node();\n        if (name !== \"\") {\n          node.varIndex = context.varIndex++;\n        }\n      }\n      if (!pathErrorCheckOnly && name !== \"\") {\n        if (paramMap.some((p) => p[0] === name)) {\n          throw new Error(\"Duplicate param name\");\n        }\n        paramMap.push([name, node.varIndex]);\n      }\n    } else {\n      node = this.children[token];\n      if (!node) {\n        if (Object.keys(this.children).some(\n          (k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR\n        )) {\n          throw PATH_ERROR;\n        }\n        if (pathErrorCheckOnly) {\n          return;\n        }\n        node = this.children[token] = new Node();\n      }\n    }\n    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);\n  }\n  buildRegExpStr() {\n    const childKeys = Object.keys(this.children).sort(compareKey);\n    const strList = childKeys.map((k) => {\n      const c = this.children[k];\n      return (typeof c.varIndex === \"number\" ? `(${k})@${c.varIndex}` : k) + c.buildRegExpStr();\n    });\n    if (typeof this.index === \"number\") {\n      strList.unshift(`#${this.index}`);\n    }\n    if (strList.length === 0) {\n      return \"\";\n    }\n    if (strList.length === 1) {\n      return strList[0];\n    }\n    return \"(?:\" + strList.join(\"|\") + \")\";\n  }\n};\nexport {\n  Node,\n  PATH_ERROR\n};\n", "// src/router/reg-exp-router/trie.ts\nimport { Node } from \"./node.js\";\nvar Trie = class {\n  constructor() {\n    this.context = { varIndex: 0 };\n    this.root = new Node();\n  }\n  insert(path, index, pathErrorCheckOnly) {\n    const paramMap = [];\n    const groups = [];\n    for (let i = 0; ; ) {\n      let replaced = false;\n      path = path.replace(/\\{[^}]+\\}/g, (m) => {\n        const mark = `@\\\\${i}`;\n        groups[i] = [mark, m];\n        i++;\n        replaced = true;\n        return mark;\n      });\n      if (!replaced) {\n        break;\n      }\n    }\n    const tokens = path.match(/(?::[^\\/]+)|(?:\\/\\*$)|./g) || [];\n    for (let i = groups.length - 1; i >= 0; i--) {\n      const [mark] = groups[i];\n      for (let j = tokens.length - 1; j >= 0; j--) {\n        if (tokens[j].indexOf(mark) !== -1) {\n          tokens[j] = tokens[j].replace(mark, groups[i][1]);\n          break;\n        }\n      }\n    }\n    this.root.insert(tokens, index, paramMap, this.context, pathErrorCheckOnly);\n    return paramMap;\n  }\n  buildRegExp() {\n    let regexp = this.root.buildRegExpStr();\n    if (regexp === \"\") {\n      return [/^$/, [], []];\n    }\n    let captureIndex = 0;\n    const indexReplacementMap = [];\n    const paramReplacementMap = [];\n    regexp = regexp.replace(/#(\\d+)|@(\\d+)|\\.\\*\\$/g, (_, handlerIndex, paramIndex) => {\n      if (typeof handlerIndex !== \"undefined\") {\n        indexReplacementMap[++captureIndex] = Number(handlerIndex);\n        return \"$()\";\n      }\n      if (typeof paramIndex !== \"undefined\") {\n        paramReplacementMap[Number(paramIndex)] = ++captureIndex;\n        return \"\";\n      }\n      return \"\";\n    });\n    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];\n  }\n};\nexport {\n  Trie\n};\n", "// src/router/reg-exp-router/router.ts\nimport { METHOD_NAME_ALL, METHODS, UnsupportedPathError } from \"../../router.js\";\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { PATH_ERROR } from \"./node.js\";\nimport { Trie } from \"./trie.js\";\nvar methodNames = [METHOD_NAME_ALL, ...METHODS].map((method) => method.toUpperCase());\nvar emptyParam = {};\nvar nullMatcher = [/^$/, [], {}];\nvar wildcardRegExpCache = {};\nfunction buildWildcardRegExp(path) {\n  return wildcardRegExpCache[path] ?? (wildcardRegExpCache[path] = new RegExp(\n    path === \"*\" ? \"\" : `^${path.replace(/\\/\\*/, \"(?:|/.*)\")}$`\n  ));\n}\nfunction clearWildcardRegExpCache() {\n  wildcardRegExpCache = {};\n}\nfunction buildMatcherFromPreprocessedRoutes(routes) {\n  const trie = new Trie();\n  const handlerData = [];\n  if (routes.length === 0) {\n    return nullMatcher;\n  }\n  const routesWithStaticPathFlag = routes.map((route) => [!/\\*|\\/:/.test(route[0]), ...route]).sort(\n    ([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length\n  );\n  const staticMap = {};\n  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length; i < len; i++) {\n    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];\n    if (pathErrorCheckOnly) {\n      staticMap[path] = { handlers, params: emptyParam };\n    } else {\n      j++;\n    }\n    let paramMap;\n    try {\n      paramMap = trie.insert(path, j, pathErrorCheckOnly);\n    } catch (e) {\n      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;\n    }\n    if (pathErrorCheckOnly) {\n      continue;\n    }\n    handlerData[j] = paramMap.length === 0 ? [{ handlers, params: emptyParam }, null] : [handlers, paramMap];\n  }\n  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();\n  for (let i = 0, len = handlerData.length; i < len; i++) {\n    const paramMap = handlerData[i][1];\n    if (paramMap) {\n      for (let j = 0, len2 = paramMap.length; j < len2; j++) {\n        paramMap[j][1] = paramReplacementMap[paramMap[j][1]];\n      }\n    }\n  }\n  const handlerMap = [];\n  for (const i in indexReplacementMap) {\n    handlerMap[i] = handlerData[indexReplacementMap[i]];\n  }\n  return [regexp, handlerMap, staticMap];\n}\nfunction findMiddleware(middleware, path) {\n  if (!middleware) {\n    return void 0;\n  }\n  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {\n    if (buildWildcardRegExp(k).test(path)) {\n      return [...middleware[k]];\n    }\n  }\n  return void 0;\n}\nvar RegExpRouter = class {\n  constructor() {\n    this.name = \"RegExpRouter\";\n    this.middleware = { [METHOD_NAME_ALL]: {} };\n    this.routes = { [METHOD_NAME_ALL]: {} };\n  }\n  add(method, path, handler) {\n    var _a;\n    const { middleware, routes } = this;\n    if (!middleware || !routes) {\n      throw new Error(\"Can not add a route since the matcher is already built.\");\n    }\n    if (methodNames.indexOf(method) === -1)\n      methodNames.push(method);\n    if (!middleware[method]) {\n      ;\n      [middleware, routes].forEach((handlerMap) => {\n        handlerMap[method] = {};\n        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {\n          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];\n        });\n      });\n    }\n    if (path === \"/*\") {\n      path = \"*\";\n    }\n    if (/\\*$/.test(path)) {\n      const re = buildWildcardRegExp(path);\n      if (method === METHOD_NAME_ALL) {\n        Object.keys(middleware).forEach((m) => {\n          var _a2;\n          (_a2 = middleware[m])[path] || (_a2[path] = findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);\n        });\n      } else {\n        (_a = middleware[method])[path] || (_a[path] = findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || []);\n      }\n      Object.keys(middleware).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(middleware[m]).forEach((p) => {\n            re.test(p) && middleware[m][p].push(handler);\n          });\n        }\n      });\n      Object.keys(routes).forEach((m) => {\n        if (method === METHOD_NAME_ALL || method === m) {\n          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push(handler));\n        }\n      });\n      return;\n    }\n    const paths = checkOptionalParameter(path) || [path];\n    for (let i = 0, len = paths.length; i < len; i++) {\n      const path2 = paths[i];\n      Object.keys(routes).forEach((m) => {\n        var _a2;\n        if (method === METHOD_NAME_ALL || method === m) {\n          (_a2 = routes[m])[path2] || (_a2[path2] = [\n            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []\n          ]);\n          routes[m][path2].push(handler);\n        }\n      });\n    }\n  }\n  match(method, path) {\n    clearWildcardRegExpCache();\n    const matchers = this.buildAllMatchers();\n    this.match = (method2, path2) => {\n      const matcher = matchers[method2];\n      const staticMatch = matcher[2][path2];\n      if (staticMatch) {\n        return staticMatch;\n      }\n      const match = path2.match(matcher[0]);\n      if (!match) {\n        return null;\n      }\n      const index = match.indexOf(\"\", 1);\n      const [handlers, paramMap] = matcher[1][index];\n      if (!paramMap) {\n        return handlers;\n      }\n      const params = {};\n      for (let i = 0, len = paramMap.length; i < len; i++) {\n        params[paramMap[i][0]] = match[paramMap[i][1]];\n      }\n      return { handlers, params };\n    };\n    return this.match(method, path);\n  }\n  buildAllMatchers() {\n    const matchers = {};\n    methodNames.forEach((method) => {\n      matchers[method] = this.buildMatcher(method) || matchers[METHOD_NAME_ALL];\n    });\n    this.middleware = this.routes = void 0;\n    return matchers;\n  }\n  buildMatcher(method) {\n    const routes = [];\n    let hasOwnRoute = method === METHOD_NAME_ALL;\n    [this.middleware, this.routes].forEach((r) => {\n      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];\n      if (ownRoute.length !== 0) {\n        hasOwnRoute || (hasOwnRoute = true);\n        routes.push(...ownRoute);\n      } else if (method !== METHOD_NAME_ALL) {\n        routes.push(\n          ...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]])\n        );\n      }\n    });\n    if (!hasOwnRoute) {\n      return null;\n    } else {\n      return buildMatcherFromPreprocessedRoutes(routes);\n    }\n  }\n};\nexport {\n  RegExpRouter\n};\n", "// src/router/smart-router/router.ts\nimport { UnsupportedPathError } from \"../../router.js\";\nvar SmartRouter = class {\n  constructor(init) {\n    this.name = \"SmartRouter\";\n    this.routers = [];\n    this.routes = [];\n    Object.assign(this, init);\n  }\n  add(method, path, handler) {\n    if (!this.routes) {\n      throw new Error(\"Can not add a route since the matcher is already built.\");\n    }\n    this.routes.push([method, path, handler]);\n  }\n  match(method, path) {\n    if (!this.routes) {\n      throw new Error(\"Fatal error\");\n    }\n    const { routers, routes } = this;\n    const len = routers.length;\n    let i = 0;\n    let res;\n    for (; i < len; i++) {\n      const router = routers[i];\n      try {\n        routes.forEach((args) => {\n          router.add(...args);\n        });\n        res = router.match(method, path);\n      } catch (e) {\n        if (e instanceof UnsupportedPathError) {\n          continue;\n        }\n        throw e;\n      }\n      this.match = router.match.bind(router);\n      this.routers = [router];\n      this.routes = void 0;\n      break;\n    }\n    if (i === len) {\n      throw new Error(\"Fatal error\");\n    }\n    this.name = `SmartRouter + ${this.activeRouter.name}`;\n    return res || null;\n  }\n  get activeRouter() {\n    if (this.routes || this.routers.length !== 1) {\n      throw new Error(\"No active router has been determined yet.\");\n    }\n    return this.routers[0];\n  }\n};\nexport {\n  SmartRouter\n};\n", "// src/router/trie-router/node.ts\nimport { METHOD_NAME_ALL } from \"../../router.js\";\nimport { splitPath, splitRoutingPath, getPattern } from \"../../utils/url.js\";\nfunction findParam(node, name) {\n  for (let i = 0, len = node.patterns.length; i < len; i++) {\n    if (typeof node.patterns[i] === \"object\" && node.patterns[i][1] === name) {\n      return true;\n    }\n  }\n  const nodes = Object.values(node.children);\n  for (let i = 0, len = nodes.length; i < len; i++) {\n    if (findParam(nodes[i], name)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar Node = class {\n  constructor(method, handler, children) {\n    this.order = 0;\n    this.children = children || {};\n    this.methods = [];\n    this.name = \"\";\n    if (method && handler) {\n      const m = {};\n      m[method] = { handler, score: 0, name: this.name };\n      this.methods = [m];\n    }\n    this.patterns = [];\n    this.handlerSetCache = {};\n  }\n  insert(method, path, handler) {\n    this.name = `${method} ${path}`;\n    this.order = ++this.order;\n    let curNode = this;\n    const parts = splitRoutingPath(path);\n    const parentPatterns = [];\n    const errorMessage = (name) => {\n      return `Duplicate param name, use another name instead of '${name}' - ${method} ${path} <--- '${name}'`;\n    };\n    for (let i = 0, len = parts.length; i < len; i++) {\n      const p = parts[i];\n      if (Object.keys(curNode.children).includes(p)) {\n        parentPatterns.push(...curNode.patterns);\n        curNode = curNode.children[p];\n        continue;\n      }\n      curNode.children[p] = new Node();\n      const pattern = getPattern(p);\n      if (pattern) {\n        if (typeof pattern === \"object\") {\n          for (let j = 0, len2 = parentPatterns.length; j < len2; j++) {\n            if (typeof parentPatterns[j] === \"object\" && parentPatterns[j][1] === pattern[1]) {\n              throw new Error(errorMessage(pattern[1]));\n            }\n          }\n          if (Object.values(curNode.children).some((n) => findParam(n, pattern[1]))) {\n            throw new Error(errorMessage(pattern[1]));\n          }\n        }\n        curNode.patterns.push(pattern);\n        parentPatterns.push(...curNode.patterns);\n      }\n      parentPatterns.push(...curNode.patterns);\n      curNode = curNode.children[p];\n    }\n    if (!curNode.methods.length) {\n      curNode.methods = [];\n    }\n    const m = {};\n    const handlerSet = { handler, name: this.name, score: this.order };\n    m[method] = handlerSet;\n    curNode.methods.push(m);\n    return curNode;\n  }\n  gHSets(node, method, wildcard) {\n    var _a, _b;\n    return (_a = node.handlerSetCache)[_b = `${method}:${wildcard ? \"1\" : \"0\"}`] || (_a[_b] = (() => {\n      const handlerSets = [];\n      for (let i = 0, len = node.methods.length; i < len; i++) {\n        const m = node.methods[i];\n        const handlerSet = m[method] || m[METHOD_NAME_ALL];\n        if (handlerSet !== void 0) {\n          handlerSets.push(handlerSet);\n        }\n      }\n      return handlerSets;\n    })());\n  }\n  search(method, path) {\n    const handlerSets = [];\n    const params = {};\n    const curNode = this;\n    let curNodes = [curNode];\n    const parts = splitPath(path);\n    for (let i = 0, len2 = parts.length; i < len2; i++) {\n      const part = parts[i];\n      const isLast = i === len2 - 1;\n      const tempNodes = [];\n      let matched = false;\n      for (let j = 0, len22 = curNodes.length; j < len22; j++) {\n        const node = curNodes[j];\n        const nextNode = node.children[part];\n        if (nextNode) {\n          if (isLast === true) {\n            if (nextNode.children[\"*\"]) {\n              handlerSets.push(...this.gHSets(nextNode.children[\"*\"], method, true));\n            }\n            handlerSets.push(...this.gHSets(nextNode, method));\n            matched = true;\n          } else {\n            tempNodes.push(nextNode);\n          }\n        }\n        for (let k = 0, len3 = node.patterns.length; k < len3; k++) {\n          const pattern = node.patterns[k];\n          if (pattern === \"*\") {\n            const astNode = node.children[\"*\"];\n            if (astNode) {\n              handlerSets.push(...this.gHSets(astNode, method));\n              tempNodes.push(astNode);\n            }\n            continue;\n          }\n          if (part === \"\")\n            continue;\n          const [key, name, matcher] = pattern;\n          const child = node.children[key];\n          const restPathString = parts.slice(i).join(\"/\");\n          if (matcher instanceof RegExp && matcher.test(restPathString)) {\n            handlerSets.push(...this.gHSets(child, method));\n            params[name] = restPathString;\n            continue;\n          }\n          if (matcher === true || matcher instanceof RegExp && matcher.test(part)) {\n            if (typeof key === \"string\") {\n              if (isLast === true) {\n                handlerSets.push(...this.gHSets(child, method));\n                if (child.children[\"*\"]) {\n                  handlerSets.push(...this.gHSets(child.children[\"*\"], method));\n                }\n              } else {\n                tempNodes.push(child);\n              }\n            }\n            if (typeof name === \"string\" && !matched) {\n              params[name] = part;\n            } else {\n              if (node.children[part]) {\n                params[name] = part;\n              }\n            }\n          }\n        }\n      }\n      curNodes = tempNodes;\n    }\n    const len = handlerSets.length;\n    if (len === 0)\n      return null;\n    if (len === 1)\n      return { handlers: [handlerSets[0].handler], params };\n    const handlers = handlerSets.sort((a, b) => {\n      return a.score - b.score;\n    }).map((s) => {\n      return s.handler;\n    });\n    return { handlers, params };\n  }\n};\nexport {\n  Node\n};\n", "// src/router/trie-router/router.ts\nimport { checkOptionalParameter } from \"../../utils/url.js\";\nimport { Node } from \"./node.js\";\nvar TrieRouter = class {\n  constructor() {\n    this.name = \"TrieRouter\";\n    this.node = new Node();\n  }\n  add(method, path, handler) {\n    const results = checkOptionalParameter(path);\n    if (results) {\n      for (const p of results) {\n        this.node.insert(method, p, handler);\n      }\n      return;\n    }\n    this.node.insert(method, path, handler);\n  }\n  match(method, path) {\n    return this.node.search(method, path);\n  }\n};\nexport {\n  TrieRouter\n};\n", "// src/hono.ts\nimport { HonoBase } from \"./hono-base.js\";\nimport { RegExpRouter } from \"./router/reg-exp-router/index.js\";\nimport { SmartRouter } from \"./router/smart-router/index.js\";\nimport { TrieRouter } from \"./router/trie-router/index.js\";\nvar Hono = class extends HonoBase {\n  constructor(init = {}) {\n    super(init);\n    this.router = init.router ?? new SmartRouter({\n      routers: [new RegExpRouter(), new TrieRouter()]\n    });\n  }\n};\nexport {\n  Hono\n};\n", "// src/middleware/cors/index.ts\nvar cors = (options) => {\n  const defaults = {\n    origin: \"*\",\n    allowMethods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\"],\n    allowHeaders: [],\n    exposeHeaders: []\n  };\n  const opts = {\n    ...defaults,\n    ...options\n  };\n  const findAllowOrigin = ((optsOrigin) => {\n    if (typeof optsOrigin === \"string\") {\n      return () => optsOrigin;\n    } else if (typeof optsOrigin === \"function\") {\n      return optsOrigin;\n    } else {\n      return (origin) => optsOrigin.includes(origin) ? origin : optsOrigin[0];\n    }\n  })(opts.origin);\n  return async (c, next) => {\n    function set(key, value) {\n      c.res.headers.set(key, value);\n    }\n    const allowOrigin = findAllowOrigin(c.req.headers.get(\"origin\") || \"\");\n    if (allowOrigin) {\n      set(\"Access-Control-Allow-Origin\", allowOrigin);\n    }\n    if (opts.origin !== \"*\") {\n      set(\"Vary\", \"Origin\");\n    }\n    if (opts.credentials) {\n      set(\"Access-Control-Allow-Credentials\", \"true\");\n    }\n    if (opts.exposeHeaders?.length) {\n      set(\"Access-Control-Expose-Headers\", opts.exposeHeaders.join(\",\"));\n    }\n    if (c.req.method !== \"OPTIONS\") {\n      await next();\n    } else {\n      if (opts.maxAge != null) {\n        set(\"Access-Control-Max-Age\", opts.maxAge.toString());\n      }\n      if (opts.allowMethods?.length) {\n        set(\"Access-Control-Allow-Methods\", opts.allowMethods.join(\",\"));\n      }\n      let headers = opts.allowHeaders;\n      if (!headers?.length) {\n        const requestHeaders = c.req.headers.get(\"Access-Control-Request-Headers\");\n        if (requestHeaders) {\n          headers = requestHeaders.split(/\\s*,\\s*/);\n        }\n      }\n      if (headers?.length) {\n        set(\"Access-Control-Allow-Headers\", headers.join(\",\"));\n        c.res.headers.append(\"Vary\", \"Access-Control-Request-Headers\");\n      }\n      c.res.headers.delete(\"Content-Length\");\n      c.res.headers.delete(\"Content-Type\");\n      return new Response(null, {\n        headers: c.res.headers,\n        status: 204,\n        statusText: c.res.statusText\n      });\n    }\n  };\n};\nexport {\n  cors\n};\n", "var util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" &&\n                (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[a-z][a-z0-9]*$/;\nconst ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^([A-Z0-9_+-]+\\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst emojiRegex = /^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$/u;\nconst ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;\nconst ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nclass ZodString extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n        /**\n         * @deprecated Use z.string().min(1) instead.\n         * @see {@link ZodString.min}\n         */\n        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n        this.trim = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n        this.toLowerCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n        this.toUpperCase = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" ||\n            (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" ||\n                ch.kind === \"int\" ||\n                ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key) => {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key) => {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        return ZodEnum.create(values);\n    }\n    exclude(values) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.issues.length) {\n                return {\n                    status: \"dirty\",\n                    value: ctx.data,\n                };\n            }\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nclass ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        if (isValid(result)) {\n            result.value = Object.freeze(result.value);\n        }\n        return result;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\nconst custom = (check, params = {}, \n/*\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            var _a, _b;\n            if (!check(data)) {\n                const p = typeof params === \"function\"\n                    ? params(data)\n                    : typeof params === \"string\"\n                        ? { message: params }\n                        : params;\n                const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal: _fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar z = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    get objectUtil () { return objectUtil; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    ZodReadonly: ZodReadonly,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nexport { BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, ZodType as Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodError, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodIssueCode, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodReadonly, ZodRecord, ZodType as ZodSchema, ZodSet, ZodString, ZodSymbol, ZodEffects as ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, z as default, errorMap as defaultErrorMap, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, getErrorMap, getParsedType, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void, z };\n", "import { zValidator } from '@hono/zod-validator';\nimport { Hono } from 'hono';\nimport { HTTPException } from 'hono/http-exception';\nimport { bearerAuth } from 'hono/bearer-auth';\nimport { cors } from 'hono/cors';\nimport { z } from 'zod';\nimport { deleteOldCache } from './autoCacheBust';\n\nexport const router = new Hono<{ Bindings: Env }>();\n\nconst paramValidator = z.object({ artifactID: z.string(), teamID: z.string().optional() });\nconst queryValidator = z.object({ slug: z.string().optional() });\n\nrouter.onError((err, c) => {\n\tif (err instanceof HTTPException) {\n\t\treturn err.getResponse();\n\t}\n\treturn c.json({ error: err.message }, 500);\n});\n\nrouter.use('*', cors());\n\n// artifactRouter.use('/artifact/*', async (c, next) => {\n// \tconst middleware = bearerAuth({ token: c.env.TURBO_TOKEN });\n// \tawait middleware(c, next);\n// });\n\nrouter.post('manual-cache-bust', zValidator('json', z.object({ expireInHours: z.number().optional() })), async (c) => {\n\tconst { expireInHours } = c.req.valid('json');\n\tawait deleteOldCache({\n\t\t...c.env,\n\t\tEXPIRATION_HOURS: expireInHours ?? c.env.EXPIRATION_HOURS,\n\t});\n\treturn c.json({ success: true });\n});\n\nrouter.put('v8/:artifactID', zValidator('param', paramValidator), zValidator('query', queryValidator), async (c) => {\n\tconst artifactID = c.req.valid('param').artifactID;\n\tconst teamID = c.req.valid('param').teamID;\n\tconst { slug } = c.req.valid('query');\n\n\tif (!teamID && !slug) {\n\t\treturn c.json({ error: 'MISSING_TEAM_ID' }, 400);\n\t}\n\n\tconst contentType = c.req.headers.get('Content-Type');\n\tif (contentType !== 'application/octet-stream') {\n\t\treturn c.json({ error: 'EXPECTED_CONTENT_TYPE_OCTET_STREAM' }, 400);\n\t}\n\n\tconst r2Metadata = {\n\t\tartifactTag: '',\n\t};\n\tconst artifactTag = c.req.headers.get('x-artifact-tag');\n\tif (artifactTag) {\n\t\tr2Metadata.artifactTag = artifactTag;\n\t}\n\n\tconst r2Object = await c.env.R2_STORE.put(`${teamID ?? slug}/${artifactID}`, c.req.body, { customMetadata: r2Metadata });\n\n\treturn c.json({ teamID, artifactID, storagePath: r2Object.key, size: r2Object.size }, 201);\n});\n\nrouter.get('v8/:artifactID/:teamID?', zValidator('param', paramValidator), zValidator('query', queryValidator), async (c) => {\n\tconst artifactID = c.req.valid('param').artifactID;\n\tconst teamID = c.req.valid('param').teamID;\n\tconst { slug } = c.req.valid('query');\n\n\tif (!teamID && !slug) {\n\t\treturn c.json({ error: 'MISSING_TEAM_ID' }, 400);\n\t}\n\n\tif (artifactID === 'list') {\n\t\tconst list = await c.env.R2_STORE.list();\n\t\treturn c.json(list.objects.map((object) => object));\n\t}\n\n\tconst r2Object = await c.env.R2_STORE.get(`${teamID ?? slug}/${artifactID}`);\n\tif (!r2Object) {\n\t\treturn c.json({ error: 'OBJECT_NOT_FOUND' }, 404);\n\t}\n\n\tc.header('Content-Type', 'application/octet-stream');\n\tif (r2Object.customMetadata?.artifactTag) {\n\t\tc.header('x-artifact-tag', r2Object.customMetadata.artifactTag);\n\t}\n\n\tc.status(200);\n\treturn c.body(r2Object.body);\n});\n", "import { deleteOldCache } from './autoCacheBust';\nimport { router } from './routes';\n\nexport default {\n\tasync fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n\t\treturn router.fetch(request, env, ctx);\n\t},\n\tasync scheduled(_event: ScheduledEvent, env: Env, _ctx: ExecutionContext) {\n\t\tawait deleteOldCache(env);\n\t},\n};\n"],
  "mappings": "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",
  "names": ["nanoInHour", "nanoInDay", "nanoIn", "unitDigitMap", "isDayTimeUnit", "unit", "isDateUnit", "parseOverflowOption", "createOptionParser", "constrain", "reject", "propName", "map", "defaultVal", "valueParser", "nameForError", "input", "runtimeDefaultVal", "d", "RangeError", "options", "ensured", "ensureOptionsObj", "constrainInt", "val", "min", "max", "overflowHandling", "Number", "isFinite", "Math", "trunc", "newVal", "refineFields", "refinerMap", "res", "fieldName", "strict", "isObjectLike", "TypeError", "objectLikeTypeRE", "v", "test", "parseRoundingModeOption", "halfExpand", "round", "ceil", "floor", "createWeakMap", "WeakMap", "get", "bind", "set", "attachGetters", "ObjClass", "getters", "Object", "defineProperties", "prototype", "mapHash", "func", "hash", "key", "mapHashByKeys", "keys", "output", "strArrayToHash", "strs", "forEach", "str", "i", "timeUnitNames", "unitNames", "durationUnitNames", "unitMap", "_str", "pluralUnitMap", "parseUnit", "defaultUnit", "minUnit", "maxUnit", "_a", "num", "parseDiffOptions", "largestUnitDefault", "smallestUnitDefault", "forDurationRounding", "ensuredOptions", "roundingIncrement", "smallestUnit", "roundingFunc", "largestUnitArg", "largestUnit", "largerNano", "incNano", "parseRoundingOptions", "relaxedDivisibility", "formatFactoryFactorySymbol", "Symbol", "ensureObj", "arg", "otherArgs", "from", "AbstractObj", "toJSON", "this", "toString", "AbstractNoValueObj", "valueOf", "Error", "getISOFields", "setISOFields", "AbstractISOObj", "constructor", "isoFields", "super", "freeze", "compareValues", "a", "b", "numSign", "roundToIncrement", "inc", "roundToMinute", "nano", "n", "abs", "roundToIncrementBI", "wholeNum", "div", "mult", "leftover", "sub", "toNumber", "add", "positiveModulo", "padZeros", "length", "buildPadding", "String", "padEnd", "len", "padChar", "Array", "join", "getSignStr", "maxLowNum", "pow", "LargeInt", "high", "low", "sign", "neg", "getHighLow", "balanceAndCreate", "highFloat", "highStr", "indexOf", "toFixed", "highDot", "lowScraps", "afterDot", "substr", "parseInt", "toBigInt", "BigInt", "createLargeInt", "maxNumBI", "trim", "match", "SyntaxError", "gapIndex", "compareLargeInts", "newLow", "newHigh", "signHigh", "signLow", "durationFieldNames", "concat", "negateDuration", "fields", "overrideDuration", "d0", "d1", "_b", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "signDuration", "years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds", "microseconds", "nanoseconds", "computeDurationSign", "computeLargestDurationUnit", "dur", "zeroISOTimeFields", "isoHour", "isoMinute", "isoSecond", "isoMillisecond", "isoMicrosecond", "isoNanosecond", "zeroDurationTimeFields", "partialLocalTimeToISO", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond", "durationDayTimeToNano", "durationTimeToNano", "isoTimeToNano", "nanoToDuration", "temp", "nanoToISOTime", "timeNano", "dayDelta", "eraOrigins", "gregory", "bce", "ce", "ethioaa", "era0", "ethiopic", "era1", "coptic", "roc", "beforeroc", "minguo", "buddhist", "be", "islamic", "ah", "indian", "saka", "persian", "ap", "japanese", "meiji", "taisho", "showa", "heisei", "reiwa", "CalendarImpl", "id", "monthCode", "month", "_year", "convertMonthCode", "monthCodeIsLeap", "monthCodeInt", "convertEraYear", "calendarID", "eraYear", "era", "fromDateTimeFormat", "origin", "getCalendarIDBase", "split", "ISOCalendarImpl", "computeFields", "epochMilli", "epochMilliToISOFields", "year", "isoYear", "isoMonth", "day", "isoDay", "epochMilliseconds", "isoToEpochMilli", "daysInMonth", "inLeapYear", "monthsInYear", "guessYearForMonthDay", "isoEpochLeapYear", "normalizeISOYearForMonthDay", "isoCalendarImpl", "epochNanoSymbol", "isoFieldsToEpochNano", "isoToEpochNano", "isoDayTry", "milli", "dayShiftAbs", "twoDigitYearBug", "isoYearTemp", "milliTry", "Date", "UTC", "isInvalid", "throwOutOfRange", "setUTCFullYear", "epochNanoToISOFields", "epochNano", "leftoverNano", "legacy", "dayUnshift", "nudgeToLegacyDate", "getUTCFullYear", "getUTCMonth", "getUTCDate", "getUTCHours", "getUTCMinutes", "getUTCSeconds", "getUTCMilliseconds", "toEpochNano", "dt", "isoYearToEpochSeconds", "epochNanoToISOYear", "computeISODayOfWeek", "getUTCDay", "date", "dateTry", "isNaN", "diffDaysMilli", "epochMilli0", "epochMilli1", "addDaysMilli", "dateTimesEqual", "compareDateTimes", "calendar", "compareTimes", "t0", "t1", "compareLocalDateFields", "compareEpochObjs", "constrainDateFields", "calendarImpl", "overflow", "constrainDateISO", "constrainDateTimeISO", "constrainTimeISO", "yearMonthFieldMap", "dateFieldMap", "timeFieldMap", "monthDayFieldMap", "durationFieldMap", "GregoryCalendarImpl", "parseCalendarDisplayOption", "auto", "never", "always", "parseDisambigOption", "compatible", "earlier", "later", "parseTimeToStringOptions", "smallestUnitArg", "digitsArg", "fractionalSecondDigits", "digits", "parseTimeZoneDisplayOption", "formatDateTimeISO", "formatConfig", "formatDateISO", "formatTimeISO", "formatYearMonthISO", "parts", "push", "formatPartialSeconds", "formatOffsetISO", "offsetNano", "partialSecondsStr", "formatCalendarID", "display", "collapseDurationTuples", "tuples", "postfix", "forceShow", "toLocaleString", "useGrouping", "totalNano", "totalNanoAbs", "afterDecimal", "replace", "mixinEpochFields", "epochNanoseconds", "epochMicroseconds", "epochSeconds", "isoFieldMap", "unitName", "s", "charAt", "toUpperCase", "slice", "mixinISOFields", "unitNames2", "yearMonthCalendarFields", "dateCalendarFields", "mixinCalendarFields", "propNames", "value", "defineProperty", "attachStringTag", "objOrClass", "name", "toStringTag", "parseOffsetHandlingOption", "prefer", "use", "ignore", "getInstantFor", "timeZoneProtocol", "dateTime", "disambigInt", "possibleInstants", "getPossibleInstantsFor", "gapNano", "plainDateTime", "utcEpochNano", "offsetDayBefore", "getOffsetNanosecondsFor", "Instant", "moreInstants", "addYears", "yearsToAdd", "newMonth", "newDay", "addMonths", "monthsToAdd", "addDays", "translateEpochNano", "durationFields", "computeZonedDateTimeEpochNano", "fuzzyMatching", "offsetHandling", "disambigOptions", "offsetNanoseconds", "timeZone", "Z", "matchingEpochNano", "findMatchingEpochNano", "createDateTime", "roundedOffsetNano", "instant", "possibleEpochNano", "possibleOffsetNano", "computeNanoInDay", "day0", "Calendar", "day1", "epochNano0", "timeRegExpStr", "offsetRegExpStr", "endingRegExpStr", "yearMonthRegExp", "createRegExp", "monthDayRegExp", "dateTimeRegExp", "dateRegExpStr", "timeRegExp", "offsetRegExp", "durationRegExp", "unicodeDashRegExp", "meat", "RegExp", "normalizeDashes", "parseZonedDateTime", "tryParseZonedDateTime", "createParseError", "parseDateTime", "tryParseDateTime", "parseOffsetNano", "tryParseOffsetNano", "parseTime", "m", "exec", "parseTimeParts", "tryOther", "tryParseYearMonth", "tryParseMonthDay", "ex", "zRE", "zOrOffset", "parseOffsetParts", "parseDateTimeParts", "requireTime", "allowZ", "toInt1", "toInt0", "parseNanoAfterDecimal", "toIntMaybe", "type", "refineBaseObj", "parsed", "createDefaultCalendar", "refineZonedObj", "TimeZone", "TimeZoneImpl", "FixedTimeZoneImpl", "getPossibleOffsets", "getOffset", "getTransition", "hashIntlFormatParts", "format", "epochMillisecond", "formatToParts", "part", "eraRemap", "bc", "ad", "normalizeShortEra", "formattedEra", "toLowerCase", "normalize", "OrigDateTimeFormat", "Intl", "DateTimeFormat", "normalizeAndCopyLocalesArg", "localesArg", "specialCases", "toNano", "DST_PERSIST_YEAR", "ISLAND_SEARCH_DAYS", "IntlTimeZoneImpl", "resolvedOptions", "yearEndOffsets", "transitionsInYear", "zoneNano", "lastOffsetNano", "transitions", "filter", "Boolean", "transition", "transitionEpochNano", "offsetNanoBefore", "offsetNanoAfter", "epochNanoA", "epochNanoB", "getYearEndOffsetSec", "getOffsetForEpochSecs", "epochSec", "zoneMilli", "direction", "getTransitionFrom", "DST_EARLIEST_YEAR", "endYear", "getTransitionsInYear", "reverse", "utcYear", "computeTransitionsInYear", "startOffsetSec", "endOffsetSec", "startEpochSec", "endEpochSec", "searchTransition", "island", "searchIsland", "middleEpochSecs", "outerOffsetSec", "offsetSec", "implCache", "getImpl", "setImpl", "toLocaleUpperCase", "static", "obj", "innerTimeZone", "refined", "getOffsetStringFor", "instantArg", "getPlainDateTimeFor", "calendarArg", "dateTimeArg", "PlainDateTime", "getPreviousTransition", "rawTransition", "getNextTransition", "extractTimeZone", "processZonedDateTimeFromFields", "buildSafeFunc", "rawFields", "tryDateTimeFromFields", "offset", "processDateTimeFromFields", "processDateFromFields", "tryDateFromFields", "processYearMonthFromFields", "extractCalendar", "filteredFields", "filterFieldsViaCalendar", "hasAnyProps", "yearMonthFromFields", "processMonthDayFromFields", "monthDayFromFields", "processTimeFromFields", "tryTimeFromFields", "processZonedDateTimeWithFields", "zonedDateTime", "tryDateTimeWithFields", "hasNewOffset", "processDateTimeWithFields", "processDateWithFields", "tryDateWithFields", "processYearMonthWithFields", "plainYearMonth", "mergedFields", "mergeFieldsViaCalendar", "processMonthDayWithFields", "plainMonthDay", "processTimeWithFields", "tryTimeWithFields", "processDurationFields", "refinedFields", "dateRes", "timeRes", "dateFromFields", "plainDate", "plainTime", "base", "_refineFunc", "objOrFields", "fieldMap", "fieldNames", "call", "filterFieldsViaWhitelist", "whitelist", "filtered", "existingObj", "existingFields", "mergeFields", "mergeCalFields", "isWith", "args", "maxInstantBI", "minInstantBI", "maxPlainBI", "minPlainBI", "validateDateTime", "validatePlain", "checkEpochNanoBuggy", "roundDateTime", "roundingConfig", "roundedTimeNano", "roundNano", "isoTimeFields", "roundTime", "roundEpochNano", "dayEpochNano", "createZonedFormatFactoryFactory", "greedyDefaults", "nonGreedyDefaults", "finalOptions", "locales", "defaults", "anyDefaultsOverridden", "buildKey", "createKeyFactory", "buildFormat", "timeZoneID", "buildEpochMilli", "getEpochMilliFromZonedEntity", "entity", "createPlainFormatFactoryFactory", "strictCalendar", "timeZoneName", "computeEpochMilliViaTimeZone", "computeEpochMilliViaISO", "optionsCalendarID", "locale", "optionsTimeZoneID", "otherEntity", "_a2", "entityCalendarID", "entityTimeZoneID", "overrides", "mixinLocaleStringMethods", "buildFormatFactory", "formatFactory", "extractFormatFactoryFactory", "parseDuration", "parseDurationTimeUnit", "small", "signedDuration", "beforeDecimal", "wholeUnits", "parseOffsetDisplayOption", "PlainTime", "createTime", "with", "durationArg", "translatePlainTime", "Duration", "subtract", "until", "other", "diffPlainTimes", "since", "equals", "toZonedDateTime", "PlainDate", "createZonedDateTimeFromFields", "toPlainDateTime", "dateArg", "ensureLooseTime", "pt", "timeFields", "newTimeFields", "pt0", "pt1", "diffConfig", "createDuration", "weekday", "PlainYearMonth", "referenceISODay", "constrained", "createYearMonth", "translatePlainYearMonth", "diffPlainYearMonths", "calendarDisplay", "toPlainDate", "yearMonth", "duration", "toPlainYearMonth", "pym0", "pym1", "flip", "diffDates", "getCommonCalendar", "offsetNanoSymbol", "ZonedDateTime", "timeZoneArg", "buildZonedDateTimeISOFields", "isObject", "withPlainDate", "getStrangerCalendar", "withPlainTime", "timeArg", "withCalendar", "withTimeZone", "translateZonedDateTime", "diffZonedDateTimes", "roundZonedDateTime", "startOfDay", "hoursInDay", "offsetDisplay", "timeZoneDisplay", "roundedZdt", "toPlainMonthDay", "createDate", "toPlainTime", "toInstant", "zdt", "translatedDate", "dateAdd", "dt0", "dt1", "diffDateTimes", "extractRelativeTo", "spanDurationFrom", "relativeTo", "translated", "dateUntil", "spanDurationFromDateTime", "dissolveWeeks", "forcedWeeks", "balancedDuration", "diffAccurate", "computeExactDuration", "smallestUnitName", "durationUnit", "incDur", "startDateTime", "endDateTime", "startNano", "endNano", "unitFrac", "roundDurationSpan", "spannedDuration", "doRound", "orig", "getFields", "setFields", "numberFields", "unsignedFields", "fieldNum", "fieldSign", "isInteger", "fields0", "fields1", "date0", "date1", "blank", "negated", "addDurations", "optionsObj", "relativeToTranslated", "total", "totalConfig", "optionsArg", "forceSeconds", "_locales", "_options", "translatePlainDateTime", "diffPlainDateTimes", "pdt0", "pdt1", "PlainMonthDay", "referenceISOYear", "createMonthDay", "isDateISOInstance", "queryDateFields", "disallowMonthDay", "ensureCalendarsEqual", "queryDateISOFields", "dateLike", "yearFromEra", "tryMonth", "unusedLeap", "getExistingDateISOFields", "computeDaysInYear", "computeDayOfYear", "calLeapMonths", "hebrew", "chinese", "dangi", "IntlCalendarImpl", "specificCalendarID", "relatedCalendarID", "yearCorrection", "computeFieldsDumb", "monthCacheByYear", "queryMonthCache", "epochMillis", "startMarker", "leapMonth", "queryLeapMonthByYear", "presetLeapMonth", "maxYear", "dumbFields", "monthStrToNum", "partHash", "relatedYear", "currentCache", "prevCache", "nextCache", "currentMonthStrs", "prevMonthStrs", "buildMonthCache", "monthStrs", "guessISOYear", "unshift", "primaryEraMilli", "implClasses", "arguments", "iso8601", "queryCalendarImpl", "toLocaleLowerCase", "good1582", "goodIslamic", "goodEpochMillis", "hasBugByID", "checkEpochMilliBuggy", "hasBug", "goodEpochMilli", "impl", "badEpochMilli", "computeFirstWeekOffset", "firstDay", "minimalDays", "firstWeekDay", "computeWeeksInISOYear", "weekOffset", "weekOffsetNext", "innerCalendar", "isoToEpochNanoSafe", "dayOfWeek", "dayOfYear", "weekOfYear", "week", "weeksYear", "daysInWeek", "daysInYear", "calFields", "dateFields", "daysFromTime", "dateArg0", "dateArg1", "largestUnitStr", "generalSign", "monthSign", "daySign", "inFields", "baseFields", "additionalFields", "merged", "anyAdditionalYear", "anyAdditionalMonth", "obj0", "obj1", "calendar0", "calendar1", "diffPlainDates", "refinedOptions", "pd0", "pd1", "diffTimeScale", "dateStart", "dateTimeMiddle", "bigDuration", "timeDuration", "bigSign", "timeSign", "dateMiddle", "diffInstants", "toZonedDateTimeISO", "inst0", "inst1", "epochNano1", "attachStringTag", "Instant", "mixinEpochFields", "mixinLocaleStringMethods", "createZonedFormatFactoryFactory", "year", "month", "day", "weekday", "hour", "minute", "second", "timeZoneName", "origLocalesSymbol", "Symbol", "origOptionsSymbol", "factoryMapSymbol", "_DateTimeFormat", "Intl", "DateTimeFormat", "constructor", "localesArg", "options", "normLocales", "normalizeAndCopyLocalesArg", "normOptions", "newOptions", "name", "val", "isObjectLike", "toString", "super", "this", "Map", "format", "dateArg", "parts", "createSingleArgs", "formatToParts", "call", "formatRange", "startArg", "endArg", "createRangeArgs", "formatRangeToParts", "origDateTimeFormat", "buildFormatFactory", "extractFormatFactoryFactory", "formatFactory", "queryFormatFactoryForType", "buildFormat", "buildEpochMilli", "TypeError", "Date", "formatFactoryMap", "get", "cachedFormats", "entity", "otherEntity", "keys", "buildKey", "key", "join", "set", "_Now", "zonedDateTimeISO", "timeZoneArg", "createZonedDateTimeFromFields", "buidZonedFields", "zonedDateTime", "calendarArg", "plainDateTimeISO", "createDateTime", "plainDateTime", "plainDateISO", "createDate", "plainDate", "plainTimeISO", "createTime", "instant", "getEpochNano", "timeZone", "getTimeZone", "TimeZone", "OrigDateTimeFormat", "resolvedOptions", "ensureObj", "buildZonedDateTimeISOFields", "calendar", "Calendar", "createLargeInt", "now", "mult", "Temporal", "PlainYearMonth", "PlainMonthDay", "PlainDate", "PlainTime", "PlainDateTime", "ZonedDateTime", "Duration", "Now", "toStringTag", "getGlobalThis", "globalThis", "window", "Temporal", "TemporalImpl", "Intl", "getGlobalThis", "DateTimeFormat", "s", "i", "m", "j", "p", "c", "c", "k", "v", "c", "options", "k", "v", "v2", "i", "r", "c", "m", "r", "a", "b", "k", "p", "c", "i", "m", "j", "_", "i", "j", "e", "k", "a", "b", "p", "re", "m", "r", "i", "router", "e", "i", "Node", "m", "p", "j", "n", "k", "a", "b", "s", "Node", "p", "Hono", "c", "util", "k", "e", "_", "objectUtil", "t", "i", "m", "x", "s", "errorUtil", "errorMap", "ctx", "result", "issues", "a", "b", "elements", "fn", "me", "processed", "p", "p2", "ZodFirstPartyTypeKind", "z", "Hono", "z", "c"]
}
